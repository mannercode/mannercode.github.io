# 소프트웨어 개발의 어려움

## 프로그래머의 기술적 고민들

### 디자인 패턴

2000년 전후로 디자인 패턴이 많은 프로그래머들에게 화자됐다. 너도 나도 공부를 하고 난 후, 반응은 몇 개로 나뉘게 되는데

- 솔직한 반응

  - 무슨 말인지 모르겠다.
  - 하여튼 디자인 패턴은 싱글톤.

- 현실 부정

  - 현실에서는 책처럼 구현하기에는 시간이 부족하기 때문에 쓸모가 없다.
  - 코드가 복잡해져서 오히려 역효과다.
  - 디자인 패턴? 이게 가능은 한가? 현실과 괴리가 크지 않나? 시간이 많이 든다. 복잡해진다.

### UML

많은 프로그래머들이 보다 체계적이고 안정적인 개발을 위해서 설계에 대한 필요성을 느끼고 있었고,
그런 이유로 UML에 대한 적극적인 학습(?)시도가 있었다.
누군가는 Rational Rose와 같은 UML 툴만 잘 쓰면 코딩 없이 개발이 가능하다는 얘기를 하기도 했다.

개인적으로 UML을 볼 때 마다 묘한 감정이 드는데 UML을 만든 그래디 부치의 책을 보면 내 한계를 절감한다.

### REST API

### MSA(Micro Service Architecture)

- TDD를 적용하려고 한다. 안 된다. 비용이 높다. 어떻게 테스트를 하나. 무엇을 테스트 하나
- UML을 사용해서 설계를 해보려는데 잘 안 된다. 무엇을 어떻게 작성해야 하는가?
- ?? rest api를 설계하기 어렵다. collection? entity? 이해가 안 된다.
- msa 아키텍처를 해보려고 하는데 어렵다. 시작은 순조로우나 얼마 안 가 쓸데없이 복잡해진다. 좋아보이기는 하는데 쓸데없다.

- 이름 짓기 힘들다. 변수? 함수? 이름이 길어진다. 줄이면 모호하다.
- 새 프로젝트를 어떻게 시작해야 할 지 모르겠다. 새로 시작할 때 기본 기능부터 구현한다. 혹은 DB 설계부터 한다.
- 프로젝트 종료 후 작성하는 문서가 얼마나 쓸모있나? 의미있는 설계문서는 무엇인가?

왜 이런 일이 벌어지는가?

## 왜 어려운가?

특허회사에서 일했었다. 특허 도메인이 많이 복잡하다. 이것을 이해해야 한다.
복잡한 업무를 효율적으로 처리하기 위해서 소프트웨어를 만드는 것이기 때문에 복잡한 업무를 이해하는 것은 자연스럽다.

> 이런 시스템의 자체기눙도 제대로 파악하기 벅찬데 여기에 사용성과 성눙, 비용, 생존성, 신뢰성 등 모든(일부는 묵시적인) 비기눙 요구 사항을 더해 보라. 이렇게 여과되지 않은 외부 복잡성온 브룩스가 말한 임의 복잠성을 초래한다.
>
> 다수의 사용자를 대상으로 하는 일정 규모 이상의 소프트웨어는 대체로 복잡하다.
> 소프트웨어의 복잡성은 소프트웨어의 유연성과 도메인(문제영역)의 복잡성에서 비롯되는 본질적 문제이다.
> 프로그래머의 실력이 좋을수록 소프트웨어의 복잡성에서 비롯되는 다양한 문제를 능숙하게 다룬다.

```

# 도메인

도메인(Domain)은 '문제 영역'으로 번역되고는 하지만 그 보다는 '관심 영역'이라고 할 수 있다.
예를 들어, '공연 예매 시스템'을 개발한다면 공연명, 공연시간, 공연장소, 좌석, 티켓가격 등등이 도메인이 된다.
복잡한 작업을 보다 쉽고 효율적으로 처리하는 것이 소프트웨어의 존재의의라고 한다면 도메인이 복잡한 것은 필연이다.

```

### 요구사항을 구체화 하기 어렵다.

외부 복잡성은 보통 시스템 사용자와 개발자 사이에 존재하는 '의사소통의 벽'에서 발생한다.
대체로 사용자는 개발자가 알 수 있는 형태로 자신들의 요구 사항을 정확히 표현하지 못한다.
어떤 경우에 사용자는 소프트웨어 시스템에서 필요한 것에 대한 막연한 생각만 하고 있을 뿐이다.
이는 소프트웨어 사용자나 개발자 잘못이 아니다.
각 그룹이 다른 도메인에 대한 전문성이 결여됐기 때문에 발생하는 일이다.
사용자와 개발자는 문제 성격을 바라보는 시각이 다르고 해법에 대해서도 서로 다르게 가정하기 마련이다.
사실 사용자가 자신둘의 펄요 사항에 대해 완벽한 지식을 가졌다 하더라도, 현재로서 그런 요구 사항을 정확하게 집어낼 도구가 거의 없다.
요구 사항을 표현하는 방법을 보면, 보통 그림으로 설명한 것은 별로 없고 문장으로 서술한 것이 많다.
이런 문서는 이해하기 어렵고 여러 의미로 해석될 우려가 있으며 펄수 요구 사항이라기보다는 설계 요소를 포함하는 경우가 많다.
더 혼란스러운 것은 소프트웨어 시스템의 요구 사항이 개발 단계에서도 자주 번경된다는 사실이다.
소프트웨어 개발 프로젝트의 존재 자체가 문제를 푸는 규칙을 변경시키는 일인 걸 어떡하랴.
설계 문서와 프로토타입 같은 초기 산출물을 본다거나, 그대로 설치해 동작하는 시스템을 한번 사용해 보면, 사용자는 실제 필요한 것을 더 잘 알게 되고 또 설명할 수도 있게 된다.
동시에 이 프로세스는 개발자가 문제 영역을 확 실히 알도록 돕고, 시스템이 실현할 동작 중에서 분명치 않은 구석진 곳을 부각시킬 수 있도록 질문을 유도한다.

### 요구사항은 계속 변경된다.

소프트웨어로 가능해진 유연성
주텍 건설업자는 대체로 목재를 확보할 목적으로 목재 농장을 운영하지는 않는다. 건 측 회사가 새 건물에 쓸 맞춤형 철제 대둘보를 단조하려고 현장에 제강 공장을 세우 는 일도 국히 드물다. 하지만 소프트웨어 산업에서 이런 관행은 보통이다. 소프트웨어 는 마지막까지 유연성을 제공하므로, 개발자로서는 어떤 종류의 추상화도 표현할 수 있다. 이런 유연성은 믿을 수 없이 매력적인 속성으로 밝혀졌지만, 개발자가 상위 수 준 추상 개넘을 올려놓을 뼈대에 해당되는 구성 요소까지도 수작업으로 공둘여 만들 게 된 요인이기도 하다. 건측 산업에서는 일관성 있는 건물 기준과 표준을 써서 원자 재 품질을 관리하는 체제를 갖춘 반면, 소프트웨어 산업에는 이런 표준이 거의 없다. 결과적으로 소프트웨어 개발은 노동 집약 산업 수준에 머물러 있다.

## 어떻게 해야 하는가?

복잡한 것은 주로 계층 구조 형태다. 복잡한 시스템은 종류' 계층과 ■-부분' 계층으로 모델을 작성하면 유용하다.

### 요구사항을 구체화 해서 생각이 맞는지 사전에 확인 -> 분석

이것이 가장 어렵다. 진정 의미하는 바가 무엇인지 통찰하는 능력은 쉽지 않다.

### 요구사항을 예상하지 말고 변화에 대응하는 것에 초점 -> 설계

80년대에 지어진 아파트는 집에서 바로 쓰레기를 버릴 수 있는 투입구가 있었다.
그러나 1991년에 분리수거가 시행되면서 이 투입구는 사용할 수 없게 된다.
쓰레기를 수거하는 방법이 변했으나 쓰레기 투입구 시스템은 그런 변화에 대응할 수 없도록 설계된 것이다.
이것은 쓰레기를 수거하는 방법이 변할 수 있다는 고려를 하지 않았기 때문이다.

주택의 수명을 30년으로 보면 수명주기 동안 많은 변화가 있다.
미세먼지가 문제 되면서 이제는 전열교환기가 기본이 됐다.
자동차를 소유하는 가구가 많아지면서 주차장이 부족해지고 위험해 지면서 지하주차장이 생겨났다.
누르면 단순한 기계음이 나던 초인종은 거실에서 1층의 문을 열어주고 엘리베이터를 부를 수 있다.
아, 연탄 보일러가 가스 보일러가 됐고 가스렌지는 전기렌지가 됐다.
전화선과 TV단자도 랜으로 통합된다.

소프트웨어 설계는 변화를 예측하고 대응 방법을 강구하는 것이다.
어떻게 변할 것인지는 알 수 없다. 변화가 발생할 때 그 변화의 영향이 최소화 되도록 만들어야 한다.

MSA, MVVM 등은 유명 아키텍처는 무엇이 변할 수 있고 그 영향을 최소화 하기 위해 의존성/응집성을 고려한 방법을 제시한 것이다.
디자인 패턴은 변화가 예측될 때 어떻게 대응하면 좋을 지를 제시한 것이다.

### 잦은 코드 변경에 대응 -> 읽기 쉬운 코드, 테스트 자동화

## 어떻게 할 수 있는가?

글을 잘 쓰는 방법과 같다.(많이 생각하고,읽고,쓰고)

ㄹㄹㄹ

### 많은 책을 읽는다.

DDD,TDD,OOP,Refactoring, Pattern

### 많이 고민한다.

자신의 코드를 어떻게 개선할 것인가를 고민한다. 책을 읽어도 어떻게 그 내용으로 코드를 개선할 것인지를 생각해라.

### 자신의 코드를 계속 개선한다.

고민을 실제로 적용해 보고 문제를 파악하고 개선한다.

### 이 글을 쓰는 이유다.

```

```

# 소프트웨어 개발의 어려움

소프트웨어는 논리와 개념으로 구성되는 무형의 결과물이다.
프로그래머는 소프트웨어의 이런 특성에서 비롯되는 많은 문제를 다루게 된다.

### 분석/설계

무형의 결과물이라는 소프트웨어의 특성은 머리속에 있는 생각을 구체화 하기 어렵게 만든다.
따라서 클라이언트의 생각을 온전히 기획서에 반영하기 힘들고, 잦은 오류가 생긴다.
기획자가 미처 생각하지 못한 많은 시나리오가 구현 단계에서 나타나는 것도 이런 이유다.
생각을 구체화 하는 과정이 설계다. 설계 문서를 어떻게 작성할 수 있을까?
생각을 그냥 문장으로 표현? 무엇부터 시작해야 할까?
문제의 시작이다.

분석 단계에서 누락된 시나리오는 설계 전체에 영향을 미친다.
프로젝트가 진행되면서 개념이 구체화 되고 설계에 반영되면서 견고해진다.
그러나 언제든 변화에 대응 할 수 있도록 유연한 구조를 가져야 한다.
MSA가 현대적인 아키텍처 중에서 가장 많이 언급이 된다.
그러나 msa를 적용하는 데 실패했다는 사례가 많이 나온다.
왜 그럴까?

### 구현/테스트

분석/설계가 개념적이고 추상적인 논리 레벨이라면 구현/테스트는 실제적이고 구체적인 물리 레벨로 구분할 수 있다.
잦은 설계 변경에 따른 어려움은 어쩔 수 없다 하더라도. 테스트 자동화를 하고 싶지만 어떻게 해야 할지 모르겠다.
의존 주입을 최상위까지 가능해야 하는데 그게 안 되고 있을 가능성도 있다.
의존성/응집성을 제대로 관리한다면 테스트 하기 좋은 코드가 된다. 외부의 변화에 유연한 대응을 하는 구조라면 당연하지 않은가?

### ddd와 rest api

ddd에서 얘기하는 entity와 collection을 이해해야 rest api가 가능하다
entity를 정의하려면 분석 단계가 잘 되어야 한다.

### 일반적인 코딩 접근 방법

프로젝트A를 시작할 때 경험이 많지 않은 프로그래머는 가장 작은 함수부터 시작한다.
bottom-up 방식이 나쁜 것은 아니다. 사용하려는 기술에 익숙하지 않을 때, 무엇이 가능한지 기능 파악조차 안 된 상태에서는 bottom-up이 적당하다.
새로운 기술, 연구과제 등등이 있겠다.
상용 제품이나 서비스에는 bottom-up 보다는 top-down 접근이 유용하다. 그러나 프로그래머는 top-down에 익숙하지 않아서 이 마저도 bottom-up으로 진행한다.
왜 bottomup으로 하게 될까? 이렇게 했을 때 어떤 문제가 있을까?
설계 문서를 작성하라고 하지만 어떻게 해야 할 지 모른다.
주변에서 테스트 자동화 혹은 TDD를 얘기하지만 정작 테스트를 어떻게 작성해야 하는지 막막하다.

rest api를 정의하기 어렵다. entity? collection?
현대적인 개발 인프라에서 제시하는 가이드를 충실히 따라가기도 어렵다.
docker? msa? ddd? 그게 과연 적당한가? 의문도 든다.

분석 결과물이 구체적이고 명확하지 않으니 구현하는 입장에서 top-down 접근이 어렵다.
그러니 프로그래머 입장에서 구체적으로 드러난 부분부터 시작하게 되는데 그게 주로 가장 하위 레벨에 있는 작업들이다.
db에서 뭔가 읽어오거나 소켓 통신을 하는 등.
자연스럽게 객체의 정의는 DB table을 따라가게 된다.
자연스럽게 bottom-up으로 되니 최종 결과물을 확인하기 까지 시간이 걸리고 의도와 다름을 뒤늦게 인지한다.
산으로 가는 프로젝트의 전형이다.

### 해결책은 설계문서

흔히 설계문서를 작성해야 한다고 누군가 말한다면 그 사람도 잘 모르고 하는 이야기다.
그저 소프트웨어 품질에 문제가 있다의 다른 표현일 뿐이다.

### 현재 프로젝트가 일반적인 상황

db는 오래전부터 유지되어 왔고 상황에 따라서 조금씩 추가됐다.
프로젝트를 두 번 다시 만들었는데 처음 한 번은 react를 모르고 급하게 만드느라, 두 번째에 db정리하고 제대로 구현하게 됐다.
언제 이 프로젝트 썰 푼다.
