mannercode.com 중급 강좌 / 프로젝트 에세이
coderani

1. 실력향상 방법재사용 가능하게 라이브러리로 만든다. 모듈 분리 과정에서 분석 능력 향상. 의존 관계가 드러난다. 라이브러리가 프레임워크가 된다. 응집성/의존성은 설계의 기본. TDD까지 이어진다. 모듈화는 중급의 시작이다.하나의 함수를 여러개로 나누고, 하나의 클래스를 여러개로 쪼개는 과정에서 요소/개념/논리가 드러난다.소프트웨어는 논리와 개념으로 이루어진 무형의 산물이다. 형태가 명확하지 않기 때문에 개개인의 역량에 따라서 보이는 것이 달라진다.이렇게 분리가 되어야 복잡도를 제어할 수 있다. 한 함수나 클래스에 많은 기능이 몰리면 다루기 어려운 것은 자명하다. 라이브러리로 만들면서 API를 생각하게 된다. API가 특정 프로젝트에 종속되지 않도록 일반화를 고민하다 보면 좋은 모듈이 된다.
2. 강좌의 특징무엇이?가 아니라 왜?에 집중한다. DDD가 무엇인가? TDD가 무엇인가? 아니라. 왜 DDD가 필요한가? 왜 TDD가 필요한가? DDD에서 왜 레이어드가 필요한가? 등등. 왜 사용하는지 알아야 바르게 사용할 수 있다. 무엇만 알면 적재적소가 어렵다. 과거 디자인패턴이 그랬고 UML이 그랬다.
3. 좋은 코드란 무엇인가?응집성/의존성이 잘 관리된 코드다. 좋은 코드는 외부의 변화에 크게 흔들리지 않는다. 시장 상황이나 사용하는 기술 개발인력 등은 앞으로 어떻게 변할지 예측하기 어렵다. 무리해서 예측하고 대응하는 코드를 작성해 봤자 예측이 틀리면 작성한 코드도 무용지물이고 부작용만 남는다. 변화에 대응하도록 코드를 작성해야 한다.
4. 테스트는 어느 정도 작성해야 하는가? 모든 케이스에 대응해야 하는가? 적절한 기준은 무엇인가?절대적인 기준선은 없다. 프로젝트의 중요도, 가용시간 등에 따라 달라진다. 이것은 경험을 통해서 각자 판단해야 할 듯.
5. 현실과 이상의 괴리, 디자인패턴이나 OOP를 공부해도 실무에서 적용할 시간이 없다. 소용없는 것 아닌가?무엇이 옳은 것인지, 무엇이 좋은지를 알아야 잘못된 것도 알 수 있다. 평소에 이런 지식을 쌓아두면 실제 프로젝트를 진행하면서 기술부채가 얼마나 쌓여가는지 가늠이 된다. 가늠이 되어야 리스크 관리가 된다. 또 100만큼 공부한 것과 10만큼 공부한 것은 실무에서 같은 시간 동안의 결과물이 다르다.
6. 생각은 계속 바뀌고 자신의 생각도 다 모른다. 의도를 파악하는게 중요하다. 서로 생각하는 것이 맞는지 최대한 빨리 구체화 해서 확인하는 것이 필요하다. 테스트 자동화와 자연스럽게 연결이 된다. 화면 구현하고 스텁코드 작성한다. 이후로 하나씩 구현해 나가면 된다. 어떻게 구체화 시키는가? 사용자의 행동/행위를 정의하고 그에 따른 도메인을 파악하는 식이다.
7. 좋은 설계는 변화에 쉽게 적응하는 것 -> 응집성/의존성, 성능은 속도 혹은 공간의 사용을 최소화 하는 것 -> 시간/공간 사이의 맞교환
8. 디자인패턴/리팩토링 같은 기본만 알면 된다. 나머지 응용패턴은 쉽게 습득 가능하다.

고민
1. 프레임워크를 사용하지만 안의 내용을 모른다. 막연한 불안감을 느낀다.
2. 난잡한 코드 유지보수를 하고 있다. 지금 하는 이 일이 나에게 도움이 되나?

설계
1. 문서 즐겨찾기를 위한 타입, 문서 뷰어를 위한 타입은 항목이 어느 정도 겹칠 것이다. 그렇다 하더라도 Favorite, Document를 구분해야 한다. 이것은 서버에서부터 이렇게 나왔어야 한다. 하나의 타입을 다양한 작업에 사용하면 그 작업들은 하나의 타입에 서로 의존하게 되는 것이다.
    1. 이것은 틀렸다. 애초에 설계가 잘못된 것이다. 문서 즐겨찾기라면 favorites에 Document가 포함되어야 한다.
2. FolderList, FolderItem, Entity는 구분해야 한다. entity를 담고 있는 폴더 구조가 있다면 이것은 어떻게 보여주겠다는 표현이다. 여기에 entity 전체를 담는 것은 두 기능이 조합되는 것이다. folder는 출력/선택에 꼭 필요한 entity의 id와 name 정도만 가져야 한다.
3. id를 가지고 getFile 하는 코드를 한 곳에 둘 것이 아니라. id를 아는 곳에서 getFile을 해서 file을 넘겨줘야 한다. 무엇으로 어떻게 얻을 것인지는 제각각이다. id로 네트워크에서 혹은 string에서 binary로 얻을 수도 있다.
4. 오버엔지니어링 - 일단 만들고 리팩토링 하면서 파악. 중요한 것은 변화에 대응하는 코드다.  변화에 대응하려면 분석이 정확해야 한다.
5. 분석의 시작은 누가? 무엇을 어떻게 하는가? 그래서 보통은 유스케이스가 시작인데 참여자와 행위가 모두 나타난다. 그러나 이것은 행위자가 분명한 서비스를 개발할 때 유용하다. 복잡한 내부 시스템 설계는 어찌하는가?이것은 누군가에게 무엇을 제공하는 서비스이기 때문이다. damon으로 동작하는 프로그램처럼 UI가 없는 다른 경우도 많다.
6. 전역을 지나치게 피하는 것도 문제다 app 전체가 공유해도 되는 state는 전역으로 관리하는게 맞다. 이것을 주고받는 비용이 너무 크다. react는 상태 기반 구조다. 값이 바뀌면 바로 알 수 있다. 전역으로 두더라도 직관성을 잃지 않는다. 상태를 기반으로 바뀌는 구조다. 누가 바꾸는지는 상관하지 않는다. 그러니 값이 전역이든 아니든 상관없다. 이런 것은 전역이 맞는 것이다. 그러나 상태가 아니라면? 옵저버가 아닌 그저 프로퍼티라면 변경 될 때 동작은 제각각이다.  값을 변경할 때 누가 무슨 일을 해야 할지 누구에게 알려야 하는지 알 수 없다. 싱글톤으로 만들면 되긴 한다마는... 그래도 값에 직접 접근하는 것은 막아야 한다.
7. usercontext에 사용자 정보/즐겨찾기 등등 모든 것을 넣으려고 했다. 잘못이다. 하나에 다 뭉쳐있으니 마이그레이션도 힘들다. getUser하면 한 번에 가져오는 것은 괜찮다 그러나 setUser 할 때 모든 정보를 넣지는 말아라.
8. 어떻게 테스트 할 것인가에 대한 고민은 SUT의 역할이 무엇인지를 생각하게 한다. controller의 역할은 입력값을 service에 잘 전달하는 것이다. service를 호출하는 지를 보는게 맞다.
9. ApprovedKycItem, KycApprovedItem 무엇이 맞는가? Kyc처럼 category가 앞에 오는게 좋다. 동작이 앞에 오면 WaitingKycItem, ApprovedKycItem 처럼 된다. 동작으로 구분하는 것이 맞는 것인가? 대분류는 Kyc이다. Waiting/Approved는 중/소분류다.물론, 네임스페이스나 모듈로 구분하는 것이 더 낫다.
10. user와 userIduser 측면user의 인증을 관리하는 것. 의미적으로는 이게 맞다. 나중에 user의 무엇이 필요할지 모른다.userId 측면MSA에서 user 전체를 던지지는 않는다.꼭 필요한 정보만 -> 의존성 최소화user 정보가 필요하면 usersService에 쿼리하면 된다.usersService가 아닌 다른 서비스에서 삭제 할 수 있다.auth는 user aggregate에 포함하지 않는다.



사회
1. 내가 아무리 실력이 좋고 열심히 해도 그것은 단지 +요인이고 자신의 -요인이 사라지는 것은 아니다. +와 -는 같이 존재한다.
2. 모든 것을 논리적으로 설명할 수 없다. 대부분은 과정은 잊어버리고 결과만을 기억한다. 내가 이해하지 못한다고 해서 논리의 과정부터 결과까지 상대방에게 제대로 설명을 요구하는 것은 잘못이다.

chodingcode.com
realizecode

에세이
1. 좌석도 아이폰 부터 웹까지 어떻게 발전시켰나
2. 파포인트 어떻게 리팩토링 했는가
3. 기존에 개발된 솔루션이 있을 경우 한 번에 파악이 힘들다. 이유는 개념정의가 제대로 안 되어있고 양도 많기 떄문이다. 새로 만드는 경우 분석에 매달리지 말고 일단 구현하면서 파악해야 한다. 변화에 대응할 수 있도록 개발하면 구현 후 리팩토링이 수월하다.
4. 문제를 덮는다. 면밀하게 코드를 살피지 않고 현재 발생하는 오류만 발생하지 않도록 수정한다. 그 수정이 다른 오류를 발생시키는 것은 신경쓰지 않는다.

개발 경험

리액트를 모르는 상태.
급하게 구현해야 함.
코드 품질을 따질 상황이 아니고 다양한 시나리오나 테스트를 꼼꼼하게 하지도 못함.
시간이 없기 때문에 시나리오 체크 겸 테스트를 다른 사람에게 넘김.
보고 받는 오류만 그 때 그 때 수정함.
처음부터 튼튼하게 잘 만드는게 아니라, 급하게 기둥 세우고 물 새는 곳을 틀어막으면서 높은 건물 쌓는 느낌.
의외로 처음부터 잘 만드는 것 보다 난이도가 높았음.
테스트 자동화, 충실한 코드 정리, 잘 정리된 개발환경 등이 생산성에 영향을 준다.
그러나 그런 요소들에 얼마나 시간을 써야 하는가에 대한 고민은 늘 남는다.
일정이 급할 때 내리는 결정에서 조금 여유를 가지는 정도가 최적이지 않을까.
어느 정도까지 품질을 타협할 것인가. 남은 시간과 일의 중요도를 저울질 하는 등 경험이 필요.


기존 DB가 엉망인 상황에서 개발
기존 DB는 그대로 두고 읽기 전용 DB를 새로 구축.
기존 DB의 데이터를 읽기 전용 DB로 재정리
백엔드는 읽기전용에서만 접근

인재가 들어오면 보호가 필요하다.
기존 인력의 텃세는 크다.
왜 텃세가 생기는가. 새 인력이 자기 자리를 위협하기 때문이다.
새 인력은 그럴 생각이 없음에도 말이다.
