좋은 코드를 작성하기 위해서 필요한 공학적 지식과 기술을 습득하는 것은 결코 쉽지 않다.
좋은 코드를 작성하기 위한 다양한 개발 방법들을 살펴보고 그들의 특징과 변화와의 관계를 알아보자.

## 리팩토링

리팩토링은 기능은 그대로 두고 코드를 개선하는 것이다.
이것은 성능 최적화와 구분이 되는데 둘 다 기능은 그대로 두고 코드를 변경하지만 리팩토링은 코드를 읽기 쉽고 변경하기 쉽게 만드는게 목적이다. 반면에 성능 최적화는 코드가 아닌 성능을 개선하는 것이 목적이다. 그렇다고 리팩토링과 성능 최적화가 무관한 것도 아닌데 성능 최적화 또한 코드 변경을 통해서 이루어지기 때문에 리팩토링이 잘 되어있다면 성능 최적화 또한 수월하게 할 수 있다. 리팩토링이 성능 최적화의 기반이 된다는 것에 주목하자. 처음부터 성능을 신경쓰면서 코드를 작성하면 대게는 복잡해지고 코드를 이해하기 어려워진다. 이렇게 작성된 코드는 리팩토링이 힘들고 결국에는 프로젝트 전체에 걸쳐서 부담을 준다. 리팩토링이 잘 되어있다면 성능은 프로젝트가 거의 마무리 된 단계에서 프로파일러로 측정하고 개선하는 것이 효율적이다.

리팩토링을 제일 처음 소개하는 이유가 있는데 리팩토링이 이후에 서술할 다른 개발 방법들을 이해하기 위한 좋은 출발점이 되기 때문이다.\
SQL과 같은 특수한 목적의 언어가 아니라면 현대적인 프로그래밍 언어는 대부분 OOP개념을 지원하기 때문에 프로그래밍 언어를 공부하면서 OOP에 대한 공부도 약간씩은 하게된다. 그러나 그것은 class의 문법을 익히는 정도이지 OOP의 개념을 깊게 이해하는 수준은 아니다. OOP는 많은 개발 방법의 근본이 되는 원리이지만 추상적이고 그 만큼 이해하기도 어렵다. 리팩토링은 나쁜 코드를 좋은 코드로 바꿔가는 과정에서 자연스럽게 OOP를 경험하게 한다.
<!-- 널오브젝트 소개, 널도 객체가 될 수 있다 -->

<!-- '시간적 범위'를 다시 정리하자. 리팩토링이 광범위한 영향을 주더라도 프로젝트 막바지라면 시간적으로는 적은 영향을 준다. 함수의 이름을 변경하는 것은 프로젝트가 진행되더라도 언제든지 거의 동일한 비용으로 수행할 수 있다. 시간이 지나도 작업량이 늘어나지 않는 것이다. -->
경험이 적다면 언제 리팩토링을 해야 하는가에 대한 고민이 많을 것이다. 나의 경우에는 리팩토링의 결과가 미치는 '시간적 범위'를 고려한다. 함수의 이름을 변경하고 중북된 코드를 정리하는 수준의 간단한 리팩토링은 많은 부분에 걸쳐서 영향을 주지는 않기 때문에 시간이 허락하는 범위 안에서 최대한 하는 편이다. 누군가는 글로벌 함수의 이름을 변경하는 것은 전체에 영향을 주는 것이 아닌가라고 생각할지 모른다. 그러나 함수 이름을 변경하는 것은 개발툴이 할 일이기 때문에 프로그래머의 작업량이 늘어나지는 않는다. 그래서 언제 해도 상관없다.

> javascript는 type이 없기 때문에 개발툴에 의한 이름 변경에 한계가 있다. 가능하면 typescript를 권장한다.

만약 더 좋은 코드를 작성할 수 있는 새로운 방법을 알게됐다면 그 즉시 리팩토링을 하는 것이 좋다. 새로운 방법이란 라이브러리나 프레임워크의 몰랐던 사용법일 수도 있고 기존의 구조적 문제점을 개선할 수 있는 아키텍처가 될 수도 있다. 이런 보다 효율적인 방법들은 프로젝트가 많이 진행되지 않은 상태에서 알게되는 경우가 보통이기 때문에 미룰수록 손해다. 이것을 미루면 프로젝트가 진행될수록 문제점도 커지기 마련이다.

리팩토링을 하면 안 되는 경우가 있다. 고치는 비용이 너무 큰 경우인데 아파트도 수 십년 지나면 재건축을 하듯이 프로젝트도 마찬가지다. 불행히도 2~3년도 버티지 못하고 새로 만들어야 하는 경우도 많다. 왜 그럴까? 단순히 좋은 코드를 작성할 수 있는 프로그래머는 많지 않기 때문이다. 한 프로젝트에 많이 프로그래머가 참여했거나 진행이 오래됐다면 이미 꼬일 만큼 꼬여있는 경우가 대부분이다. 다시 만든다고 해서 기존에 만들었던 시간 만큼 드는 것은 아니다. 요구사항이 구체화 되어있고 어떻게든 동작하는 소프트웨어가 있기 때문에 판단과 시행착오를 줄일 수 있다.그러니 다시 만들 수 있다면 망설이지 말고 다시 만들어라. 물론 더 잘 만들 자신이 있어야 한다.

기억에 남는 몇 가지 리팩토링 방법들이 있다.

case2.
함수와 전역 변수를 잘 모으면 클래스가 된다.
범위를 조금 확장해서 클래스 레벨에서 좋은 코드를 찾아보자.

## 디자인 패턴

종종 디자인 패턴을 클래스 수준에서 적용하는 기술로 알고있는 프로그래머들이 있다. 그러나 이것은 말 그대로 패턴이기 때문에 다양한 곳에서 나타난다. MSA에서 Message Broker는 옵저버 패턴이다. API Gateway는 facade의 일종으로 해석할 수 있다.
GoF의 30가지 패턴들은 어떤 문제가 있을 수 있고 어떻게 해결하면 좋은지를 소개한다.
전략 패턴에서 아래의 코드를 좋은 구조라고 소개한다.
왜 이런 구조를 지향하는 것일까?
다른 구조를 가지는 다른 패턴들은 왜 존재할까? 특징이 무엇일까?

> Impl을 직접 사용하지 않고 interface로 접근하는 다양한 예를 제시한다.
> 의존성을 관리해서 변화에 대응하는 전형적인 방법을 보여준다.

## OOP
OOP가 다른 개발방법의 기본이 되면서도 비교적 늦게 소개하는 것은 그 만큼 이해하기 어렵기 때문이다. 학습의 순서가 OOP->리팩토링->디자인패턴이 될 것 같지만 실제로는 리팩토링과 디자인패턴을 열심히 연습하다 보면 OOP에 대한 이해가 조금씩 깊어진다. 아래의 내용 중 상당수는 UML을 만든 그레디 부치의 저서 'Object-Oriented Analysis Design with Applications'에서 인용한 것이다. 프로그래밍 이론서를 딱 하나만 선택해야 한다면 이 책을 추천한다.

OOP는 도메인을 객체 단위로 분석/구현하는 프로그래밍 기법이다. 왜 객체 단위로 분석을 할까? 그것이 현실의 개념과 잘 맞기 때문이다.
아래의 코드를 비교해 보자

> if-else 구문으로 프로그래밍을 하면 아무리 함수로 분리한다 해도 if-else가 중첩되는 등의 문제가 있을 것이다. OOP vs 절차식(알고리즘) 사례를 찾아보자
> https://www.geeksforgeeks.org/brief-overview-comparison-of-object-oriented-programming-from-c-to-java/

> https://www.geeksforgeeks.org/differences-between-procedural-and-object-oriented-programming/

이런 OOP의 5가지의 원칙이 있다.

> SOLID 원칙 소개

객체지향코드는 분석이 어렵다. 알고리즘 코드는 한 곳에 있고 호출하는 함수도 간단하고 어떤 값을 가져오는지 알기쉽다.
객체지향은 일처리를 다른 객체에 위임하고 결과만 받는다. 코드는 어딘가에 분산되어 있다.
객체지향을 잘 분석하기 위해서는 거기에 사용된 아키텍처를 이해하고 있어야 한다.
코드에 아키텍처라고 부를만한 것이 없다면 OOP든 알고리즘이든 어렵기는 마찬가지가 된다.

OOP는 쉽지 않다.

> 엔터프라이즈 아키텍처 36p
> 도메인 모댈(122)을 사용하는 데 따르는 비용은 사용의 복잡성과 데이터 원본 계층의 복잡성이 다. 리치 객체 모델을 처음 시작하는 개발자가 도메인 모댈(122)에 익숙해지는 데는 시간이 펼 요하다. 이 패턴을 사용하는 프로젝트에서 몇 달 동안 작업한 후에야 비로소 사고방식의 전환을 이루는 경우도 많다 일단 도메인 모댈(122)을 사용하는 데 익숙해진 후에는 이후의 모든 작업 이 수월해진다. 필자와 같은 객체 신봉자가 이렇게 한 명 늘어난다. 그러나 이러한 전환을 끝내 이루지 못하는 개발자들도 상당수 있다.

## Layerd Arch

\*\* 전체적으로 엔터프라이즈 아키텍처를 참고해서 설명한다.

> 마틴 파울러, 엔터프라이즈 아키텍처, 9p, 들어가며
>
> 필자가 가장 중요하게 여기는 아키텍처 패턴은 계층(layer)의 아 키텍처 패턴이며 이에 대해서는 1장에서 자세하게 다룬다. 요의f하면 이 책은 엔터프라이즈 애 플리케이션을 계층으로 분할하는 방법과 이러한 계층이 상호작용핸 방법에 대한 책이다. 중 요한 엔터프라이즈 애플리케이션은 어떤 형식으로든 계층형 아키텍처를 사용하지만 경우에

레이어로 나눌 때 주의해야 할 것은 무리하게 캡슐화 하려는 욕심이다.
각각의 레이어는 독립적이다. 적어도 상위 레이어를 알 수 없다. 각 레이어를 오고 갈 때 dto를 통한 변환 작업이 이루어진다.
적어도 db->model이 그렇다. model->service도 인터페이스(microservice, rest api)에 따른 변환 작업이 필요하다.
이것을 DB에서 Service까지 아우르는 하나의 클래스로 캡슐화(공통화) 하면 각각의 레이어에서 발생하는 변경사항이 전체 레이어에 영향을 준다. 이것은 레이어로 나눈 것이 아니다.

> 계층은 전체가 효과적으로 캡슐화되지 않는다 그 결과 뭔가를 변경했을 때 다른 계층에 영흔F을 미치는 경우가 있다 계층형 앤터프라이즈 애플리케이션에서 볼 수 있는 전형적인 예는 UI에 표시해야 하는 필드가 데이터베 이스에도 있어야 하므로 그 시이어| 있는 모든 계층에 해당 필드를 추가해야 한다는 것이다‘

레이어를 엄격하게 나누는 것에 대해서 마틴은 아래와 같이 우려했다.

> 사실 필자가 지나치게 독단적으로 주장하는 것은 아닌지 염려스러운 마음도 있다. 앨런 나이트 는 이 책을 검토하면서 “이 논리를 UI에 넣는 것은 지옥으로 들어가는 문일 수도 있고 독단적 순수주의자만 반대할 완전히 합리적 선택일 수도 있다”라고 이야기했다. 우리가 염려히는 것은 둘 다 맞는 이야기이기 때문이다.

내 생각에는 레이어로 나누는 것은 대규모 혹은 다수의 참여자를 고려한 것이다. 그렇다면 다소 불편함이 있더라도 일관성을 유지하는 것이 옳다고 믿는다. 지금은 괜찮아 보여도 시간이 지나고 변화하면서 결국엔 일관된 코드를 지향하게 된다. 물론, 프로젝트의 규모와 수명 등을 종합적으로 고려해야 할 것이다.
위의 마틴의 언급은 2002년에 출판된 책에 실린 것이기 때문에 마틴도 생각을 바꿨을지도 모른다.

## 아키텍처

몇 가지 대표적인 아키텍처를 살펴보자.
backend라면 Layerd Arch와 MSA,
frontend라면 MVC/MVVM을 대표적인 아키텍처라고 할 만하다.

### MSA 소개

MSA는 다른 서비스의 의존성을 최소화 한다.
각각의 서비스들은 다른 서비스에 독립적으로 동작하도록 개발된다.
이것은 서비스를 사용하지 않는다는 것이 아니다. 서비스의 변화에 독립적이라는 뜻이다.
시스템 레벨에서도 마찬가지다

다양한 개발언어와 팀의 상황에 맞춰서 서비스를 개발한다.
모놀리식은 통일된 도구를 사용하게 된다.
다양한 상황에 대응하는 시스템 구조 = 변화를 수용

### MVC(MVVM) 소개

MVC에서 MVP를 거쳐서 지금은 MVVM을 많이 사용하는 것 같다. .NET의 WPF는 물론이고 iOS(SwiftUI)와 android도 MVVM 구조를 지원한다.
MVC든 MVVM이든 요점은 Model과 View를 분리한다는 것이다.

### 아키텍처와 변화

이들 아키텍처의 지향점은 무엇인가? 이 아키텍처의 공통된 장점은 무엇일까?
한 부분에서의 변화가 다른 부분으로 전파되지 않도록 한다.
아키텍처는 응집성/의존성을 전반에 걸쳐 준수하도록 한다.

아키텍처는 최대한 단순해야 한다. 규칙이 복잡할수록 고려하지 못한 예외 사항이 발생하기 쉽고 대처하기 어렵다. 또한 그 만큼 외부 변화에 취약하다.

DDD는 언뜻 변화와 무관해 보일 지도 모르겠다. 요구사항의 변경은 최하위 레이어인 인프라스트럭쳐까지 영향을 준다.
도메인의 의미를 잘못 파악해서 구현하면 결국 많은 부분을 고치게 된다. 또 도메인이 변경되면 많은 부분을 고쳐야 하기 때문에 결국 변화할 수 없다. 도메인을 최상위에 놓는다는 것은 도메인이 변경될 때 영향을 최소화 하겠다는 뜻이다.
DDD는 도메인의 변화가 구현된 시스템에 끼치는 영향을 최소화 한다.

요즘의 최신 백엔드 프레임워크는 DDD에 기반한 Layerd arch와 MSA를 잘 지원하는 방향으로 발전하고 있다.

## DDD

실제 DDD에서는 도메인 전문가(고객)와 원활한 의사소통을 위해서 유비쿼터스 언어를 정의하는 것까지 소개하고 있다.
여기서 DDD는 Layerd Arch의 좀 더 발전된 혹은 세련된 아키텍처로 바라본다.
즉, Layerd Arch 보다 Domain이 중심이 되는 아키텍처를 구성하는 것을 DDD로 언급한다.
내가 DDD를 학습할 때 어려웠던 것은 Domain이 중심이 되어야 하는데 레이어는 Service->Model->Infra 순서다.
Domain은 Infra를 몰라야 하는데 아키텍처는 알아야만 하도록 구성되어 있다.

여기까지만 생각하면 레이어는 Service->Infra->Model이 되어야 할 것 같다. Model 자신이 참조하는 것은 아무것도 없기 때문에.
Model이 중심이 되는 것과 Model이 마지막 레이어인 것은 다르다. 다른 계층은 얼마든지 생길 수 있다.
그러니까 차라리 Service->Model<-Infra로 해석하는 것이 보다 정확해 보인다.

## 테스트 자동화(TDD)

### 테스트 자동화 소개

테스트가 마지막인 것은 설계 능력이 갖춰지지 않으면 TDD가 어렵기 때문이다.
우리가 흔히 이용하는 비행기에 센서가 없다고 상상해 보자. 출발 전에 문제가 발생하면 그나마 다행이겠지만 어디에서 문제가 발생하는지 알 수 있는 방법이 없기 때문에 원인을 찾기 위해서 모든 부분을 살펴봐야 할 것이다.
그리고 그것이 테스트 자동화가 갖춰지지 않은 프로젝트의 상황이다. 그럼에도 테스트 자동화를 갖추지 않는 이유는 크게 두 가지인데.(너무 당연한 3번은 제외하고)

1. 오류가 발생해도 피해가 크지 않다.
2. 비행기 만큼 복잡하지는 않아서 어떻게든 찾아낼 수 있다.
3. 너무 당연하지만 테스트를 작성하기에는 실력이 부족하다.

다양한 테스트 방법들. 유닛테스트, 엔드2엔드 테스트 등등.
여기서 언급하는 것은 주로 유닛테스트다.

### 테스트 자동화와 변화

비행기는 시간이 흐르면서 내부의 부품이 계속 마모되는 변화가 발생한다. 소프트웨어는 외부 환경이 변화한다. 변화가 어느 쪽에서 일어나든 그것은 시스템 전반에 영향을 준다. 그 시스템이 복잡하다면 테스트 없이 생존할 수 없다.
테스트 자동화는 일반적이다. 우리가 사용하는 대부분의 개발 프레임워크의 가이드를 보면 테스트가 있다.

### TDD 소개

TDD는 지속적으로 변화하는 코드를 테스트 하기 위해서다. 테스트 자동화와 TDD는 엄밀하게는 구분되어야 한다. TDD는 테스트를 주도적으로 개발하는 것인데 부수적인(혹은 주목적일지도) 효과로 인터페이스를 먼저 정의하게 되고 이것은 자연스럽게 설계 후 구현으로 이어진다.
TDD로 얻게 되는 장점으로 켄트백은 아래와 제시한다.

-
-
-

추가로 자연스럽게 설계를 우선하게 되는 것이 장점이다.

### 프론트엔드에서 테스트 자동화

react 같은 gui 프레임워크는 자동화된 테스트를 보기가 백엔드 보다 더 어렵다.
프론트엔드는 화면에 렌더링하는 코드가 대부분인데 이것은 TDD로 진행하기 어렵다.
jest에는 snapshot이라는 기능을 사용해서 정상인 화면을 사람이 확인해서 사진을 찍어둔다. 그 후 코드를 리팩토링 하거나 다른 변화로 동일한 테스트가 다른 결과가 나온다면 오류 가능성이 있는 것이다.
만약 스냅샷이 아니라 백엔드와 같은 유닛테스트로 진행한다면 테스트는 쉽게 깨질 것이고 테스트를 유지하기 어려울 것이다.
스냅샷은 테스트를 작성하기 수월하고 유지하기도 쉽다.

## 애자일 방법론

### 애자일 소개

집을 지을 때 처음 설계를 마치고 시공을 하는 중에도 끊임없이 수정하고 싶은 욕구가 생긴다. 여기에 전등을 달고 저기에 스위치를 옮기고 창은 좀 줄이고 등등.
이것은 인간이 창의적이기 때문이다. 그리고 이런 과정은 소프트웨어를 개발할 때도 마찬가지다.
요구사항은 계속 변한다. 그것이 고객의 요구이든 분석 단계에서 오류가 있든 간에 말이다.
애자일은 이런 요구사항의 변화에 대응하기 위한 개발 전략이다.

### 애자일과 변화

## cross-platform, 이 파트는 결론에 간단하게

### Java, NET 소개

.NET이 뒤늦게 나왔고 비교적 세련된 기술이다.
그럼에도 시장 점유율은 낮은 편이다. 개선된 장점이 흐름을 바꿀 만큼 크지 않은 것이다.

### Flutter, React Native 소개

### Docker 소개

> Linux® 컨테이너는 시스템의 나머지 부분과 분리된 1개 이상의 프로세스 세트입니다. 이러한 프로세스를 실행하는 데 필요한 모든 파일은 고유한 이미지에서 제공되므로, Linux 컨테이너는 개발 단계에서 테스트, 프로덕션에 이르기까지 이식성과 일관성을 유지할 수 있습니다. 따라서 전통적인 테스트 환경을 복제하는 데 의존하는 개발 파이프라인보다 사용 시점을 훨씬 더 앞당길 수 있습니다. 대중성과 사용의 편의성 때문에 컨테이너 역시 IT 보안의 중요한 부분입니다.

실행에 필요한 환경을 모두 하나의 패키지로 관리한다는 것은 응집성/의존성의 특징이다.

### 크로스 플랫폼과 변화

ios/android를 지원하는 Flutter, Java, .NET은 OS의 변화에 대응하기 쉬운 환경을 제공한다. 물론 one source multi use가 플랫폼의 의도였겠으나, 다양한 환경에 적응하는 플랫폼이라는 것은 변화에 잘 대응하는 플랫폼이라는 말과 같다.

## ORM(이것도 억지스럽네3)

### ORM 소개

ORM과 OOP의 관계

### ORM과 변화

typeorm, mybatis와 같은 ORM들은 다양한 SQL을 통일된 방법으로 사용할 수 있게 한다.
SQL 마다 문법이 조금씩 다르다. 본래의 취지는 말 그대로 Object Relation Modeling이겠으나 부수적인 효과로 통일된 인터페이스를 통한 SQL에 독립적인 코드를 지원한다.
