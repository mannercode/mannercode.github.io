<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-13T23:30:45+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Manner Code</title><subtitle>리팩토링, 디자인패턴, OOP, TDD, DDD, 아키텍처 같은 프로그래밍의 기본을 다룹니다.
</subtitle><author><name>mannercode</name><email>hello@mannercode.com</email></author><entry><title type="html">본질 기반 해석(Essence-Based Interpretation, EBI)</title><link href="http://localhost:4000/2024/05/04/ebi.html" rel="alternate" type="text/html" title="본질 기반 해석(Essence-Based Interpretation, EBI)" /><published>2024-05-04T00:00:00+00:00</published><updated>2024-05-04T00:00:00+00:00</updated><id>http://localhost:4000/2024/05/04/ebi</id><content type="html" xml:base="http://localhost:4000/2024/05/04/ebi.html"><![CDATA[<h2 id="1-소개">1. 소개</h2>

<p>나는 좋은 코드에 대해서 많은 노력을 해왔다. 좋은 코드를 작성하기 위해서 리팩토링과 디자인 패턴은 물론이고 여러 아키텍처와 개발 방법을 학습했다. 내가 작성한 코드가 잘 동작함에도 불구하고 더 나은 구조나 이름에 대해서 한참 고민하기도 했다.</p>

<p>그럼에도 불구하고 선택의 순간에 명확히 답을 내리지 못하고 오늘은 A방법으로 구현했다가 내일은 B방법으로 구현하는 일이 오랜시간 지속됐다. 왜냐하면 두 방법 모두 장단점이 명확했기 때문에 어느 한 방법을 선택해도 아쉬움이 남기 때문이다. 여기서 방법은 디자인 패턴이 될 수도 있고 함수나 변수의 이름일 수도 있다.</p>

<p>그 때의 나는 개발자로서 어느 정도 역량을 갖추고 있다고 생각했지만, 이런 선택의 고민은 아무리 많은 경험과 노력을 쌓아도 좀처럼 사라지지 않을 것만 같았다. 이 부분 만큼은 정답이 존재하지 않고 개인의 성향에 따른 선택이 있을 뿐인, 예술의 영역은 아닐까? 하는 생각도 했다. 그 만큼 나에게는 넘기 힘든 벽처럼 보였다. 마치 디자인 패턴을 이해하지 못하는 개발자들이 디자인 패턴은 실무에서 쓸모없다고 치부하는 것과 같은 방어기재였을지도 모르겠다.</p>

<p>그러다 문득 내가 놓치고 있던 것을 깨달았다. 먼저 몇 가지 사례를 살펴보고 그것이 무엇인지 알아보려고 한다.</p>

<h2 id="2-방향키의-구현">2. 방향키의 구현</h2>

<p>사용자에게 ‘상/하/좌/우’를 선택할 수 있는 방향키를 제공해야 한다. 4개 화살표의 모양은 동일하고 방향만 다르다. 이 때 방향키를 구현하는 방법이 두 가지 있다.</p>

<h3 id="21-방법1---한-개의-이미지를-회전시켜서-재사용">2.1. 방법#1 - 한 개의 이미지를 회전시켜서 재사용</h3>

<p><code class="language-plaintext highlighter-rouge">방법#1</code>은 한 개의 화살표 이미지(arrow.png)를 회전시켜서 구현하는 것이다. 화살표의 모양은 동일하기 때문에 쉽게 구현할 수 있다.</p>

<p>이 방법은 저장 공간을 적게 차지하는 장점이 있다. 그러나 코드 가독성이 상대적으로 떨어진다는 단점이 있다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"180"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"-90"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"90"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p><img src="/assets/images/arrows1.svg" alt="방향키1" /> <br />
<em>[그림 2-1] 한 개의 이미지를 회전시켜서 구현한 방향키</em></p>

<h3 id="22-방법2---4개의-이미지를-사용">2.2. 방법#2 - 4개의 이미지를 사용</h3>

<p><code class="language-plaintext highlighter-rouge">방법#2</code>는 상/하/좌/우에 해당하는 4개의 이미지를 사용하는 것이다.</p>

<p>이 방법은 더 많은 이미지 리소스를 관리하는 번거로움과 저장 공간도 더 많이 차지한다는 단점이 있다. 반면 코드의 가독성은 비교적 좋다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"up.png"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"down.png"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"let.png"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"right.png"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p><img src="/assets/images/arrows2.svg" alt="방향키2" /> <br />
<em>[그림 2-2] 상/하/좌/우 4개의 이미지로 구현한 방향키</em></p>

<h3 id="23-옳은-방법은-무엇일까">2.3. 옳은 방법은 무엇일까?</h3>

<p>무엇이 옳은 것일까? 혹은 이 선택에 있어서 옳고 그름이 존재하긴 하는 걸까? 그저 개인의 철학에 따른 선택만이 있는 것은 아닐까? 읽기 쉬운 코드를 추구한다면 <code class="language-plaintext highlighter-rouge">방법#1</code>이지만 효율성을 추구한다면 <code class="language-plaintext highlighter-rouge">방법#2</code>일 것이다.</p>

<p>읽기 쉬운 코드가 옳은가? 성능 효율적인 코드가 옳은가? 대체로 과거에는 성능 효율을 우선했겠지만 요즘처럼 하드웨어의 성능이 충분한 경우에는 읽기 쉬운 코드를 선호한다. 그런 이유로 읽기 쉬운 코드를 선택해야 할까?</p>

<p>아마도 많은 개발자들이 화살표의 모양이 같다는 것에 주목해서 <code class="language-plaintext highlighter-rouge">방법#1</code>처럼 이미지를 회전 시켜서 효율을 추구하는 방법을 선택했을 것이다.</p>

<p>다양한 생각들이 있겠지만 우선적으로 고려해야 하는 것은 화살표의 의미다. 만약 화살표가 <em>[그림 2-3]</em> 처럼 특정한 물체를 가리키는 용도라면 <code class="language-plaintext highlighter-rouge">방법#1</code>처럼 화살표를 회전시켜서 구현하는 것이 맞다.</p>

<p><img src="/assets/images/arrows3.svg" alt="방향키3" /> <br />
<em>[그림 2-3] 무언가를 가리키는 용도의 화살표</em></p>

<p>그러나 사용자가 생각한 방향키는 <em>[그림 2-4]</em> 와 같이 키보드 구석에 고정되어 있는 4개의 방향키였을 것이다. 그리고 그런 사용자의 생각과 유사한 것은 <code class="language-plaintext highlighter-rouge">방법#2</code>와 같이 4개의 이미지를 사용하는 것이다.</p>

<p><img src="/assets/images/arrows4.svg" alt="방향키4" /> <br />
<em>[그림 2-4] 서로 다른 모양의 화살표를 가지는 방향키</em></p>

<p>사용자에게 보여지는 결과물은 같기 때문에 어떤 방법을 선택해도 큰 차이는 없다고 생각할지도 모르겠다. 사용자의 생각을 무시한 채 단순히 구현 편의성만을 추구하면 어떻게 될까?</p>

<p>사용자는 언제든지 화살표의 모양을 쉽게 변경할 수 있다고 생각한다. 왜냐하면 사용자는 당연히 4개의 이미지로 구성된 방향키라고 생각하기 때문이다. 이미지를 회전시켜서 성능을 최적화 하는 것은 지극히 개발자의 입장일 뿐이다. 그리고 어느날 사용자는 방향키의 모양을 <em>[그림 2-4]</em> 처럼 변경해 달라고 가볍게 요구할 수 있다. 키의 이미지를 변경하기만 하면 되니까 쉬운 작업이라고 생각할 것이다. 그러나 개발자는 구현 방법을 바꿔야 하는 큰 일이 된다.</p>

<p>화살표의 모양이 동일한 것은 그저 우연일 뿐이다. 이런 우연으로 생긴 상황을 구현에 반영하면 사용자의 생각과 멀어지게 된다. 다시 얘기하자면 사용자의 의도를 무시한 채 구현 편의성만을 추구하면 유지보수가 점점 더 어려워 지게 된다.</p>

<h3 id="24-해석의-어려움">2.4. 해석의 어려움</h3>

<p>여러 방법을 두고 고민하게 되는 이유 중에 하나는 당연한 정보는 누락하기 때문이다.</p>

<p>사용자가 방향키를 요구사항으로 언급했을 때는 키보드의 그 방향키라고 구체적으로 설명하지는 않았을 것이다. 사용자의 입장에서는 방향키라고 하면 당연히 키보드의 그것이라고 생각하기 때문이다.</p>

<p>그러나 개발자 입장에서는 방향키에 대한 추가 정보가 없기 때문에 구현 방법을 선택하는 데 있어서 조금 더 고민하게 되는 것이다.</p>

<p>이것이 해석의 어려운 부분인데 당연하다고 여겨 구체적 정의를 생략한 부분은, 개발 단계에서 개발자가 스스로 채워넣어야 한다. 그리고 개발자가 누락된 부분을 채우려면 요구사항이 그렇게 정의된 이유와 과정까지 모두 고려해야 하기 때문에 많은 경험과 통찰력이 필요하다.</p>

<p>만약 지금 상황에서 사용자의 의도를 정확히 파악할 수 없다면 어떻게 해야 할까? 혹은 어떻게 변경될지 예측할 수 없다면 어떻게 해야 할까?</p>

<p><code class="language-plaintext highlighter-rouge">&lt;Up /&gt;&lt;Down /&gt;&lt;Left /&gt;&lt;Right /&gt;</code> 클래스로 정의해서 화살표의 요구사항이 어떻게 변경 되더라도 다른 곳에 영향이 없도록 하면 된다.</p>

<blockquote>
  <p>쇼핑몰을 운영하는 회사에서 일할 때의 일이다. 회의 내용은 ‘쿠폰’을 어떻게 구현할 것인가에 대한 논의였다.</p>

  <p>당시 개발팀은 결제 금액을 ‘원’이라는 화폐 단위로만 다루고 있었다. DB에 저장된 금액 단위는 모두 ‘원’이었고, 코드에서 다루는 금액 단위 역시 ‘원’이었다. 사용자 관점에서의 ‘결제금액’이라는 개념은 고려되지 않은 채로 말이다.</p>

  <p>이러한 상황에서 ‘포인트’ 개념을 도입하게 되었다. 다행히 당시에는 1point가 1원이라는 단순한 구조였기에 큰 문제없이 DB에 point 컬럼을 추가하는 것으로 대응할 수 있었다.</p>

  <p>하지만 서비스가 확장되며 할인쿠폰, 등급별 혜택 등의 기능이 추가되면서 사용자가 인지하는 ‘결제금액’은 단순히 원으로 표현될 수 없는 복잡한 개념이 되어갔다. 기존의 ‘원’ 중심 구현방식으로는 사용자의 결제 flow를 온전히 반영할 수 없게 된 것이다.</p>

  <p>만약 프로젝트 초기에 ‘결제금액’의 의미를 좀 더 깊이 생각했다면 이후의 많은 변경사항에 매끄럽게 대처할 수 있었을 것이다.</p>

  <p>물론, 이것은 쉽지 않은 일이기는 하다. 기본적으로 객체 지향 프로그래밍에 능숙해야 하는데 이것 부터가 쉽지 않다. 그리고 결제 기능이 언제 어떻게 변경될지 알 수 없기 때문에 아무리 실력있는 개발자라 하더라도 처음부터 ‘결제금액’을 객체로 만드는 것은 어려울 것이다.</p>

  <p>그러나 방향키의 사례처럼, 요구사항 이면의 본질을 파악하는 습관을 기른다면 시행착오를 크게 줄일 수 있다.</p>
</blockquote>

<h2 id="3-rest-api의-shallow-routing-vs-nested-routing">3. REST API의 Shallow Routing vs Nested Routing</h2>

<p>[그림 3-1]은 사용자가 영화 예매 서비스에서 상영 중인 영화/극장/시간을 선택하는 시퀀스 다이어그램이다. 여기에서 REST API의 라우팅을 어떻게 디자인 해야 할까?</p>

<p><object data="/uml/9eca4c0ba637d46c74f35ee2c77ca2cf.svg" type="image/svg+xml" class="plantuml"></object></p>

<p><em>[그림 3-1]</em></p>

<h3 id="31-shallow-routing">3.1. Shallow Routing</h3>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code> 형식으로 디자인 한다면 아래와 비슷한 형태가 될 것이다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 상영 영화 목록 요청</span>
/movies?status<span class="o">=</span>showing

<span class="c"># 상영 극장 목록 요청</span>
/theaters?movieId<span class="o">={</span>movidId<span class="o">}</span>

<span class="c"># 상영일 목록 요청</span>
/showdates?movieId<span class="o">={</span>movieId<span class="o">}</span>&amp;theaterId<span class="o">={</span>theaterId<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code>은 각 리소스를 독립적으로 관리할 수 있으므로 확장성이 좋다. 그러나 리소스 간의 관계를 명확하게 표현하지 않기 때문에 복잡한 계층 구조의 데이터를 표현하는데 어려움이 있다.</p>

<h3 id="32-nested-routing">3.2. Nested Routing</h3>

<p><code class="language-plaintext highlighter-rouge">Nested Routing</code> 형식으로 디자인 한다면 아래와 비슷한 형태가 될 것이다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 상영 영화 목록 요청</span>
/showing/movies

<span class="c"># 상영 극장 목록 요청</span>
/showing/movies/<span class="o">{</span>movieId<span class="o">}</span>/theaters

<span class="c"># 상영일 목록 요청</span>
/showing/movies/<span class="o">{</span>movieId<span class="o">}</span>/theaters/<span class="o">{</span>theaterId<span class="o">}</span>/showdates
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Nested Routing</code>은 리소스 간의 관계를 URL에서 명확하게 표현할 수 있으므로, 복잡한 리소스 구조를 표현하는데 적합하다. 그러나 중첩된 리소스 구조가 변경될 경우, URL도 함께 변경되어야 하므로 유연성이 제한된다.</p>

<h3 id="33-옳은-방법은-무엇일까">3.3. 옳은 방법은 무엇일까?</h3>

<p>두 REST API의 라우팅 디자인 방식의 장단점을 간단하게 살펴봤다. 그렇다면 <code class="language-plaintext highlighter-rouge">Shallow Routing</code>의 유연성과 <code class="language-plaintext highlighter-rouge">Nested Routing</code>의 명확함 사이에서 어떤 방법을 선택해야 할까?</p>

<p>두 방식 중에서 무엇을 선택할 것인지는 개념적인 관점에서 영화 예매 프로세스를 더 잘 표현하는 것이 무엇인지를 봐야 한다.</p>

<p>그런 면에서 <code class="language-plaintext highlighter-rouge">Nested Routing</code>은 티켓 구매 프로세스를 그대로 반영하고 있다.
티켓 구매 프로세스가 영화 선택 후 극장을 선택해야 하듯이, <code class="language-plaintext highlighter-rouge">Nested Routing</code>도 영화를 지정하지 않으면 극장을 지정할 수 없다.
즉, <code class="language-plaintext highlighter-rouge">Nested Routing</code>의 REST API가 티켓 구매 프로세스와 유사한 구조를 표현하고 있다.
이 정도면 별도의 문서가 없어도 티켓 구매 프로세스를 알 수 있을 것이다.</p>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code>과 <code class="language-plaintext highlighter-rouge">Nested Routing</code> 중에서 무엇이 좋은가에 대한 논쟁을 종종 보게된다.
그러나 그런 논쟁은 무의미하다. 중요한 것은 요구사항을 보다 정확히 반영하는 것이 무엇이냐인 것이다.
기술적 관점에서 보면 답이 없는 문제를 가지고 논쟁을 하니 논쟁이 끝나지 않는 것이다.</p>

<p>“한참 고민해도 답이 보이지 않는다면, 답이 거기에 없는 것이다.”</p>

<h3 id="34-클래스의-상속과-포함composition">3.4. 클래스의 상속과 포함(Composition)</h3>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code>과 <code class="language-plaintext highlighter-rouge">Nested Routing</code>의 논쟁과 유사한 다른 논쟁으로 클래스의 상속과 포함(Composition)이 있다.</p>

<p>유연성이 주는 장점 때문에 <code class="language-plaintext highlighter-rouge">Shallow Routing</code>이 기술적으로 우월하다는 대체적인 공감대와 마찬가지로 클래스도 가능하면 상속을 피하고 포함을 사용하는 것이 좋은 재사용 방법이라고 한다. 그러나 이것도 마찬가지로 도메인 개념을 더 잘 표현하는 것이 무엇인지를 고민해야 하는 것이지 기술적 우월성을 우선해서 고려하면 안 된다.</p>

<p><object data="/uml/9f603402d37bffc94cd71f3d9fe52b9d.svg" type="image/svg+xml" class="plantuml"></object></p>

<p>위의 다이어그램에서 Dog는 Animal의 한 종류다. 이것은 상속으로 표현하는 것이 자연스럽다. 반면에 Engine은 Car를 구성하는 부품 중 하나이다. 이것은 포함으로 표현하는 것이 자연스럽다.</p>

<h2 id="4-유사한-형식의-문서-구현-방법">4. 유사한 형식의 문서 구현 방법</h2>

<p>소득증명서와 같은 국내에서 발행되는 문서의 국외 사용을 위한 인증 방식이 두 가지 있는데 ‘아포스티유’와 ‘영사확인’이다.
영사확인이 일반적인 절차이고 아포스티유는 협약에 따라 영사확인 절차를 보다 보다 간소화 한 것이다.</p>

<p>프로젝트의 목표는 이 두 문서를 암호화 하고 변조 여부를 확인할 수 있는 시스템을 구축하는 것이었다.</p>

<p>아포스티유와 영사확인 문서는 항목이나 구조가 유사했기 때문에 기존에 구축된 서비스도 하나의 테이블을 공유하고 있었다.</p>

<p><object data="/uml/05725b13c788685ea2729a3ba231029d.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="41-초기-설계">4.1. 초기 설계</h3>

<p>기존 시스템을 분석하는 과정에서 나는 영사확인과 아포스티유가 비슷해 보이는 것은 우연일 뿐이며 동일한 문서로 취급하면 안 될 것처럼 보였다. 만약 같은 문서라면 프로젝트 이름이 ‘아포스티유 &amp; 영사확인’은 아니었을 것이다.</p>

<p>그에 반해서 back-end 담당자는 두 개로 분리할 필요가 없다는 주장을 하고 있었다.
결국 타협점으로 REST API만 두 개로 분리하고 테이블 등은 하나로 구현하기로 했다.</p>

<p><object data="/uml/ec5e5e2347907e077d1b58976807c9cf.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="42-설계-변경">4.2. 설계 변경</h3>

<p>그런데 프로젝트가 진행되면서 두 문서의 차이가 구체화 되기 시작했다.
아포스티유와 영사확인의 문서번호가 중복될 수 있어서 문서번호 체계가 달라졌다.
그리고 서비스 기능이 확장 되면서 두 문서의 인터페이스는 점점 달라졌다.</p>

<p>결국 테이블을 둘로 나누고 내부 구조도 분리하기로 결정했다.
다행스럽게도 외부에 노출되는 API는 두 개로 분리되어 있었기 때문에 내부 구조를 변경하는 것은 비교적 수월했다.
만약 분리하는 것이 부담스러워서 리팩토링을 피하려고 했다면 코드 곳곳에 if-else가 넘쳐나고 지옥으로 가는 문이 열렸을 것이다.</p>

<p><object data="/uml/92b9f1fa32a97ec298a8c11ad6c7b8fc.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="43-이런-일이-발생한-이유">4.3. 이런 일이 발생한 이유</h3>

<p>이 사례에서 두 문서의 형식이 같았던 것은 그저 우연일 뿐이었다. 사용자의 요구에 따라서 얼마든지 달라질 가능성이 있었다. 애초에 다른 문서이기 때문에 다른 이름이 붙은 것이라는 사실을 간과한 것이 문제였다.</p>

<p>프로그래머는 종종 구현 편의성을 우선하는 경향이 있다. 그 습관을 버리기가 쉽지 않을 것이다. 그러나 철저하게 도메인의 개념을 따라야 한다.</p>

<h2 id="5-인코딩된-파일명의-저장">5. 인코딩된 파일명의 저장</h2>

<p>사용자가 웹 브라우저로 <code class="language-plaintext highlighter-rouge">[file].txt</code> 파일을 업로드 하려고 한다.</p>

<p>사용자가 업로드 하는 파일명에 특수문자가 포함되어 있어서 URL encoding을 해서 서버에 전송해야 한다. 마찬가지로 사용자가 파일을 다운로드 받으려면 파일명을 URL encoding 해야 한다.</p>

<p>그렇다면 서버는 DB에 인코딩된 문자열(<code class="language-plaintext highlighter-rouge">%5Bfile%5D.txt</code>)을 그대로 저장하는 것이 좋을까? 아니면 이것을 다시 디코딩해서 <code class="language-plaintext highlighter-rouge">[file].txt</code>로 저장하는 것이 좋을까?</p>

<p><code class="language-plaintext highlighter-rouge">[file].txt</code>로 저장하면 사용자에게 파일을 전송할 때 다시 인코딩 해야 한다. 그렇다면 그냥 받은 그대로 <code class="language-plaintext highlighter-rouge">%5Bfile%5D.txt</code>으로 저장하는 것이 효율적이지 않을까?</p>

<p>본질이 무엇인지 알기 위해서 사용자의 생각을 살펴봐야 한다.</p>

<p>사용자가 업로드 한 파일명은 <code class="language-plaintext highlighter-rouge">[file].txt</code>이다. 사용자는 이것이 변환된다고 생각하지 않은다. 그러니까 저장할 때도 사용자의 생각에 맞춰서 <code class="language-plaintext highlighter-rouge">[file].txt</code>으로 저장하는 것이 옳다.</p>

<p>애초에 URL Encoding은 ASCII 문자 집합의 제한 때문에 필요한 것이지, 사용자의 요구사항이 아니다. 특정 기술의 한계 혹은 특성이 다른 영역에 영향을 주는 것은 좋은 구조가 아니다. 그러니까 HTML의 전송 과정에서 발생하는 기술적인 문제는 그 과정에서 해결해야 하는 것이지 그것을 DB까지 가져오면 두 개의 큰 영역이 서로 강하게 결합되는 안티-패턴이 된다.</p>

<p>사용자의 의도를 더 정확하게 반영하는 것이 우선이고 최적화는 그 다음이다.</p>

<p>다운로드 기능만을 고려한다면 받은 그대로 저장하는 것이 최선의 선택일 것이다. 그러나 기능이 확장되면서 파일 목록을 보여주거나 검색을 허용할 때는 원본 문자열(<code class="language-plaintext highlighter-rouge">[file].txt</code>)이 필요할 것이다. 왜냐하면 사용자는 파일명을 <code class="language-plaintext highlighter-rouge">[file].txt</code>으로 생각하기 때문이다. 그런데 저장을 <code class="language-plaintext highlighter-rouge">%5Bfile%5D.txt</code>으로 한다면 조회나 검색 기능을 구현할 때 어려움을 겪을 것이다.</p>

<p>구현 편의성을 추구하면 이렇게 작은 변화에도 쉽게 흔들리게 되는 것이다.</p>

<!-- markdownlint-disable MD034 -->
<p><object data="/uml/543ff9861916ccb443624522babac381.svg" type="image/svg+xml" class="plantuml"></object></p>

<h2 id="6-본질에-기반한-기능-정의">6. 본질에 기반한 기능 정의</h2>

<p>영화 예매 서비스를 개발한다고 할 때 여기에 장바구니 기능을 구현해야 할까? 전자상거래 서비스에서는 장바구니가 필수적인 기능이지만, 영화 예매 서비스에서도 꼭 필요할까?</p>

<p>이 질문에 답하기 위해서는 실제 영화 예매 프로세스에서의 사용자 경험을 생각해 봐야 한다. 일반적으로 사용자가 영화를 예매할 때는 다음과 같은 순서로 진행된다.</p>

<ol>
  <li>영화 선택</li>
  <li>상영 시간 선택</li>
  <li>좌석 선택</li>
  <li>결제</li>
</ol>

<p>이 과정에서 우리는 “장바구니에 담기”와 같은 중간 단계를 발견할 수 없다. 사용자는 영화, 시간, 좌석을 선택하고 바로 결제를 진행한다.</p>

<p>그렇다면 온라인 영화 예매 서비스에 장바구니 기능을 추가하는 것은 사용자의 실제 경험과는 거리가 먼 결정이 될 수 있다. 오히려 불필요한 복잡성을 야기하고, 온라인과 오프라인에서의 경험 간 일관성을 해칠 수 있다.</p>

<p>물론 “나중에 결제하기 위해 선택한 영화를 저장해 두는 기능이 있으면 좋겠다”라는 사용자 요구사항이 있을 수 있다. 하지만 이 경우에도 “장바구니”라는 개념을 그대로 가져오기보다는, 영화 예매 서비스의 맥락에 맞는 개념으로 재해석할 필요가 있다. 예를 들어, “관심 영화 저장” 또는 “예매 내역 저장” 등의 기능으로 제공하는 것이 더 적절할 수 있다.</p>

<h2 id="7-본질에-기반한-네이밍">7. 본질에 기반한 네이밍</h2>

<p>백엔드에 대한 기본적인 지식을 전달하기 위한 프로젝트로 영화 예매 서비스 개발을 시작하려고 한다. 프로젝트의 이름을 무엇이라고 해야 할까? 영화 예매니까 ticket-service이라고 하면 어떨까?</p>

<p>우리가 만들려고 하는 것은 ticket-service가 맞다. 그러나 왜 만들려고 하는가를 생각해 보면 backend-fundamentals이 더 좋은 선택이다. ticket-service는 백엔드의 기본적인 지식을 전달하기 위한 수단에 불과하다. 수단은 언제든지 변경될 수 있다.</p>

<p>이 경우처럼 코드가 아니어도 선택의 순간에는 본질을 통찰하는 사고가 필요하다. 나의 경우 매 순간 습관처럼 내가 인지한 정보의 본질이 무엇인지를 고민한다.</p>

<h2 id="8-결론">8. 결론</h2>

<p>지금까지 살펴본 사례들이 보여준 공통점은 ‘무엇(what)’이 아니라 ‘왜(why)’에 집중한다는 것이다. ‘무엇(what)’은 ‘왜(why)’에 도달하기 위한 방법 중에 하나일 뿐이다. 목적(why)은 쉽게 바뀌지 않지만 방법(what)은 여러 상황에 따라서 얼마든지 바뀔 수 있다.</p>

<p>나는 이 사고방식을 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>이라고 정의했다. <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>은 무언가를 바라볼 때 그 본질을 통찰하려는 노력이다.</p>

<p>이것은 <code class="language-plaintext highlighter-rouge">도메인 주도 디자인(DDD)</code>를 고민하다가 떠올린 개념인 만큼 <code class="language-plaintext highlighter-rouge">도메인 주도 디자인(DDD)</code>과 비슷한 맥락을 가진다. 그래서 굳이 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>이라는 거창한 이름으로 정의하려니 좀 창피하기도 하다. 그러나 나를 포함한 많은 개발자들이 이 개념의 존재를 보다 분명하게 인지하는데 도움이 되기를 바라는 마음으로 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>을 정의하고자 한다.</p>

<p>‘왜(why)’에 집중해야 하는 다른 중요한 이유는 분석 단계에서 사용자의 모든 생각을 문서로 정리할 수 없기 때문이다. 이것은 설계도 마찬가지인데 설계 단계에서 설계자의 모든 생각을 정리할 수 없다. 모든 요구사항과 설계를 최대한 반영한 것이 코드이기 때문이다. 어느 정도 빈틈이 있을 수 밖에 없고 그 빈틈은 굳이 말하지 않아도 알 것이라고 생각하는 것들이다. 문제는 사용자가 당연하게 생각하는 것들을 개발자는 전혀 다르게 받아들일 수 있다는 것이다.</p>

<p>그러나 ‘왜(why)’에 집중해서 사고하면 결국 같은 곳을 바라보기 때문에 의사소통에 다소의 빈틈이 있더라도 그 오차가 크지 않다. 이렇게 사용자와 개발자 간에 발생할 수 있는 생각의 차이를 줄이는 것이 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>의 중요한 역할 중 하나이다.</p>

<p><code class="language-plaintext highlighter-rouge">본질 기반 해석(Essence-Based Interpretation, EBI)</code>은 너무 당연하고 원론적인 개념이라서 대상 범위나 구체적인 실천 방법을 정의하기가 어렵다. 그리고 개발에만 국한되는 것도 아니다.</p>

<p><code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>은 도메인에 기반해야 한다는 점에서 도메인 주도 개발(DDD)과 비슷한 맥락을 가진다. 그러나 DDD는 보다 체계적이고 구체적인 설계 방법론으로 복잡하거나 변화가 잦은 도메인에 대응하는 것이 주 목적이다. 반면에 본질 기반 해석(EBI)은 구체적인 방법론이라기보다는, 소프트웨어 개발을 포함한 다양한 분야에 적용할 수 있는 일반적인 사고방식이라 할 수 있다.</p>

<p>좋은 코드에 대한 고민은 사고방식의 변화를 가져오며, 이는 본질을 통찰하여 예측 불가능한 변화에 대응하는 전략으로 이어진다. 이는 소프트웨어 개발 특유의 소중한 도전이다.</p>]]></content><author><name>mannercode</name><email>hello@mannercode.com</email></author><summary type="html"><![CDATA[1. 소개]]></summary></entry><entry><title type="html">객체 지향 프로그래밍의 이해</title><link href="http://localhost:4000/2024/03/09/oop.html" rel="alternate" type="text/html" title="객체 지향 프로그래밍의 이해" /><published>2024-03-09T00:00:00+00:00</published><updated>2024-03-09T00:00:00+00:00</updated><id>http://localhost:4000/2024/03/09/oop</id><content type="html" xml:base="http://localhost:4000/2024/03/09/oop.html"><![CDATA[<blockquote>
  <p>객체 지향 프로그래밍은 데이터와 함수를 하나의 ‘객체’로 그룹화하여 응집성은 높이고 의존성은 낮추는 프로그래밍 패러다임이다.</p>
</blockquote>

<p>OOP를 학습할 때 가장 중요한 것은 사고의 전환이다. 마틴 파울러는 사고의 전환을 이루기 위한 가장 좋은 방법은 OOP가 잘 구성된 환경에서 얼마간 일해보는 것이라고 한다. 그러나 OOP를 제대로 이해한 개발자가 많지 않아서 그런 환경을 찾기가 쉽지 않다.</p>

<p>본 글에서는 절차식에서 객체 지향 방식까지 코드를 개선해 가면서 OOP의 본질이 무엇인지 알아보고 사고의 전환을 이루는데 조금이나마 도움이 되려고 한다.</p>

<h2 id="1-절차식-코드-소개">1. 절차식 코드 소개</h2>

<p>먼저, 버퍼에서 문서를 읽어서 한 글자씩 출력하는 함수를 작성해 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 버퍼에서 읽기 */</span>
<span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>

  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">buffer</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="11-절차식-코드에-기능-추가하기">1.1. 절차식 코드에 기능 추가하기</h3>

<p>여기에 파일에서 문서를 읽어서 한 글자씩 출력하는 기능을 추가해 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

  <span class="cm">/* 파일에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 파일에서 읽기 */</span>
    <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

      <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이것이 전형적인 절차식이다. 절차식의 특징 중 하나는 if가 자주 나온다는 것이다.</p>

<h2 id="2-절차식-코드의-문제점">2. 절차식 코드의 문제점</h2>

<p>만약 여기에 REST API로 읽는 기능을 추가해야 한다면 어떻게 될까? main()함수는 물론이고 printDocument() 함수도 변경되어야 한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

  <span class="cm">/* 파일에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>

  <span class="cm">/* REST API 요청 */</span>
  <span class="kd">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HttpRequest</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://test.com/api</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">request</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span> <span class="o">|</span> <span class="nx">HttpRequest</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 파일에서 읽기 */</span>
    <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

      <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* REST API 요청 */</span>
    <span class="kd">const</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">body</span><span class="p">();</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">body</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">body</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>지금처럼 printDocument() 함수 하나만 변경하는 것이라면 문제가 되지 않는다. 그러나 printDocument() 외에 다른 함수가 있다면? 변경해야 하는 함수가 그 만큼 늘어난다.</p>

<h3 id="21-중첩된-함수에서의-문제">2.1. 중첩된 함수에서의 문제</h3>

<p>실제 프로젝트는 이것보다 더 길고 복잡한 코드인 경우가 많다. 이런 환경에서 관련된 모든 함수를 찾아서 변경하는 것은 쉽지 않다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span>
    <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
    <span class="nf">updateDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="dl">"</span><span class="s2">new contents</span><span class="dl">"</span><span class="p">)</span>
    <span class="nf">clearDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>

    <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">)</span>
    <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
    <span class="nf">updateDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="dl">"</span><span class="s2">new contents</span><span class="dl">"</span><span class="p">)</span>
    <span class="c1">// clear 하려면 close 해야 한다는 규칙을 알아야 한다.</span>
    <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
    <span class="nf">clearDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">updateDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">,</span> <span class="nx">contents</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">doc</span> <span class="o">=</span> <span class="nx">contents</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">){</span>
        <span class="nx">doc</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">){</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">clearDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">doc</span> <span class="o">=</span> <span class="dl">""</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">){</span>
        <span class="nx">doc</span><span class="p">.</span><span class="k">delete</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">){</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">()</span>

        <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>

            <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">){</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>if는 코드의 복잡도를 증가시키고 개발을 어렵게 한다. 그렇다고 if문을 제거하면 더 큰 부작용이 발생한다.</p>

<h2 id="3-절차식-코드의-개선-방법">3. 절차식 코드의 개선 방법</h2>

<h3 id="31-함수-세분화하기">3.1. 함수 세분화하기</h3>

<p>if를 피하는 방법으로 printDocument()를 세분화 하는 방법을 생각할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nf">printBufferDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printFileDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printBufferDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printFileDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

    <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>언뜻 괜찮은 방법처럼 보인다.</p>

<p>그런데 보통은 아래처럼 중첩해서 함수를 호출하기 마련이다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span>
    <span class="nf">printBufferWeeklyReport</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>

    <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">)</span>
    <span class="nf">printFileWeeklyReport</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printBufferWeeklyReport</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span><span class="p">){</span>
    <span class="cm">/* report를 생성하는 코드*/</span>
    <span class="p">...</span>

    <span class="nf">printBufferDocument</span><span class="p">(</span><span class="nx">report</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printFileWeeklyReport</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">File</span><span class="p">){</span>
    <span class="cm">/* report를 생성하는 코드*/</span>
    <span class="p">...</span>

    <span class="nf">printFileDocument</span><span class="p">(</span><span class="nx">report</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>확실히 if 문이 사라지긴 했다. 그러나 if를 피하기 위해서 ‘report를 생성하는 코드’를 반복하게 된다. 이럴거면 차라리 if를 사용하는 것이 낫다.</p>

<h3 id="32-실행-코드-전달하기">3.2. 실행 코드 전달하기</h3>

<p>printDocument()에서 if를 제거할 수 없는 근본 원인은 main() 함수에서 printDocument()에 필요한 데이터만 전달할 뿐, 그 데이터를 사용하는 방법은 전달하지 않기 때문이다.</p>

<p>그래서 printDocument()는 데이터의 유형에 따라서 실행해야 하는 코드를 판별해야 하는 것이다.</p>

<p>그렇다면 실행해야 하는 코드도 같이 전달하면 어떨까?</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">getCharFromBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">position</span> <span class="o">==</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">position</span><span class="o">++</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">getCharFromBuffer</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">getCharFromFile</span> <span class="o">=</span> <span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">File</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

    <span class="k">return</span> <span class="nx">char</span> <span class="o">==</span> <span class="nx">EOF</span> <span class="p">?</span> <span class="kc">null</span> <span class="p">:</span> <span class="nx">char</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">getCharFromFile</span><span class="p">);</span>
  <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">getChar</span><span class="p">:</span> <span class="nx">Func</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nf">getChar</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

    <span class="nx">char</span> <span class="o">=</span> <span class="nf">getChar</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>비록 main() 함수는 더 복잡해졌지만 printDocument()는 if 문이 필요없고 어떤 형식이 오더라도 변경하지 않아도 된다.</p>

<p>이제 어떻게 하면 main() 함수를 깔끔하게 정리할 수 있을까?</p>

<h2 id="4-객체-지향-코드">4. 객체 지향 코드</h2>

<p>main() 함수를 깔끔하게 정리하기 위해서 우리는 클래스를 사용할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">bufferDocument</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferDocument</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">bufferDocument</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">fileDocument</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileDocument</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">fileDocument</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">reader</span><span class="p">:</span> <span class="nx">DocumentReadable</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="nx">char</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nx">reader</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">DocumentReadable</span> <span class="p">{</span>
  <span class="nf">getChar</span><span class="p">():</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nf">close</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">BufferDocument</span> <span class="k">implements</span> <span class="nx">DocumentReadable</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">position</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">buffer</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">getChar</span><span class="p">():</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">position</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>

    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">position</span><span class="o">++</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">FileDocument</span> <span class="k">implements</span> <span class="nx">DocumentReadable</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">stream</span><span class="p">:</span> <span class="nx">ReadStream</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="nx">filename</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">stream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">getChar</span><span class="p">():</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">stream</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">char</span> <span class="o">!==</span> <span class="nx">EOF</span> <span class="p">?</span> <span class="nx">char</span> <span class="p">:</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">close</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">stream</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 객체 지향 방식에서의 printDocument()에는 문서 타입을 판별하는 if 문이 없다. main()에서 객체를 처음 생성할 때 필요한 것들이 모두 정해진다. printDocument()는 주어진 객체를 사용하기만 하면 되는 것이다.</p>

<blockquote>
  <p>코드에 if 문이 보인다면 이것이 절차식은 아닌지? 객체 지향으로 개선할 수 없는지 고민해 보기를 바란다.</p>
</blockquote>

<p>앞서 절차식은 printDocument()에 필요한 데이터만 전달할 뿐, 그 데이터를 사용하는 구체적인 방법(함수)은 전달하지 않는다고 했다. 객체 지향 방식은 데이터와 그 데이터를 사용하는 함수를 객체로 묶어서 전달한다. 이것이 가장 크고 두드러지는 차이점이다.</p>

<h2 id="5-좋은-객체의-특징">5. 좋은 객체의 특징</h2>

<p>코드를 클래스 다이어그램으로 표현해 보자.</p>

<p><object data="/uml/152ad9a5674298d75d5a14fc5eceea85.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="51-관심사-분리">5.1. 관심사 분리</h3>

<p><code class="language-plaintext highlighter-rouge">printDocument()</code> 함수는 <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스를 사용하기만 한다.<br />
<code class="language-plaintext highlighter-rouge">BufferDocument</code>나 <code class="language-plaintext highlighter-rouge">FileDocument</code>는 <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스에 맞춰서 각자 기능을 제공하기만 한다.</p>

<p>그러니까 <code class="language-plaintext highlighter-rouge">printDocument()</code>, <code class="language-plaintext highlighter-rouge">BufferDocument</code>, <code class="language-plaintext highlighter-rouge">FileDocument</code>가 아는 것은 <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스 뿐이고 서로에 대해서는 알지 못한다. 이것은 즉, <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스가 변경되지 않는 한 각 클래스 혹은 함수를 변경할 필요가 없다는 뜻이다.</p>

<p>다시 설명하자면 인터페이스를 변경하지 않는다면 각 부분을 어떻게 변경하든 다른 부분에는 영향을 미치지 않는다는 것이다. 이것이 객체 지향 프로그래밍이 점진적인 개발을 가능하게 하는 방법이다. 이렇게 인터페이스와 구현을 분리하는 매커니즘은 자연스럽게 응집성이 높아지면서 의존성이 낮아지는 결과가 된다.</p>

<blockquote>
  <p>절차식 사고에 익숙하면 이렇게 기능을 응집시키고 그 부분에만 집중하는 방법 자체에 서투른 경우를 보게 된다. 그것은 코드 뿐만이 아니라 업무를 분담하고 협업하는 등의 일상적인 업무에서도 나타난다.</p>

  <p>예를 들면, 프론트엔드와 백엔드 개발자가 REST API를 정의하고 각자 개발을 진행한다. 그러다 기존에 정의한 REST API를 만족시키지 못하는 오류가 백엔드에서 발생한다. 디버깅을 해보니 백엔드에서 코드를 수정하는 것보다 REST API를 변경하고 프론트엔드에서 코드를 수정하는 것이 더 간단한 상황이다. 백엔드 개발자는 프론트엔드 개발자에게 코드를 수정해 달라고 요청하고 프론트엔드 개발자도 기꺼이 동의한다.</p>

  <p>REST API를 설계했을 때의 원칙을 저버리는 것은 큰 문제다. 더군다나 백엔드의 문제를 프론트엔드까지 끌어들이면서 백엔드와 프론트엔드는 그 만큼 더 강하게 결합하게 된다.</p>

  <p>이 정도 사소한 변경이 그렇게 큰 문제일까 싶은 의문이 들지도 모르겠다. 코딩하는 당시에는 대수롭지 않겠지만 시간이 지나고 다른 개발자가 코드를 분석하려고 할 때 장애가 된다.</p>

  <p>“각자의 작업 영역은 엄격하게 지켜야 한다.”</p>

  <p>절차식 사고에 익숙한 개발자는 이 말을 이기적이고 냉정한 것으로 받아들이는 경우가 있다. 그러나 이것은 지극히 기술적인 접근일 뿐이다.</p>
</blockquote>

<h3 id="52-접근-제어">5.2. 접근 제어</h3>

<p>함수들은 변수를 통해서 서로 연결된다고 볼 수 있다.</p>

<p>전역변수를 생각해 보자. 흔히 전역변수를 사용하면 안 된다고 한다. 왜냐하면 하나의 전역변수를 사용하는 모든 함수들은 서로 연결되는 것이다. 소스코드가 10만 라인이 넘어가는 상황에서 다른 함수들이 내가 생각한 규칙대로 움직인다고 어떻게 보장할 수 있을까?
이것은 복잡도를 엄청나게 상승시킨다.</p>

<blockquote>
  <p>코드를 변경할 때 그 영향이 어디까지 미치는 것인지 파악이 안 된다면 거의 반드시 버그를 만들고 있는 것이다.</p>
</blockquote>

<p>아래의 그림에서 count 변수를 사용하는 read(), write(), change(), reset() 함수들은 서로 연결되어 있다. 특히 값을 변경하는 change(), reset() 함수는 다른 모든 함수에 직접적인 영향을 끼친다.</p>

<!-- markdownlint-disable MD032 MD037 -->
<p><object data="/uml/62794e45846be2ea9677da1605c99ef9.svg" type="image/svg+xml" class="plantuml"></object></p>

<p>반면에 <code class="language-plaintext highlighter-rouge">BufferDocument</code>의 <code class="language-plaintext highlighter-rouge">buffer</code>나 <code class="language-plaintext highlighter-rouge">position</code>을 사용하는 함수는 <code class="language-plaintext highlighter-rouge">BufferDocument</code> 클래스에만 존재할 수 있다.
왜냐하면 두 프로퍼티(변수)가 비공개이기 때문에 외부에서의 접근이 원천적으로 차단되기 때문이다.</p>

<p>이것이 프로퍼티를 public으로 직접 노출하지 말라는 이유이다. 외부에서 프로퍼티를 변경할 수 있다면 프로퍼티와 관련된 코드를 변경할 때 그 영향이 어디까지 미칠지 알 수 없게 된다. 잠재적으로 전역변수와 다를바 없게 되는 것이다.</p>

<h2 id="6-객체-지향의-응용">6. 객체 지향의 응용</h2>

<p>객체 지향 방식의 관심사 분리를 통한 복잡도 관리 및 변화에 의한 영향을 최소화 하는 특징은 다른 분야에도 영향을 끼친다.</p>

<h3 id="61-microservices-architecture">6.1. Microservices Architecture</h3>

<p>MSA는 구조적으로 객체 지향 방식과 유사한 면이 많다.</p>

<p>객체 지향의 핵심은 데이터와 함수를 하나의 객체로 묶는 것이다. MSA에서 서비스도 DB와 API를 하나로 묶어서 관리하고 각 서비스의 내부 구현과 DB는 외부에 노출되지 않는다. 이것은 서비스 내부의 변화가 외부에 영향을 미치지 않도록 하면서 유지보수성과 확장성에 큰 장점이 된다.</p>

<p><object data="/uml/5343b720ca16b12ee6bef537a977a2af.svg" type="image/svg+xml" class="plantuml"></object></p>

<p>OOP와 MSA가 구조적으로 유사하다는 사실에서 알 수 있듯이, OOP를 제대로 이해하지 못하면 MSA와 같은 아키텍처를 이해하고 올바르게 설계하는 것은 많이 어려운 일이 될 것이다.</p>

<p>요즘은 MSA가 유행인 것 같다. 그리고 많은 개발자들이 API gateway나 gRPC, 메시지 브로커 등 MSA 구성 요소들의 사용법을 익히는 데만 열중하는 것 같다. 그러나 가장 중요하고 기본적인 것은 OOP에 대한 깊은 이해이다.</p>

<h3 id="62-애자일-방법론">6.2. 애자일 방법론</h3>

<p>디자이너, 개발자, 기획자 등 관련자들이 한 팀을 이뤄 긴밀하게 협력하는 작업 방식은 객체 지향 프로그래밍(OOP)의 핵심 원칙인 높은 응집성과 낮은 결합도에 비유할 수 있다. 이러한 접근 방식은 소프트웨어 개발 뿐만 아니라, 조직 구성과 팀워크에서도 생산성과 효율성을 높이는 데 중요한 역할을 한다.</p>

<p>애자일 팀의 구성 자체가 데이터와 함수를 하나로 묶는 객체와 동일한 구조는 아니다. 그러나 애자일 팀에서는 기획자가 요구사항이라는 데이터를 생산하고, 개발자가 이를 구현한다는 점에서 데이터의 생산과 소비 주체가 함께 있다는 유사성을 찾을 수 있다. 이는 마치 객체 내부에서 데이터(속성)와 함수(메서드)가 밀접하게 연관되어 있는 것과 같은 맥락으로 볼 수 있다.</p>

<p>한편, 애자일 방법론의 중요 원칙인 점진적인 개발을 반복하는 프로세스는 객체 지향 설계의 관심사 분리를 기반으로 가능한 것이다. 객체 지향 프로그래밍은 시스템을 독립적인 객체들의 상호작용으로 모델링하므로, 각 객체를 개별적으로 개발하고 테스트할 수 있게 해준다. 이는 애자일 방법론이 지향하는 작은 단위의 개발과 피드백 반영을 원활히 하는 데 도움이 된다. 결과적으로 OOP는 애자일 소프트웨어 개발의 기반이 되는 주요 기법 중 하나로 자리매김하고 있다.</p>

<h2 id="7-결론">7. 결론</h2>

<p>이 글은 이렇게 시작했다.</p>

<blockquote>
  <p>객체 지향 프로그래밍은 데이터와 함수를 하나의 ‘객체’로 그룹화하여 응집성은 높이고 의존성은 낮추는 프로그래밍 패러다임이다.</p>
</blockquote>

<p>그렇다. 데이터와 함수를 하나의 객체로 그룹화 한다는 것이 객체 지향의 핵심이다.
그러나 OOP를 설명하는 많은 글이나 영상은 OOP의 캡슐화, 은닉화, 다형성, 상속성이 무엇인지를 설명한다. OOP의 이 네 가지 기본 원칙은 데이터와 함수를 그룹화 할 때의 지침일 뿐이다. 가장 기본적이고 필수적인 것은 데이터와 함수의 그룹화이다.</p>

<p>그렇다면 데이터만 존재하는 객체가 있을 수 있을까? 반대로 함수만 존재하는 객체가 있을 수 있을까?
문법적으로 class를 사용해서 코드를 작성한다고 해도 그것은 객체가 아니다. 객체는 상태(프로퍼티)와 방법(메소드)이 함께해야 의미를 가진다.</p>

<p>지금 이 글을 읽고 뭔가를 알것 같은 느낌을 받았을지도 모른다. 그러나 실제로 자신의 코드를 객체지향으로 바꿔보기 전에는 그것이 구체화 되지는 않을 것이다.
좋은 코드가 무엇인지 많은 고민과 연습이 필요하다.</p>

<p>현대적인 개발 방법론의 근간에는 OOP가 있다. OOP를 깊이있게 이해하지 못하면 TDD, DDD, 애자일, MSA 등 현대적인 개발 방법을 공부해도 올바르게 사용하기 어려울 것이다. 실제로 MSA를 적용한 프로젝트는 많지만 성공 사례가 적은 이유이다.</p>

<p>객체지향 프로그래밍에서 자주 사용하는 일반적인 패턴을 모아놓은 것이 디자인 패턴이다. 이것은 다음 기회에 다루겠다.</p>]]></content><author><name>mannercode</name><email>hello@mannercode.com</email></author><summary type="html"><![CDATA[객체 지향 프로그래밍은 데이터와 함수를 하나의 ‘객체’로 그룹화하여 응집성은 높이고 의존성은 낮추는 프로그래밍 패러다임이다.]]></summary></entry><entry><title type="html">소프트웨어 개발의 이념 전쟁: 원리주의와 실용주의</title><link href="http://localhost:4000/2024/02/03/pragmatism-principlism.html" rel="alternate" type="text/html" title="소프트웨어 개발의 이념 전쟁: 원리주의와 실용주의" /><published>2024-02-03T00:00:00+00:00</published><updated>2024-02-03T00:00:00+00:00</updated><id>http://localhost:4000/2024/02/03/pragmatism-principlism</id><content type="html" xml:base="http://localhost:4000/2024/02/03/pragmatism-principlism.html"><![CDATA[<p>과거 냉전 시대의 공산주의와 자유주의의 대립 만큼이나 양립할 수 없는 두 진영이 소프트웨어 개발에 존재한다. 원리주의와 실용주의가 그것이다.</p>

<p>원리주의자는 체계적인 소프트웨어 개발 이론을 기반으로 소프트웨어 개발을 진행해야 한다는 입장이다. 유지보수가 중요하고 멀리 보고 신중하게 코드를 작성한다.</p>

<p>실용주의자는 문제를 최대한 간단하게 해결하자는 입장이다. 초기에 많은 시간을 들여서 작업을 하느니 문제가 생길 때 마다 대응하는 것이 효율적이라고 생각한다.</p>

<p>여기서는 극단적인 원리주의자와 극단적인 실용주의자 그리고 그 중도 성향의 입장을 구체적으로 알아보려고 한다.</p>

<h2 id="1-원리주의-팀원">1. 원리주의 팀원</h2>

<p>성장 욕구와 열정이 넘치는 주니어 개발자라면 높은 확률로 원리주의 팀원이 될 것이다. 이런 원리주의 팀원이 원리주의 팀장을 만나면 행복하겠지만 현실은 원리주의 팀원과 실용주의 팀장의 조합이 더 많다.</p>

<p>실용주의 팀장에 속한 원리주의 팀원은 개발팀에서 힘든 위치에 놓일 수 있다. 팀장에게 코드 리뷰를 기대하지 못하는 것은 당연하고 팀장이 일정을 제촉하기 때문에 코드 품질에 신경 쓸 여력도 없다. 일정에 여유가 있어서 리팩토링을 하더라도 팀장의 눈치를 봐야 한다. 문제가 발생하면 원리주의 팀원은 그 원인이 무엇인지 파악하고 올바르게 조치하기 위해서 노력한다. 그러나 실용주의 팀장이 원인을 무시하고 문제를 쉽게 해결할 수 있는 방법을 강요할 수 있다.</p>

<p>이런 일이 반복되면 원리주의 팀원은 답답함을 느낀다. 팀장의 실력이 부족한 것은 물론이고 책임감 없이 일을 대충 처리하는 것으로 보인다. 팀장에게서 배울 것이 없고 존경할 만한 업무 태도도 아니라고 생각하기 때문에 팀장을 무시하는 언행을 하기도 한다. 팀장도 그것을 느끼고 원리주의 팀원을 감정적으로 대한다. 원리주의 팀원은 정신적으로 점점 힘들어지고 결국 퇴사를 하게 된다. 그렇지만 회사를 옮겨도 결국 높은 확률로 실용주의 팀장을 만나게 되기 때문에 원리주의 팀원의 어려움은 쉽게 해결되지 않는다.</p>

<p>이것은 나의 주니어 시절 경험이기도 하다. 잦은 이직을 하고 여러 팀장을 만나면서 내 뜻을 존중해 주는 팀장도 있었지만 그 중에서 두 번은 극단적인 실용주의 팀장이었다. 이 극단적인 실용주의 팀장은 자신감과 열정이 넘치는 어린 팀원이 마음에 들지 않았는지 노골적으로 견제하는 행동을 보여주기도 했다. 그래도 나는 팀원의 입장에서 최대한의 존중을 했다고 생각한다. 팀장과 갈등을 겪고 있을 때 다른 팀원들에게 내가 뭔가 잘못했냐고 여러차례 물어봤지만 단지 둘이 안 맞아서 그렇다는 대답이 대부분이었다.</p>

<p>지금 생각해 보면 실용주의 팀장 자신의 개발 역량이 뒤쳐지는 것을 불안해 하는 와중에, 원리주의 팀원이 디자인 패턴이나 TDD 같은 개발 이론을 공공연하게 떠들고 다니면서 그 불안감을 더 자극한 것은 아닐까 싶다. 그래서 실용주의 팀장의 눈에 자신감 넘치고 눈치는 없는 팀원이 곱게는 안 보였을지도 모른다.</p>

<h2 id="2-원리주의-팀장">2. 원리주의 팀장</h2>

<p>원리주의 팀원에서 열정이 계속 된다면 대체로 원리주의 팀장이 되는데 가장 많은 시행착오를 겪는 시기이기도 하다.</p>

<p>많은 시행착오를 겪게 되는 원인은 원리주의 팀장이 그 동안의 노력에도 불구하고 주어진 권한에 비해서 실력과 경험이 부족하기 때문이다. 이 상태에서 엄격한 개발 원칙을 고집하면 생산성은 물론이고 유지보수성도 같이 하락한다. 여기서 더 안 좋은 상황은 원리주의 팀장이 자신의 부족함을 알지 못할 때이다.</p>

<p>생산성이 떨어지는 것은 알겠는데 유지보수성이 떨어진다는 것은 무슨 뜻일까? 이것은 예를 들면 디자인 패턴을 과도하게 적용해서 코드를 직관적으로 이해하기 어렵고 구조적으로도 얽혀있어서 코드의 변경이 쉽지 않은 상황일 수 있다. 혹은 작은 프로젝트임에도 불구하고 MSA(Microservices Architecture)를 적용했을 수도 있다.</p>

<p>원리주의 팀장이 주장하는 올바른 개발 방법론을 실제로 경험할 수 있다는 생각에 팀원들은 많은 기대를 할 수 있다.</p>

<p>원리주의 팀장의 지나치게 체계적인 접근과 꼼꼼한 계획 요구를 팀원들은 납득하기 어려울 것이다. 팀원이 보기에는 개발 문서의 작성이 형식적으로 보인다. 커버리지 100%를 위한 엄격한 테스트 코드 작성의 유용성에 대해서도 의문을 품을 것이다. 얼마 안 가서 개발 문서를 변경해야 하고 테스트 코드가 무효화 되는 일이 반복되면서 원리주의 팀장의 방향성에 의문을 가질 것이다.</p>

<p>이 정도 되면 관리자 입장에서는 유지보수야 어찌됐든 당장의 생산성이라도 높은 실용주의 팀장의 개발 방법이 더 나을 수 있다. 원리주의 팀장은 그런 관리자의 평가를 납득하지 못한다. 좋은 소프트웨어를 개발하기 위한 자신의 노력을 관리자가 알아주지 않는다고 생각한다.</p>

<p>원리주의 팀장의 눈에는 많은 것이 마음에 들지 않겠지만 특히 실용주의 팀원에 대한 불만이 크다. 원리주의 팀장은 설계와 문서 작성의 중요성을 강조하면서 간단한 작업에도 이 원칙을 지킬 것을 강요할 수 있다. 그러나 실용주의 팀원은 이 원칙이 이해되지 않는다.</p>

<p>원리주의 팀장 자신도 제대로 못하는 업무를 팀원들에게 강요하는 경우도 종종 있다. 대표적으로 설계와 문서가 있다. 자신의 생각을 물리적인 형태로 표현하는 것은 어려운 일이다. 하물며 경험이 적은 팀원들에게 제대로 된 가이드도 없이  설계를 하라는 것은 무리다. 업무를 지시한 팀장이 먼저 시범을 보여야 하는데 자신도 제대로 하지 못하니 팀원들을 나무라기만 하는 경우를 종종 본다.</p>

<p>원리주의 팀장의 열정과 자신감이 높은 상태라면 주변에서 들려오는 잘못된 신호를 감지하기 어려울 것이다. 높은 자신감은 문제의 원인을 다른 사람에게서 찾게 만들 수 있다. 극단적으로 높은 자신감은 강한 자기 주장을 하게 만들기도 한다. 이런 언행은 관리자에게 큰 스트레스를 주는 것인데 본인은 그것을 알지 못한다.</p>

<p>이런 잘못을 극복하면 실용주의 팀장이 되거나 중도성향 팀장으로 발전할 수 있다.</p>

<blockquote>
  <p>내가 회사에서 새 프로젝트를 시작하면 항상 기술적인 도전 과제를 스스로 설정하고는 했다. 이번 프로젝트에서는 TDD를 해보거나 DDD를 적용해 보는 식으로 말이다. 이 도전이 얼마니 많이, 또 오래 지속되는지는 관리자의 피드백에 달렸다. 대체로 프로젝트를 시작하고 한 달이 넘도록 제품 개발은 더디고 기술연구만 하고 있으면 개발 진행이 더디다는 관리자의 주의가 주어진다.</p>
</blockquote>

<p>개발자가 부족하면서 대체로 짧은 경력에도 개발 팀장이 되는 경우를 자주 본다. 내 생각에 적어도 10년 이상의 경력을 쌓아야 개발팀을 이끌 수 있다고 생각한다. 그런데 5년 전후의 경력으로 팀장이 되면 많은 어려움을 겪을 것이다. 물론 케바케다</p>

<ul>
  <li><strong>개발 속도의 저하:</strong> 팀장은 체계적인 접근과 꼼꼼한 계획을 요구하지만, 실용주의적 팀원은 이러한 접근이 개발 속도를 늦춘다고 느낍니다.
    <ul>
      <li><strong>유연성 부족:</strong> 실용주의자 팀원들은 변화하는 요구 사항에 빠르게 대응하려 하지만, 원리주의자 팀장은 변경 사항을 받아들이기 전에 많은 분석과 리뷰를 요구하여 프로젝트의 유연성이 떨어집니다.</li>
      <li><strong>포화 상태와 좌절감:</strong> 원리주의 팀장이 깊이 있는 분석과 철저한 계획을 요구하면, 실용주의 팀원은 자신의 빠른 대응 능력이 저평가되고 있다고 느낄 수 있습니다. 이는 팀원에게 좌절감을 주며, 창의적인 해결책을 제시하려는 의욕을 감소시킵니다.</li>
      <li><strong>동기 부여 감소:</strong> 팀장의 높은 기준과 지나친 디테일의 요구는 팀원들에게 업무의 동기를 떨어뜨릴 수 있습니다. 실용주의 팀원은 자유롭게 문제를 해결하고 싶어하지만, 원리주의적 접근 때문에 자신의 아이디어가 억제되고 있다고 느낍니다.</li>
    </ul>
  </li>
</ul>

<h2 id="3-원리주의-관리자">3. 원리주의 관리자</h2>

<p>실용주의 개발을 몇 년 해보고 유지보수가 중요함을 깨달은 경우다. 그러나 회사에 개발 방법론을 제대로 이해한 개발자가 없는 상황에서 어떻게든 품질을 끌어올리기 위해서 노력을 한다. 대표적으로 문서화를 강하게 주장한다.
아니면 개발 기술에 관심이 있는 엔지니어 성향의 관리자라면 처음부터 원리주의 관리자가 될 수도 있다.</p>

<p>자신을 과신하고 개발자를 불신하는 경우도 있었다.</p>

<h2 id="4-실용주의-팀원">4. 실용주의 팀원</h2>

<p>내가 이해하기 힘든 부류다. 개발에 대한 열정이 없는 것은 아니다. 유지보수를 신경쓰지 않는다. 내 기준에서는 솔루션이나 서비스 같은 자체 개발이 아니라 그나마 SI에 적합한 유형으로 보인다. 개발에 대한 노력을 안 하는 것은 아니지만 개발에 대한 이해가 부족한 것으로 보인다. 이런 유형의 개발자는 실용주의 팀장으로 성장하게 된다.</p>

<h2 id="5-실용주의-팀장">5. 실용주의 팀장</h2>

<p>실용주의 팀장의 눈에 원리주의 팀원은 아직 현실을 모르고 그럴듯한 이론에 빠져서 헛된 일을 하는 것으로 보인다. 실용주의 팀장은 주변에서 개발 방법론의 중요성을 외치는 많은 동료들을 봐왔지만 개발 일정만 늦어질 뿐 딱히 품질이 좋아지는 경우를 본 적이 없다. 그래서 팀원의 노력을 시간 낭비로 보고 한심하게 여기기도 한다.</p>

<h2 id="6-실용주의-관리자">6. 실용주의 관리자</h2>
<h2 id="7-중도성향-팀원">7. 중도성향 팀원</h2>

<p>팀장의 뜻을 적극 따르는 부류다.</p>

<h2 id="8-중도성향-팀장">8. 중도성향 팀장</h2>
<h2 id="9-중도성향-관리자">9. 중도성향 관리자</h2>

<h2 id="10-원리주의-회사가-되기까지의-과정">10. 원리주의 회사가 되기까지의 과정</h2>

<p>충분한 비용을 들여서 제대로 된 개발자를 한 명은 채용해야 한다. 기술을 이해하는 관리자가 있어야 한다.</p>

<h2 id="11-소프트웨어-개발-회사로-살아남기-위해서">11. 소프트웨어 개발 회사로 살아남기 위해서</h2>

<p>충분한 비용을 들여서 제대로 된 개발자를 한 명은 채용해야 한다. 기술을 이해하는 관리자가 있어야 한다. 관리자가 기술을 모르면 팀장들 사이의 논쟁(혹은 분쟁)을 조율하지 못한다. 결국 실용주의 팀장이 남게 된다. 기술을 모르는 관리자라도 논쟁을 통해서 합리적 결론을 내릴 수 있다고 착각하는데 자신의 생각을 모두 논리적으로 설명할 수는 없다. 실용주의는 계속 의문을 제기하고 원리주의는 계속 답을 해야 하는데 그러다 답이 막힌다. 이 과정에서 원리주의는 지치고 감정 싸움이 되거나 퇴사하게 된다.</p>

<p>보안 회사를 두 군데 다녔다. 하나는 많은 문제가 있었고 기술 개발도 안 됐다. 다른 하나는 활기가 넘치고 기술력도 있는 것을 알았다. 거기에 CTO가 스스로 많은 연구를 하고 개발팀을 이끌고 있었다. 또라이 같은 팀장 하나 때문에 나오기는 했지만 종종 생각난다.</p>

<h2 id="1-혼합된-팀에서-발생하는-문제들">1. 혼합된 팀에서 발생하는 문제들</h2>

<p>팀장이 자신과 비슷한 성향의 팀원을 선택할 수 있는 환경이라면 그 팀은 행복할 것이다. 그러나 보통은 팀원을 까다롭게 선택할 수 있는 형편은 안 되고 개발 역량을 우선해서 팀원을 채용한다. 그래서 보통은 한 팀에 원리주의자와 실용주의자가 뒤섞여서 개발을 한다.</p>

<p>이렇게 다른 이념을 가진 개발자가 뒤섞일 때 발생하는 문제를 살펴보자.</p>

<h3 id="11-팀장이-실용주의자-팀원이-원리주의자일-때">1.1. <strong>팀장이 실용주의자, 팀원이 원리주의자일 때:</strong></h3>

<ul>
  <li><strong>문제:</strong>
    <ul>
      <li><strong>프로젝트 일정과 품질 간의 갈등:</strong> 팀장은 빠른 결과를 원하기 때문에 단기적인 해결책을 선호합니다. 반면, 팀원은 더 견고하고 장기적인 솔루션을 개발하려고 하여 갈등이 발생합니다.</li>
      <li><strong>코드 리뷰에서의 충돌:</strong> 팀장은 코드의 빠른 개발을 중요시하고 작은 문제들은 나중에 수정하자는 입장이지만, 팀원은 모든 코드가 처음부터 완벽해야 한다고 주장하여 코드 리뷰 과정에서 충돌이 일어납니다.</li>
      <li><strong>스트레스와 불안:</strong> 실용주의 팀장이 빠른 결과를 요구할 때, 원리주의 팀원은 자신의 철저한 작업 방식이 무시당한다고 느낍니다. 이는 팀원에게 스트레스와 불안을 유발하며, 자신의 전문성이 존중받지 않는다고 느낄 수 있습니다.</li>
      <li><strong>소통의 장애:</strong> 팀장의 “빨리 빨리” 문화와 팀원의 “천천히 그러나 올바르게” 접근 방식 사이에서 소통이 단절되기 쉽습니다. 이는 서로에 대한 오해와 감정적 거리를 증가시킵니다.</li>
    </ul>
  </li>
  <li><strong>예시 상황:</strong>
    <ul>
      <li>팀장은 고객의 요구 사항을 빠르게 충족시키기 위해 초기 프로토타입을 급하게 출시하려 합니다. 그러나 팀원은 이 프로토타입이 장기적으로 유지보수하기 어려울 것이라고 우려하며, 더 많은 시간을 들여 설계를 개선하자고 주장합니다. 이로 인해 프로젝트 일정이 지연될 수 있으며, 팀 내 의사소통에 긴장이 발생합니다.</li>
      <li>프로젝트 기한이 임박하여 팀장은 추가 기능 구현을 서두르고 있지만, 원리주의 팀원은 기존 코드의 리팩토링을 요구합니다. 팀장의 압박이 커질수록 팀원은 자신의 전문적 접근이 무시당한다고 느끼며, 이는 감정적으로 소진되는 결과를 초래합니다. 결국, 팀원은 방어적 태도를 취하며, 팀장과의 의사소통이 긴장된 상태로 변합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="12-팀장이-원리주의자-팀원이-실용주의자일-때">1.2. <strong>팀장이 원리주의자, 팀원이 실용주의자일 때:</strong></h3>

<ul>
  <li><strong>문제:</strong>
    <ul>
      <li><strong>개발 속도의 저하:</strong> 팀장은 체계적인 접근과 꼼꼼한 계획을 요구하지만, 실용주의적 팀원은 이러한 접근이 개발 속도를 늦춘다고 느낍니다.</li>
      <li><strong>유연성 부족:</strong> 실용주의자 팀원들은 변화하는 요구 사항에 빠르게 대응하려 하지만, 원리주의자 팀장은 변경 사항을 받아들이기 전에 많은 분석과 리뷰를 요구하여 프로젝트의 유연성이 떨어집니다.</li>
      <li><strong>포화 상태와 좌절감:</strong> 원리주의 팀장이 깊이 있는 분석과 철저한 계획을 요구하면, 실용주의 팀원은 자신의 빠른 대응 능력이 저평가되고 있다고 느낄 수 있습니다. 이는 팀원에게 좌절감을 주며, 창의적인 해결책을 제시하려는 의욕을 감소시킵니다.</li>
      <li><strong>동기 부여 감소:</strong> 팀장의 높은 기준과 지나친 디테일의 요구는 팀원들에게 업무의 동기를 떨어뜨릴 수 있습니다. 실용주의 팀원은 자유롭게 문제를 해결하고 싶어하지만, 원리주의적 접근 때문에 자신의 아이디어가 억제되고 있다고 느낍니다.</li>
    </ul>
  </li>
  <li><strong>예시 상황:</strong>
    <ul>
      <li>팀장은 소프트웨어의 모든 기능에 대해 광범위한 테스트와 문서화를 요구합니다. 그러나 실용주의자 팀원은 이런 절차가 실제 사용자의 요구를 빠르게 반영하는 데 방해가 된다고 느끼며, 더 간단하고 직관적인 방법을 선호합니다. 이로 인해 팀원들은 불필요한 작업에 시간을 낭비한다고 느끼며, 팀장과의 의견 충돌이 생깁니다.</li>
      <li>원리주의 팀장은 모든 기능에 대한 완벽한 테스트와 문서화를 요구합니다. 실용주의 팀원은 이러한 접근이 신속한 개발과 혁신을 방해한다고 느끼며, 자신의 업무 방식이 잘못된 것처럼 여겨지는 상황에 좌절감을 느낍니다. 이러한 상황은 팀원들이 감정적으로 소외되고, 팀장에 대한 불만을 키우는 결과를 낳습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="23-관리자가-실용주의자-개발팀장이-원리주의자">2.3 관리자가 실용주의자, 개발팀장이 원리주의자</h3>

<p>대부분이 이렇다.</p>

<h3 id="24-관리자가-원리주의자-개발팀장이-실용주의자">2.4 관리자가 원리주의자, 개발팀장이 실용주의자</h3>

<p>이런 경우는 없다.</p>

<h3 id="23-해결-방안">2.3. 해결 방안</h3>

<p>갈등은 두 이념 사이에 거리가 멀수록 커진다. 팀장이 극단적인 원리주의자이고 팀원이 극단적인 실용주의자이거나 그 반대라면 생산적인 프로젝트 진행이 될 수 없다.</p>

<p>아래의 방법들은 생각의 차이가 크지 않은 경우에 도움이 될 뿐 결국 각자의 불만을 마음 속에 쌓아두게 된다.</p>

<ol>
  <li><strong>상호 존중과 이해:</strong> 각 진영의 장점을 인정하고 상대방의 접근 방식에 대해 열린 마음을 가지는 것이 중요합니다.</li>
  <li><strong>밸런스 찾기:</strong> 프로젝트의 단계와 중요도에 따라 원리주의와 실용주의의 접근을 적절히 조합하는 것이 좋습니다.</li>
  <li><strong>명확한 커뮤니케이션:</strong> 프로젝트의 목표와 기대치를 명확히 하여 모든 팀원이 이해하고 동의할 수 있도록 합니다.</li>
  <li><strong>유연한 정책 도입:</strong> 상황에 따라 유연하게 정책을 조정하여, 필요한 경우 실용주의적 접근을 허용하고 다른 경우에는 원리주의적 접근을 우선시합니다.</li>
  <li><strong>감정적 인식과 존중:</strong> 서로의 작업 방식을 이해하려는 노력이 필요합니다. 각자의 방식이 팀의 다양한 필요를 충족시키는 중요한 역할을 한다는 점을 인정해야 합니다.</li>
  <li><strong>공감적 소통 구축:</strong> 감정적 충돌을 피하기 위해서는 정기적인 1:1 대화를 포함하여, 서로의 입장에서 문제를 바라보고 공감할 수 있는 소통 방식을 개발해야 합니다.</li>
  <li><strong>스트레스 관리:</strong> 프로젝트의 압박감 속에서 각자의 감정을 관리할 수 있는 기술을 개발하고, 필요한 경우에는 팀원들에게 적절한 휴식과 지원을 제공해야 합니다.</li>
  <li><strong>융통성 있는 접근:</strong> 팀의 목표에 따라 원리주의와 실용주의의 균형을 조정하고, 각 상황에 맞는 최선의 접근 방식을 채택하는 융통성을 발휘해야 합니다.</li>
</ol>

<h2 id="3-이념의-전향">3. 이념의 전향</h2>

<h3 id="31-원리주의자에서-실용주의자로">3.1 원리주의자에서 실용주의자로</h3>

<p>이것 저것 해봤는데 기술적 한계를 극복하지 못하고 결곡 포기하는 경우</p>

<h3 id="32-실용주의자에서-원리주의자로">3.2 실용주의자에서 원리주의자로</h3>

<p>오래된 실용주의 개발자인데 OOP를 깨닫고 체계적인 개방 방법을 경험한 후로 원리주의자로 전향한다. 개발에 뜻은 있었으나 기회가 없었던 케이스다</p>

<h3 id="31-원리주의자에서-중간주의자로">3.1 원리주의자에서 중간주의자로</h3>

<p>원리주의를 추구하며 노력의 끝에 도달한 경우다.</p>

<h2 id="3-조직-내에서의-입지">3. 조직 내에서의 입지</h2>

<p>한 조직에서 원리주의자의 입지는 어떨까? 또 실용주의자는 어떤 입지를 가지게 될까?</p>

<p>원리주의자는 실용주의자에 비해서 불리한 입장인 경우가 많다. 보통 의문을 제기하는 것은 쉽지만 답하기는 어려운 데 실용주의자는 의문을 제기하는 쪽이고 원리주의자는 답을 해야하는 입장이다. 원리주의자가 논리적으로 답을 하는 것도 어렵지만 정답을 얘기한다고 해도 실용주의는 계속 의미없는 질문을 던져가며 자신의 주장을 굽히지 않을 수 있다.
이 정도 되면 감정적으로 원리주의자가 힘들어진다. 결국 제 3자가 보기에 원리주의자가 문제를 일으키는 것으로 보인다.</p>

<p>상위 직급자가 볼 때 실용주의자의 주장이 더 매력적으로 들린다. 적은 비용으로 간단하게 문제를 해결할 수 있으니까. 물론 어느 정도 경험이 있기 때문에 쉬운 해결책을 계속 고집하는 경우 유지보수가 어려워 진다는 것을 경험적으로 알고는 있다. 그러나 품질 문제는 당장 드러나는 것은 아니다. 반면에 두 개발자의 갈등은 당장 조정해야 하는 시급한 문제다.</p>

<p>이 갈등의 끝은 대체로 원리주의자가 고립감을 느끼고 조직을 이탈하게 된다.</p>

<!-- 원리주의자의 정치적 어려움 -->
<p>한 조직에서 두 이념이 갈등할 때 프로젝트는 어떻게 진행될까?</p>

<p>실제 조직 내에서는 실용주의자들이 더 명확하게 살아남는 경향이 있는 경우가 많습니다. 이는 특히 단기적인 성과가 강조되는 경영 환경에서 두드러집니다. 관리자와 경영진은 대체로 당장의 결과와 가시적인 성과를 선호하며, 이는 실용주의적 접근이 잘 맞아떨어지는 상황입니다.</p>

<h3 id="실용주의자의-강점과-조직-내에서의-우위">실용주의자의 강점과 조직 내에서의 우위</h3>

<ol>
  <li>
    <p><strong>즉시적인 결과물 제공:</strong>
실용주의자는 ‘지금 당장 작동하는’ 솔루션을 제공하는 데 초점을 맞춥니다. 관리자나 이해관계자는 프로젝트가 빠르게 진행되는 것을 보고 싶어하며, 실용주의자들이 제공하는 신속한 해결책은 이러한 요구에 잘 부합합니다.</p>
  </li>
  <li>
    <p><strong>유연성과 적응성:</strong>
시장의 변화에 빠르게 대응하고, 사용자의 요구에 신속하게 반응하는 것은 현대 비즈니스 환경에서 큰 장점입니다. 실용주의자들은 이러한 변화에 유연하게 대응하며, 이는 불확실한 경제 상황이나 경쟁이 치열한 시장에서 특히 중요합니다.</p>
  </li>
  <li>
    <p><strong>직관적이고 실질적인 커뮤니케이션:</strong>
실용주의자는 복잡한 이론이나 모델을 사용하기보다는 직관적이고 실질적인 언어를 사용하여 아이디어를 전달합니다. 이는 비전문가나 다른 부서와의 소통에서 상당히 유리하며, 이해관계자들에게 쉽게 접근할 수 있게 해줍니다.</p>
  </li>
  <li>
    <p><strong>위기 상황에서의 효과적 대응:</strong>
문제가 발생했을 때 즉각적으로 대응하는 실용주의자의 태도는 위기 상황에서 매우 유용합니다. 버그 수정, 사용자 피드백 반영, 또는 경쟁 제품에 대한 빠른 대응 등은 실용주의적 접근으로 더 잘 해결될 수 있습니다.</p>
  </li>
</ol>

<h3 id="원리주의자의-답답함과-조직-내에서의-도전">원리주의자의 답답함과 조직 내에서의 도전</h3>

<ol>
  <li>
    <p><strong>장기적인 비전 vs. 단기적 성과:</strong>
원리주의자는 장기적인 관점에서 안정성과 확장성을 고려하여 개발을 추진합니다. 하지만 많은 조직에서는 단기적인 성과가 더 중요시되며, 이러한 차이는 원리주의자에게 많은 답답함을 주고, 그들의 접근 방식이 간과되는 원인이 됩니다.</p>
  </li>
  <li>
    <p><strong>이론과 실제의 간극:</strong>
원리주의자는 종종 소프트웨어 개발 이론과 모범 사례를 중시하지만, 실제 비즈니스 상황에서는 이러한 이론이 완벽하게 적용되기 어려울 수 있습니다. 이는 그들이 제안하는 솔루션을 설득하는 데 추가적인 어려움을 초래합니다.</p>
  </li>
  <li>
    <p><strong>커뮤니케이션의 어려움:</strong>
원리주의자는 때때로 자신의 접근 방식을 설명할 때 너무 기술적이거나 이론적인 언어를 사용할 수 있습니다. 이는 비기술적인 관리자나 이해관계자와의 커뮤니케이션에서 장벽이 될 수 있으며, 그들의 아이디어가 충분히 평가받지 못하는 결과를 낳을 수 있습니다.</p>
  </li>
  <li>
    <p><strong>변화에 대한 저항:</strong>
원리주의자는 변경을 신중하게 접근하며 때로는 새로운 요구사항이나 기술적 변화에 저항할 수 있습니다. 이는 특히 변화와 혁신을 추구하는 조직 문화에서 그들이 소외될 수 있는 요인입니다.</p>
  </li>
</ol>

<h3 id="조직-내에서의-원리주의자와-실용주의자의-조화">조직 내에서의 원리주의자와 실용주의자의 조화</h3>

<p>결국 조직에서는 각기 다른 접근 방식이 필요한 다양한 상황이 존재합니다. 원리주의자와 실용주의자 모두의 접근 방식을 적절히 조화롭게 사용하는 것이 이상적입니다.</p>

<ul>
  <li><strong>원리주의자는 실용주의자와의 협력을 통해</strong> 자신의 장기적인 관점을 현실적인 프로젝트 목표에 맞추어 조정할 수 있습니다.</li>
  <li><strong>실용주의자는 원리주의자와의 대화를 통해</strong> 자신의 단기적인 해결책이 장기적인 문제를 야기하지 않도록 보완할 수 있습니다.</li>
</ul>

<p>이렇게 서로의 장점을 인정하고 통합하는 방식으로 일한다면, 원리주의자와 실용주의자 모두 조직 내에서 중요한 역할을 하며 살아남을 수 있습니다. 결국, 조직의 성공은 다양한 접근 방식을 포용하고, 각각의 강점을 최대한 활용하는 데에서 비롯됩니다.</p>

<h2 id="결론">결론</h2>

<p>결국 길은 한 곳에서 만난다고 하지만
한 가지 중요한 점은 여기서 얘기하는 원리주의자와 실용주의자의 개발 실력이 평범한 경우의 이야기다.
그러니까 서로 다른 이념을 갖고 개발자로 한참 성장해야 하는 경우를 다루는 것이다.</p>

<p>개발 실력이 출중하고 경험이 많으면 어떤 이념이라고 하든 개인 성향으로 치부할 수 있다. 그리고 그런 개발자는 적절한 지점을 요령있게 간파할 것이다.</p>]]></content><author><name>mannercode</name><email>hello@mannercode.com</email></author><summary type="html"><![CDATA[과거 냉전 시대의 공산주의와 자유주의의 대립 만큼이나 양립할 수 없는 두 진영이 소프트웨어 개발에 존재한다. 원리주의와 실용주의가 그것이다.]]></summary></entry></feed>