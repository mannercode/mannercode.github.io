<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-05-21T05:33:48+00:00</updated><id>/feed.xml</id><title type="html">Manner Code</title><subtitle>리팩토링, 디자인패턴, OOP, TDD, DDD, 아키텍처 같은 프로그래밍의 기본을 다룹니다.
</subtitle><author><name>mannercode</name><email>hello@mannercode.com</email></author><entry><title type="html">본질 기반 해석(Essence-Based Interpretation, EBI)</title><link href="/2024/05/04/ebi.html" rel="alternate" type="text/html" title="본질 기반 해석(Essence-Based Interpretation, EBI)" /><published>2024-05-04T00:00:00+00:00</published><updated>2024-05-04T00:00:00+00:00</updated><id>/2024/05/04/ebi</id><content type="html" xml:base="/2024/05/04/ebi.html"><![CDATA[<h2 id="1-소개">1. 소개</h2>

<p>나는 좋은 코드에 대해서 많은 노력을 해왔다. 좋은 코드를 작성하기 위해서 리팩토링과 디자인 패턴은 물론이고 여러 아키텍처와 개발 방법을 학습했다. 내가 작성한 코드가 잘 동작함에도 불구하고 더 나은 구조나 이름에 대해서 한참 고민하기도 했다.</p>

<p>그럼에도 불구하고 선택의 순간에 명확히 답을 내리지 못하고 오늘은 A방법으로 구현했다가 내일은 B방법으로 구현하는 일이 오랜시간 지속됐다. 왜냐하면 두 방법 모두 장단점이 명확했기 때문에 어느 한 방법을 선택해도 아쉬움이 남기 때문이다. 여기서 방법은 디자인 패턴이 될 수도 있고 함수나 변수의 이름일 수도 있다.</p>

<p>그 때의 나는 개발자로서 어느 정도 역량을 갖추고 있다고 생각했지만, 이런 선택의 고민은 아무리 많은 경험과 노력을 쌓아도 좀처럼 사라지지 않을 것만 같았다. 이 부분 만큼은 정답이 존재하지 않고 개인의 성향에 따른 선택이 있을 뿐인, 예술의 영역은 아닐까? 하는 생각도 했다. 그 만큼 나에게는 넘기 힘든 벽처럼 보였다. 마치 디자인 패턴을 이해하지 못하는 개발자들이 디자인 패턴은 실무에서 쓸모없다고 치부하는 것과 같은 방어기재였을지도 모르겠다.</p>

<p>그러다 문득 내가 놓치고 있던 것을 깨달았다. 먼저 몇 가지 사례를 살펴보고 그것이 무엇인지 알아보려고 한다.</p>

<h2 id="2-방향키의-구현">2. 방향키의 구현</h2>

<p>사용자에게 ‘상/하/좌/우’를 선택할 수 있는 방향키를 제공해야 한다. 4개 화살표의 모양은 동일하고 방향만 다르다. 이 때 방향키를 구현하는 방법이 두 가지 있다.</p>

<h3 id="21-방법1---한-개의-이미지를-회전시켜서-재사용">2.1. 방법#1 - 한 개의 이미지를 회전시켜서 재사용</h3>

<p><code class="language-plaintext highlighter-rouge">방법#1</code>은 한 개의 화살표 이미지(arrow.png)를 회전시켜서 구현하는 것이다. 화살표의 모양은 동일하기 때문에 쉽게 구현할 수 있다.</p>

<p>이 방법은 저장 공간을 적게 차지하는 장점이 있다. 그러나 코드 가독성이 상대적으로 떨어진다는 단점이 있다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"180"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"-90"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"90"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p><img src="/assets/images/arrows1.svg" alt="방향키1" /> <br />
<em>[그림 2-1] 한 개의 이미지를 회전시켜서 구현한 방향키</em></p>

<h3 id="22-방법2---4개의-이미지를-사용">2.2. 방법#2 - 4개의 이미지를 사용</h3>

<p><code class="language-plaintext highlighter-rouge">방법#2</code>는 상/하/좌/우에 해당하는 4개의 이미지를 사용하는 것이다.</p>

<p>이 방법은 더 많은 이미지 리소스를 관리하는 번거로움과 저장 공간도 더 많이 차지한다는 단점이 있다. 반면 코드의 가독성은 비교적 좋다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"up.png"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"down.png"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"let.png"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"right.png"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p><img src="/assets/images/arrows2.svg" alt="방향키2" /> <br />
<em>[그림 2-2] 상/하/좌/우 4개의 이미지로 구현한 방향키</em></p>

<h3 id="23-옳은-방법은-무엇일까">2.3. 옳은 방법은 무엇일까?</h3>

<p>무엇이 옳은 것일까? 혹은 이 선택에 있어서 옳고 그름이 존재하긴 하는 걸까? 그저 개인의 철학에 따른 선택만이 있는 것은 아닐까? 읽기 쉬운 코드를 추구한다면 <code class="language-plaintext highlighter-rouge">방법#1</code>이지만 효율성을 추구한다면 <code class="language-plaintext highlighter-rouge">방법#2</code>일 것이다.</p>

<p>읽기 쉬운 코드가 옳은가? 성능 효율적인 코드가 옳은가? 대체로 과거에는 성능 효율을 우선했겠지만 요즘처럼 하드웨어의 성능이 충분한 경우에는 읽기 쉬운 코드를 선호한다. 그런 이유로 읽기 쉬운 코드를 선택해야 할까?</p>

<p>아마도 많은 개발자들이 화살표의 모양이 같다는 것에 주목해서 <code class="language-plaintext highlighter-rouge">방법#1</code>처럼 이미지를 회전 시켜서 효율을 추구하는 방법을 선택했을 것이다.</p>

<p>다양한 생각들이 있겠지만 우선적으로 고려해야 하는 것은 화살표의 의미다. 만약 화살표가 <em>[그림 2-3]</em> 처럼 특정한 물체를 가리키는 용도라면 <code class="language-plaintext highlighter-rouge">방법#1</code>처럼 화살표를 회전시켜서 구현하는 것이 맞다.</p>

<p><img src="/assets/images/arrows3.svg" alt="방향키3" /> <br />
<em>[그림 2-3] 무언가를 가리키는 용도의 화살표</em></p>

<p>그러나 사용자가 생각한 방향키는 <em>[그림 2-4]</em> 와 같이 키보드 구석에 고정되어 있는 4개의 방향키였을 것이다. 그리고 그런 사용자의 생각과 유사한 것은 <code class="language-plaintext highlighter-rouge">방법#2</code>와 같이 4개의 이미지를 사용하는 것이다.</p>

<p><img src="/assets/images/arrows4.svg" alt="방향키4" /> <br />
<em>[그림 2-4] 서로 다른 모양의 화살표를 가지는 방향키</em></p>

<p>사용자에게 보여지는 결과물은 같기 때문에 어떤 방법을 선택해도 큰 차이는 없다고 생각할지도 모르겠다. 사용자의 생각을 무시한 채 단순히 구현 편의성만을 추구하면 어떻게 될까?</p>

<p>사용자는 언제든지 화살표의 모양을 쉽게 변경할 수 있다고 생각한다. 왜냐하면 사용자는 당연히 4개의 이미지로 구성된 방향키라고 생각하기 때문이다. 이미지를 회전시켜서 성능을 최적화 하는 것은 지극히 개발자의 입장일 뿐이다. 그리고 어느날 사용자는 방향키의 모양을 <em>[그림 2-4]</em> 처럼 변경해 달라고 가볍게 요구할 수 있다. 키의 이미지를 변경하기만 하면 되니까 쉬운 작업이라고 생각할 것이다. 그러나 개발자는 구현 방법을 바꿔야 하는 큰 일이 된다.</p>

<p>화살표의 모양이 동일한 것은 그저 우연일 뿐이다. 이런 우연으로 생긴 상황을 구현에 반영하면 사용자의 생각과 멀어지게 된다. 다시 얘기하자면 사용자의 의도를 무시한 채 구현 편의성만을 추구하면 유지보수가 점점 더 어려워 지게 된다.</p>

<h3 id="24-해석의-어려움">2.4. 해석의 어려움</h3>

<p>여러 방법을 두고 고민하게 되는 이유 중에 하나는 당연한 정보는 누락하기 때문이다.</p>

<p>사용자가 방향키를 요구사항으로 언급했을 때는 키보드의 그 방향키라고 구체적으로 설명하지는 않았을 것이다. 사용자의 입장에서는 방향키라고 하면 당연히 키보드의 그것이라고 생각하기 때문이다.</p>

<p>그러나 개발자 입장에서는 방향키에 대한 추가 정보가 없기 때문에 구현 방법을 선택하는 데 있어서 조금 더 고민하게 되는 것이다.</p>

<p>이것이 해석의 어려운 부분인데 당연하다고 여겨 구체적 정의를 생략한 부분은, 개발 단계에서 개발자가 스스로 채워넣어야 한다. 그리고 개발자가 누락된 부분을 채우려면 요구사항이 그렇게 정의된 이유와 과정까지 모두 고려해야 하기 때문에 많은 경험과 통찰력이 필요하다.</p>

<p>만약 지금 상황에서 사용자의 의도를 정확히 파악할 수 없다면 어떻게 해야 할까? 혹은 어떻게 변경될지 예측할 수 없다면 어떻게 해야 할까?</p>

<p><code class="language-plaintext highlighter-rouge">&lt;Up /&gt;&lt;Down /&gt;&lt;Left /&gt;&lt;Right /&gt;</code> 클래스로 정의해서 화살표의 요구사항이 어떻게 변경 되더라도 다른 곳에 영향이 없도록 하면 된다.</p>

<blockquote>
  <p>쇼핑몰을 운영하는 회사에서 일할 때의 일이다. 회의 내용은 ‘쿠폰’을 어떻게 구현할 것인가에 대한 논의였다.</p>

  <p>당시 개발팀은 결제 금액을 ‘원’이라는 화폐 단위로만 다루고 있었다. DB에 저장된 금액 단위는 모두 ‘원’이었고, 코드에서 다루는 금액 단위 역시 ‘원’이었다. 사용자 관점에서의 ‘결제금액’이라는 개념은 고려되지 않은 채로 말이다.</p>

  <p>이러한 상황에서 ‘포인트’ 개념을 도입하게 되었다. 다행히 당시에는 1point가 1원이라는 단순한 구조였기에 큰 문제없이 DB에 point 컬럼을 추가하는 것으로 대응할 수 있었다.</p>

  <p>하지만 서비스가 확장되며 할인쿠폰, 등급별 혜택 등의 기능이 추가되면서 사용자가 인지하는 ‘결제금액’은 단순히 원으로 표현될 수 없는 복잡한 개념이 되어갔다. 기존의 ‘원’ 중심 구현방식으로는 사용자의 결제 flow를 온전히 반영할 수 없게 된 것이다.</p>

  <p>만약 프로젝트 초기에 ‘결제금액’의 의미를 좀 더 깊이 생각했다면 이후의 많은 변경사항에 매끄럽게 대처할 수 있었을 것이다.</p>

  <p>물론, 이것은 쉽지 않은 일이기는 하다. 기본적으로 객체 지향 프로그래밍에 능숙해야 하는데 이것 부터가 쉽지 않다. 그리고 결제 기능이 언제 어떻게 변경될지 알 수 없기 때문에 아무리 실력있는 개발자라 하더라도 처음부터 ‘결제금액’을 객체로 만드는 것은 어려울 것이다.</p>

  <p>그러나 방향키의 사례처럼, 요구사항 이면의 본질을 파악하는 습관을 기른다면 시행착오를 크게 줄일 수 있다.</p>
</blockquote>

<h2 id="3-rest-api의-shallow-routing-vs-nested-routing">3. REST API의 Shallow Routing vs Nested Routing</h2>

<p>[그림 3-1]은 사용자가 영화 예매 서비스에서 상영 중인 영화/극장/시간을 선택하는 시퀀스 다이어그램이다. 여기에서 REST API의 라우팅을 어떻게 디자인 해야 할까?</p>

<p><object data="/uml/9eca4c0ba637d46c74f35ee2c77ca2cf.svg" type="image/svg+xml" class="plantuml"></object></p>

<p><em>[그림 3-1]</em></p>

<h3 id="31-shallow-routing">3.1. Shallow Routing</h3>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code> 형식으로 디자인 한다면 아래와 비슷한 형태가 될 것이다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 상영 영화 목록 요청</span>
/movies?status<span class="o">=</span>showing

<span class="c"># 상영 극장 목록 요청</span>
/theaters?movieId<span class="o">={</span>movidId<span class="o">}</span>

<span class="c"># 상영일 목록 요청</span>
/showdates?movieId<span class="o">={</span>movieId<span class="o">}</span>&amp;theaterId<span class="o">={</span>theaterId<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code>은 각 리소스를 독립적으로 관리할 수 있으므로 확장성이 좋다. 그러나 리소스 간의 관계를 명확하게 표현하지 않기 때문에 복잡한 계층 구조의 데이터를 표현하는데 어려움이 있다.</p>

<h3 id="32-nested-routing">3.2. Nested Routing</h3>

<p><code class="language-plaintext highlighter-rouge">Nested Routing</code> 형식으로 디자인 한다면 아래와 비슷한 형태가 될 것이다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 상영 영화 목록 요청</span>
/showing/movies

<span class="c"># 상영 극장 목록 요청</span>
/showing/movies/<span class="o">{</span>movieId<span class="o">}</span>/theaters

<span class="c"># 상영일 목록 요청</span>
/showing/movies/<span class="o">{</span>movieId<span class="o">}</span>/theaters/<span class="o">{</span>theaterId<span class="o">}</span>/showdates
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Nested Routing</code>은 리소스 간의 관계를 URL에서 명확하게 표현할 수 있으므로, 복잡한 리소스 구조를 표현하는데 적합하다. 그러나 중첩된 리소스 구조가 변경될 경우, URL도 함께 변경되어야 하므로 유연성이 제한된다.</p>

<h3 id="33-옳은-방법은-무엇일까">3.3. 옳은 방법은 무엇일까?</h3>

<p>두 REST API의 라우팅 디자인 방식의 장단점을 간단하게 살펴봤다. 그렇다면 <code class="language-plaintext highlighter-rouge">Shallow Routing</code>의 유연성과 <code class="language-plaintext highlighter-rouge">Nested Routing</code>의 명확함 사이에서 어떤 방법을 선택해야 할까?</p>

<p>두 방식 중에서 무엇을 선택할 것인지는 개념적인 관점에서 영화 예매 프로세스를 더 잘 표현하는 것이 무엇인지를 봐야 한다.</p>

<p>그런 면에서 <code class="language-plaintext highlighter-rouge">Nested Routing</code>은 티켓 구매 프로세스를 그대로 반영하고 있다.
티켓 구매 프로세스가 영화 선택 후 극장을 선택해야 하듯이, <code class="language-plaintext highlighter-rouge">Nested Routing</code>도 영화를 지정하지 않으면 극장을 지정할 수 없다.
즉, <code class="language-plaintext highlighter-rouge">Nested Routing</code>의 REST API가 티켓 구매 프로세스와 유사한 구조를 표현하고 있다.
이 정도면 별도의 문서가 없어도 티켓 구매 프로세스를 알 수 있을 것이다.</p>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code>과 <code class="language-plaintext highlighter-rouge">Nested Routing</code> 중에서 무엇이 좋은가에 대한 논쟁을 종종 보게된다.
그러나 그런 논쟁은 무의미하다. 중요한 것은 요구사항을 보다 정확히 반영하는 것이 무엇이냐인 것이다.
기술적 관점에서 보면 답이 없는 문제를 가지고 논쟁을 하니 논쟁이 끝나지 않는 것이다.</p>

<p>“한참 고민해도 답이 보이지 않는다면, 답이 거기에 없는 것이다.”</p>

<h3 id="34-클래스의-상속과-포함composition">3.4. 클래스의 상속과 포함(Composition)</h3>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code>과 <code class="language-plaintext highlighter-rouge">Nested Routing</code>의 논쟁과 유사한 다른 논쟁으로 클래스의 상속과 포함(Composition)이 있다.</p>

<p>유연성이 주는 장점 때문에 <code class="language-plaintext highlighter-rouge">Shallow Routing</code>이 기술적으로 우월하다는 대체적인 공감대와 마찬가지로 클래스도 가능하면 상속을 피하고 포함을 사용하는 것이 좋은 재사용 방법이라고 한다. 그러나 이것도 마찬가지로 도메인 개념을 더 잘 표현하는 것이 무엇인지를 고민해야 하는 것이지 기술적 우월성을 우선해서 고려하면 안 된다.</p>

<p><object data="/uml/9f603402d37bffc94cd71f3d9fe52b9d.svg" type="image/svg+xml" class="plantuml"></object></p>

<p>위의 다이어그램에서 Dog는 Animal의 한 종류다. 이것은 상속으로 표현하는 것이 자연스럽다. 반면에 Engine은 Car를 구성하는 부품 중 하나이다. 이것은 포함으로 표현하는 것이 자연스럽다.</p>

<h2 id="4-유사한-형식의-문서-구현-방법">4. 유사한 형식의 문서 구현 방법</h2>

<p>소득증명서와 같은 국내에서 발행되는 문서의 국외 사용을 위한 인증 방식이 두 가지 있는데 ‘아포스티유’와 ‘영사확인’이다.
영사확인이 일반적인 절차이고 아포스티유는 협약에 따라 영사확인 절차를 보다 보다 간소화 한 것이다.</p>

<p>프로젝트의 목표는 이 두 문서를 암호화 하고 변조 여부를 확인할 수 있는 시스템을 구축하는 것이었다.</p>

<p>아포스티유와 영사확인 문서는 항목이나 구조가 유사했기 때문에 기존에 구축된 서비스도 하나의 테이블을 공유하고 있었다.</p>

<p><object data="/uml/05725b13c788685ea2729a3ba231029d.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="41-초기-설계">4.1. 초기 설계</h3>

<p>기존 시스템을 분석하는 과정에서 나는 영사확인과 아포스티유가 비슷해 보이는 것은 우연일 뿐이며 동일한 문서로 취급하면 안 될 것처럼 보였다. 만약 같은 문서라면 프로젝트 이름이 ‘아포스티유 &amp; 영사확인’은 아니었을 것이다.</p>

<p>그에 반해서 back-end 담당자는 두 개로 분리할 필요가 없다는 주장을 하고 있었다.
결국 타협점으로 REST API만 두 개로 분리하고 테이블 등은 하나로 구현하기로 했다.</p>

<p><object data="/uml/ec5e5e2347907e077d1b58976807c9cf.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="42-설계-변경">4.2. 설계 변경</h3>

<p>그런데 프로젝트가 진행되면서 두 문서의 차이가 구체화 되기 시작했다.
아포스티유와 영사확인의 문서번호가 중복될 수 있어서 문서번호 체계가 달라졌다.
그리고 서비스 기능이 확장 되면서 두 문서의 인터페이스는 점점 달라졌다.</p>

<p>결국 테이블을 둘로 나누고 내부 구조도 분리하기로 결정했다.
다행스럽게도 외부에 노출되는 API는 두 개로 분리되어 있었기 때문에 내부 구조를 변경하는 것은 비교적 수월했다.
만약 분리하는 것이 부담스러워서 리팩토링을 피하려고 했다면 코드 곳곳에 if-else가 넘쳐나고 지옥으로 가는 문이 열렸을 것이다.</p>

<p><object data="/uml/92b9f1fa32a97ec298a8c11ad6c7b8fc.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="43-이런-일이-발생한-이유">4.3. 이런 일이 발생한 이유</h3>

<p>이 사례에서 두 문서의 형식이 같았던 것은 그저 우연일 뿐이었다. 사용자의 요구에 따라서 얼마든지 달라질 가능성이 있었다. 애초에 다른 문서이기 때문에 다른 이름이 붙은 것이라는 사실을 간과한 것이 문제였다.</p>

<p>프로그래머는 종종 구현 편의성을 우선하는 경향이 있다. 그 습관을 버리기가 쉽지 않을 것이다. 그러나 철저하게 도메인의 개념을 따라야 한다.</p>

<h2 id="5-인코딩된-파일명의-저장">5. 인코딩된 파일명의 저장</h2>

<p>사용자가 웹 브라우저로 <code class="language-plaintext highlighter-rouge">[file].txt</code> 파일을 업로드 하려고 한다.</p>

<p>사용자가 업로드 하는 파일명에 특수문자가 포함되어 있어서 URL encoding을 해서 서버에 전송해야 한다. 마찬가지로 사용자가 파일을 다운로드 받으려면 파일명을 URL encoding 해야 한다.</p>

<p>그렇다면 서버는 DB에 인코딩된 문자열(<code class="language-plaintext highlighter-rouge">%5Bfile%5D.txt</code>)을 그대로 저장하는 것이 좋을까? 아니면 이것을 다시 디코딩해서 <code class="language-plaintext highlighter-rouge">[file].txt</code>로 저장하는 것이 좋을까?</p>

<p><code class="language-plaintext highlighter-rouge">[file].txt</code>로 저장하면 사용자에게 파일을 전송할 때 다시 인코딩 해야 한다. 그렇다면 그냥 받은 그대로 <code class="language-plaintext highlighter-rouge">%5Bfile%5D.txt</code>으로 저장하는 것이 효율적이지 않을까?</p>

<p>본질이 무엇인지 알기 위해서 사용자의 생각을 살펴봐야 한다.</p>

<p>사용자가 업로드 한 파일명은 <code class="language-plaintext highlighter-rouge">[file].txt</code>이다. 사용자는 이것이 변환된다고 생각하지 않은다. 그러니까 저장할 때도 사용자의 생각에 맞춰서 <code class="language-plaintext highlighter-rouge">[file].txt</code>으로 저장하는 것이 옳다.</p>

<p>애초에 URL Encoding은 ASCII 문자 집합의 제한 때문에 필요한 것이지, 사용자의 요구사항이 아니다. 특정 기술의 한계 혹은 특성이 다른 영역에 영향을 주는 것은 좋은 구조가 아니다. 그러니까 HTML의 전송 과정에서 발생하는 기술적인 문제는 그 과정에서 해결해야 하는 것이지 그것을 DB까지 가져오면 두 개의 큰 영역이 서로 강하게 결합되는 안티-패턴이 된다.</p>

<p>사용자의 의도를 더 정확하게 반영하는 것이 우선이고 최적화는 그 다음이다.</p>

<p>다운로드 기능만을 고려한다면 받은 그대로 저장하는 것이 최선의 선택일 것이다. 그러나 기능이 확장되면서 파일 목록을 보여주거나 검색을 허용할 때는 원본 문자열(<code class="language-plaintext highlighter-rouge">[file].txt</code>)이 필요할 것이다. 왜냐하면 사용자는 파일명을 <code class="language-plaintext highlighter-rouge">[file].txt</code>으로 생각하기 때문이다. 그런데 저장을 <code class="language-plaintext highlighter-rouge">%5Bfile%5D.txt</code>으로 한다면 조회나 검색 기능을 구현할 때 어려움을 겪을 것이다.</p>

<p>구현 편의성을 추구하면 이렇게 작은 변화에도 쉽게 흔들리게 되는 것이다.</p>

<!-- markdownlint-disable MD034 -->
<p><object data="/uml/543ff9861916ccb443624522babac381.svg" type="image/svg+xml" class="plantuml"></object></p>

<h2 id="6-본질에-기반한-기능-정의">6. 본질에 기반한 기능 정의</h2>

<p>영화 예매 서비스를 개발한다고 할 때 여기에 장바구니 기능을 구현해야 할까? 전자상거래 서비스에서는 장바구니가 필수적인 기능이지만, 영화 예매 서비스에서도 꼭 필요할까?</p>

<p>이 질문에 답하기 위해서는 실제 영화 예매 프로세스에서의 사용자 경험을 생각해 봐야 한다. 일반적으로 사용자가 영화를 예매할 때는 다음과 같은 순서로 진행된다.</p>

<ol>
  <li>영화 선택</li>
  <li>상영 시간 선택</li>
  <li>좌석 선택</li>
  <li>결제</li>
</ol>

<p>이 과정에서 우리는 “장바구니에 담기”와 같은 중간 단계를 발견할 수 없다. 사용자는 영화, 시간, 좌석을 선택하고 바로 결제를 진행한다.</p>

<p>그렇다면 온라인 영화 예매 서비스에 장바구니 기능을 추가하는 것은 사용자의 실제 경험과는 거리가 먼 결정이 될 수 있다. 오히려 불필요한 복잡성을 야기하고, 온라인과 오프라인에서의 경험 간 일관성을 해칠 수 있다.</p>

<p>물론 “나중에 결제하기 위해 선택한 영화를 저장해 두는 기능이 있으면 좋겠다”라는 사용자 요구사항이 있을 수 있다. 하지만 이 경우에도 “장바구니”라는 개념을 그대로 가져오기보다는, 영화 예매 서비스의 맥락에 맞는 개념으로 재해석할 필요가 있다. 예를 들어, “관심 영화 저장” 또는 “예매 내역 저장” 등의 기능으로 제공하는 것이 더 적절할 수 있다.</p>

<h2 id="7-본질에-기반한-네이밍">7. 본질에 기반한 네이밍</h2>

<p>백엔드에 대한 기본적인 지식을 전달하기 위한 프로젝트로 영화 예매 서비스 개발을 시작하려고 한다. 프로젝트의 이름을 무엇이라고 해야 할까? 영화 예매니까 ticket-service이라고 하면 어떨까?</p>

<p>우리가 만들려고 하는 것은 ticket-service가 맞다. 그러나 왜 만들려고 하는가를 생각해 보면 backend-fundamentals이 더 좋은 선택이다. ticket-service는 백엔드의 기본적인 지식을 전달하기 위한 수단에 불과하다. 수단은 언제든지 변경될 수 있다.</p>

<p>이 경우처럼 코드가 아니어도 선택의 순간에는 본질을 통찰하는 사고가 필요하다. 나의 경우 매 순간 습관처럼 내가 인지한 정보의 본질이 무엇인지를 고민한다.</p>

<h2 id="8-결론">8. 결론</h2>

<p>지금까지 살펴본 사례들이 보여준 공통점은 ‘무엇(what)’이 아니라 ‘왜(why)’에 집중한다는 것이다. ‘무엇(what)’은 ‘왜(why)’에 도달하기 위한 방법 중에 하나일 뿐이다. 목적(why)은 쉽게 바뀌지 않지만 방법(what)은 여러 상황에 따라서 얼마든지 바뀔 수 있다.</p>

<p>나는 이 사고방식을 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>이라고 정의했다. <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>은 무언가를 바라볼 때 그 본질을 통찰하려는 노력이다.</p>

<p>이것은 <code class="language-plaintext highlighter-rouge">도메인 주도 디자인(DDD)</code>를 고민하다가 떠올린 개념인 만큼 <code class="language-plaintext highlighter-rouge">도메인 주도 디자인(DDD)</code>과 비슷한 맥락을 가진다. 그래서 굳이 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>이라는 거창한 이름으로 정의하려니 좀 창피하기도 하다. 그러나 나를 포함한 많은 개발자들이 이 개념의 존재를 보다 분명하게 인지하는데 도움이 되기를 바라는 마음으로 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>을 정의하고자 한다.</p>

<p>‘왜(why)’에 집중해야 하는 다른 중요한 이유는 분석 단계에서 사용자의 모든 생각을 문서로 정리할 수 없기 때문이다. 이것은 설계도 마찬가지인데 설계 단계에서 설계자의 모든 생각을 정리할 수 없다. 모든 요구사항과 설계를 최대한 반영한 것이 코드이기 때문이다. 어느 정도 빈틈이 있을 수 밖에 없고 그 빈틈은 굳이 말하지 않아도 알 것이라고 생각하는 것들이다. 문제는 사용자가 당연하게 생각하는 것들을 개발자는 전혀 다르게 받아들일 수 있다는 것이다.</p>

<p>그러나 ‘왜(why)’에 집중해서 사고하면 결국 같은 곳을 바라보기 때문에 의사소통에 다소의 빈틈이 있더라도 그 오차가 크지 않다. 이렇게 사용자와 개발자 간에 발생할 수 있는 생각의 차이를 줄이는 것이 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>의 중요한 역할 중 하나이다.</p>

<p><code class="language-plaintext highlighter-rouge">본질 기반 해석(Essence-Based Interpretation, EBI)</code>은 너무 당연하고 원론적인 개념이라서 대상 범위나 구체적인 실천 방법을 정의하기가 어렵다. 그리고 개발에만 국한되는 것도 아니다.</p>

<p><code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>은 도메인에 기반해야 한다는 점에서 도메인 주도 개발(DDD)과 비슷한 맥락을 가진다. 그러나 DDD는 보다 체계적이고 구체적인 설계 방법론으로 복잡하거나 변화가 잦은 도메인에 대응하는 것이 주 목적이다. 반면에 본질 기반 해석(EBI)은 구체적인 방법론이라기보다는, 소프트웨어 개발을 포함한 다양한 분야에 적용할 수 있는 일반적인 사고방식이라 할 수 있다.</p>

<p>좋은 코드에 대한 고민은 사고방식의 변화를 가져오며, 이는 본질을 통찰하여 예측 불가능한 변화에 대응하는 전략으로 이어진다. 이는 소프트웨어 개발 특유의 소중한 도전이다.</p>]]></content><author><name>mannercode</name><email>hello@mannercode.com</email></author><summary type="html"><![CDATA[1. 소개]]></summary></entry><entry><title type="html">객체 지향 프로그래밍의 이해</title><link href="/2024/03/09/oop.html" rel="alternate" type="text/html" title="객체 지향 프로그래밍의 이해" /><published>2024-03-09T00:00:00+00:00</published><updated>2024-03-09T00:00:00+00:00</updated><id>/2024/03/09/oop</id><content type="html" xml:base="/2024/03/09/oop.html"><![CDATA[<blockquote>
  <p>객체 지향 프로그래밍은 데이터와 함수를 하나의 ‘객체’로 그룹화하여 응집성은 높이고 의존성은 낮추는 프로그래밍 패러다임이다.</p>
</blockquote>

<p>OOP를 학습할 때 가장 중요한 것은 사고의 전환이다. 마틴 파울러는 사고의 전환을 이루기 위한 가장 좋은 방법은 OOP가 잘 구성된 환경에서 얼마간 일해보는 것이라고 한다. 그러나 OOP를 제대로 이해한 개발자가 많지 않아서 그런 환경을 찾기가 쉽지 않다.</p>

<p>본 글에서는 절차식에서 객체 지향 방식까지 코드를 개선해 가면서 OOP의 본질이 무엇인지 알아보고 사고의 전환을 이루는데 조금이나마 도움이 되려고 한다.</p>

<h2 id="1-절차식-코드-소개">1. 절차식 코드 소개</h2>

<p>먼저, 버퍼에서 문서를 읽어서 한 글자씩 출력하는 함수를 작성해 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 버퍼에서 읽기 */</span>
<span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>

  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">buffer</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="11-절차식-코드에-기능-추가하기">1.1. 절차식 코드에 기능 추가하기</h3>

<p>여기에 파일에서 문서를 읽어서 한 글자씩 출력하는 기능을 추가해 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

  <span class="cm">/* 파일에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 파일에서 읽기 */</span>
    <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

      <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이것이 전형적인 절차식이다. 절차식의 특징 중 하나는 if가 자주 나온다는 것이다.</p>

<h2 id="2-절차식-코드의-문제점">2. 절차식 코드의 문제점</h2>

<p>만약 여기에 REST API로 읽는 기능을 추가해야 한다면 어떻게 될까? main()함수는 물론이고 printDocument() 함수도 변경되어야 한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

  <span class="cm">/* 파일에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>

  <span class="cm">/* REST API 요청 */</span>
  <span class="kd">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HttpRequest</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://test.com/api</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">request</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span> <span class="o">|</span> <span class="nx">HttpRequest</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 파일에서 읽기 */</span>
    <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

      <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* REST API 요청 */</span>
    <span class="kd">const</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">body</span><span class="p">();</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">body</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">body</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>지금처럼 printDocument() 함수 하나만 변경하는 것이라면 문제가 되지 않는다. 그러나 printDocument() 외에 다른 함수가 있다면? 변경해야 하는 함수가 그 만큼 늘어난다.</p>

<h3 id="21-중첩된-함수에서의-문제">2.1. 중첩된 함수에서의 문제</h3>

<p>실제 프로젝트는 이것보다 더 길고 복잡한 코드인 경우가 많다. 이런 환경에서 관련된 모든 함수를 찾아서 변경하는 것은 쉽지 않다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span>
    <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
    <span class="nf">updateDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="dl">"</span><span class="s2">new contents</span><span class="dl">"</span><span class="p">)</span>
    <span class="nf">clearDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>

    <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">)</span>
    <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
    <span class="nf">updateDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="dl">"</span><span class="s2">new contents</span><span class="dl">"</span><span class="p">)</span>
    <span class="c1">// clear 하려면 close 해야 한다는 규칙을 알아야 한다.</span>
    <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
    <span class="nf">clearDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">updateDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">,</span> <span class="nx">contents</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">doc</span> <span class="o">=</span> <span class="nx">contents</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">){</span>
        <span class="nx">doc</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">){</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">clearDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">doc</span> <span class="o">=</span> <span class="dl">""</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">){</span>
        <span class="nx">doc</span><span class="p">.</span><span class="k">delete</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">){</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">()</span>

        <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>

            <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">){</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>if는 코드의 복잡도를 증가시키고 개발을 어렵게 한다. 그렇다고 if문을 제거하면 더 큰 부작용이 발생한다.</p>

<h2 id="3-절차식-코드의-개선-방법">3. 절차식 코드의 개선 방법</h2>

<h3 id="31-함수-세분화하기">3.1. 함수 세분화하기</h3>

<p>if를 피하는 방법으로 printDocument()를 세분화 하는 방법을 생각할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nf">printBufferDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printFileDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printBufferDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printFileDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

    <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>언뜻 괜찮은 방법처럼 보인다.</p>

<p>그런데 보통은 아래처럼 중첩해서 함수를 호출하기 마련이다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span>
    <span class="nf">printBufferWeeklyReport</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>

    <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">)</span>
    <span class="nf">printFileWeeklyReport</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printBufferWeeklyReport</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span><span class="p">){</span>
    <span class="cm">/* report를 생성하는 코드*/</span>
    <span class="p">...</span>

    <span class="nf">printBufferDocument</span><span class="p">(</span><span class="nx">report</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printFileWeeklyReport</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">File</span><span class="p">){</span>
    <span class="cm">/* report를 생성하는 코드*/</span>
    <span class="p">...</span>

    <span class="nf">printFileDocument</span><span class="p">(</span><span class="nx">report</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>확실히 if 문이 사라지긴 했다. 그러나 if를 피하기 위해서 ‘report를 생성하는 코드’를 반복하게 된다. 이럴거면 차라리 if를 사용하는 것이 낫다.</p>

<h3 id="32-실행-코드-전달하기">3.2. 실행 코드 전달하기</h3>

<p>printDocument()에서 if를 제거할 수 없는 근본 원인은 main() 함수에서 printDocument()에 필요한 데이터만 전달할 뿐, 그 데이터를 사용하는 방법은 전달하지 않기 때문이다.</p>

<p>그래서 printDocument()는 데이터의 유형에 따라서 실행해야 하는 코드를 판별해야 하는 것이다.</p>

<p>그렇다면 실행해야 하는 코드도 같이 전달하면 어떨까?</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">getCharFromBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">position</span> <span class="o">==</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">position</span><span class="o">++</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">getCharFromBuffer</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">getCharFromFile</span> <span class="o">=</span> <span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">File</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

    <span class="k">return</span> <span class="nx">char</span> <span class="o">==</span> <span class="nx">EOF</span> <span class="p">?</span> <span class="kc">null</span> <span class="p">:</span> <span class="nx">char</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">getCharFromFile</span><span class="p">);</span>
  <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">getChar</span><span class="p">:</span> <span class="nx">Func</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nf">getChar</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

    <span class="nx">char</span> <span class="o">=</span> <span class="nf">getChar</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>비록 main() 함수는 더 복잡해졌지만 printDocument()는 if 문이 필요없고 어떤 형식이 오더라도 변경하지 않아도 된다.</p>

<p>이제 어떻게 하면 main() 함수를 깔끔하게 정리할 수 있을까?</p>

<h2 id="4-객체-지향-코드">4. 객체 지향 코드</h2>

<p>main() 함수를 깔끔하게 정리하기 위해서 우리는 클래스를 사용할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">bufferDocument</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferDocument</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">bufferDocument</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">fileDocument</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileDocument</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">fileDocument</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">reader</span><span class="p">:</span> <span class="nx">DocumentReadable</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="nx">char</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nx">reader</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">DocumentReadable</span> <span class="p">{</span>
  <span class="nf">getChar</span><span class="p">():</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nf">close</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">BufferDocument</span> <span class="k">implements</span> <span class="nx">DocumentReadable</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">position</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">buffer</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">getChar</span><span class="p">():</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">position</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>

    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">position</span><span class="o">++</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">FileDocument</span> <span class="k">implements</span> <span class="nx">DocumentReadable</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">stream</span><span class="p">:</span> <span class="nx">ReadStream</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="nx">filename</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">stream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">getChar</span><span class="p">():</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">stream</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">char</span> <span class="o">!==</span> <span class="nx">EOF</span> <span class="p">?</span> <span class="nx">char</span> <span class="p">:</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">close</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">stream</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 객체 지향 방식에서의 printDocument()에는 문서 타입을 판별하는 if 문이 없다. main()에서 객체를 처음 생성할 때 필요한 것들이 모두 정해진다. printDocument()는 주어진 객체를 사용하기만 하면 되는 것이다.</p>

<blockquote>
  <p>코드에 if 문이 보인다면 이것이 절차식은 아닌지? 객체 지향으로 개선할 수 없는지 고민해 보기를 바란다.</p>
</blockquote>

<p>앞서 절차식은 printDocument()에 필요한 데이터만 전달할 뿐, 그 데이터를 사용하는 구체적인 방법(함수)은 전달하지 않는다고 했다. 객체 지향 방식은 데이터와 그 데이터를 사용하는 함수를 객체로 묶어서 전달한다. 이것이 가장 크고 두드러지는 차이점이다.</p>

<h2 id="5-좋은-객체의-특징">5. 좋은 객체의 특징</h2>

<p>코드를 클래스 다이어그램으로 표현해 보자.</p>

<p><object data="/uml/152ad9a5674298d75d5a14fc5eceea85.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="51-관심사-분리">5.1. 관심사 분리</h3>

<p><code class="language-plaintext highlighter-rouge">printDocument()</code> 함수는 <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스를 사용하기만 한다.<br />
<code class="language-plaintext highlighter-rouge">BufferDocument</code>나 <code class="language-plaintext highlighter-rouge">FileDocument</code>는 <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스에 맞춰서 각자 기능을 제공하기만 한다.</p>

<p>그러니까 <code class="language-plaintext highlighter-rouge">printDocument()</code>, <code class="language-plaintext highlighter-rouge">BufferDocument</code>, <code class="language-plaintext highlighter-rouge">FileDocument</code>가 아는 것은 <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스 뿐이고 서로에 대해서는 알지 못한다. 이것은 즉, <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스가 변경되지 않는 한 각 클래스 혹은 함수를 변경할 필요가 없다는 뜻이다.</p>

<p>다시 설명하자면 인터페이스를 변경하지 않는다면 각 부분을 어떻게 변경하든 다른 부분에는 영향을 미치지 않는다는 것이다. 이것이 객체 지향 프로그래밍이 점진적인 개발을 가능하게 하는 방법이다. 이렇게 인터페이스와 구현을 분리하는 매커니즘은 자연스럽게 응집성이 높아지면서 의존성이 낮아지는 결과가 된다.</p>

<blockquote>
  <p>절차식 사고에 익숙하면 이렇게 기능을 응집시키고 그 부분에만 집중하는 방법 자체에 서투른 경우를 보게 된다. 그것은 코드 뿐만이 아니라 업무를 분담하고 협업하는 등의 일상적인 업무에서도 나타난다.</p>

  <p>예를 들면, 프론트엔드와 백엔드 개발자가 REST API를 정의하고 각자 개발을 진행한다. 그러다 기존에 정의한 REST API를 만족시키지 못하는 오류가 백엔드에서 발생한다. 디버깅을 해보니 백엔드에서 코드를 수정하는 것보다 REST API를 변경하고 프론트엔드에서 코드를 수정하는 것이 더 간단한 상황이다. 백엔드 개발자는 프론트엔드 개발자에게 코드를 수정해 달라고 요청하고 프론트엔드 개발자도 기꺼이 동의한다.</p>

  <p>REST API를 설계했을 때의 원칙을 저버리는 것은 큰 문제다. 더군다나 백엔드의 문제를 프론트엔드까지 끌어들이면서 백엔드와 프론트엔드는 그 만큼 더 강하게 결합하게 된다.</p>

  <p>이 정도 사소한 변경이 그렇게 큰 문제일까 싶은 의문이 들지도 모르겠다. 코딩하는 당시에는 대수롭지 않겠지만 시간이 지나고 다른 개발자가 코드를 분석하려고 할 때 장애가 된다.</p>

  <p>“각자의 작업 영역은 엄격하게 지켜야 한다.”</p>

  <p>절차식 사고에 익숙한 개발자는 이 말을 이기적이고 냉정한 것으로 받아들이는 경우가 있다. 그러나 이것은 지극히 기술적인 접근일 뿐이다.</p>
</blockquote>

<h3 id="52-접근-제어">5.2. 접근 제어</h3>

<p>함수들은 변수를 통해서 서로 연결된다고 볼 수 있다.</p>

<p>전역변수를 생각해 보자. 흔히 전역변수를 사용하면 안 된다고 한다. 왜냐하면 하나의 전역변수를 사용하는 모든 함수들은 서로 연결되는 것이다. 소스코드가 10만 라인이 넘어가는 상황에서 다른 함수들이 내가 생각한 규칙대로 움직인다고 어떻게 보장할 수 있을까?
이것은 복잡도를 엄청나게 상승시킨다.</p>

<blockquote>
  <p>코드를 변경할 때 그 영향이 어디까지 미치는 것인지 파악이 안 된다면 거의 반드시 버그를 만들고 있는 것이다.</p>
</blockquote>

<p>아래의 그림에서 count 변수를 사용하는 read(), write(), change(), reset() 함수들은 서로 연결되어 있다. 특히 값을 변경하는 change(), reset() 함수는 다른 모든 함수에 직접적인 영향을 끼친다.</p>

<!-- markdownlint-disable MD032 MD037 -->
<p><object data="/uml/62794e45846be2ea9677da1605c99ef9.svg" type="image/svg+xml" class="plantuml"></object></p>

<p>반면에 <code class="language-plaintext highlighter-rouge">BufferDocument</code>의 <code class="language-plaintext highlighter-rouge">buffer</code>나 <code class="language-plaintext highlighter-rouge">position</code>을 사용하는 함수는 <code class="language-plaintext highlighter-rouge">BufferDocument</code> 클래스에만 존재할 수 있다.
왜냐하면 두 프로퍼티(변수)가 비공개이기 때문에 외부에서의 접근이 원천적으로 차단되기 때문이다.</p>

<p>이것이 프로퍼티를 public으로 직접 노출하지 말라는 이유이다. 외부에서 프로퍼티를 변경할 수 있다면 프로퍼티와 관련된 코드를 변경할 때 그 영향이 어디까지 미칠지 알 수 없게 된다. 잠재적으로 전역변수와 다를바 없게 되는 것이다.</p>

<h2 id="6-객체-지향의-응용">6. 객체 지향의 응용</h2>

<p>객체 지향 방식의 관심사 분리를 통한 복잡도 관리 및 변화에 의한 영향을 최소화 하는 특징은 다른 분야에도 영향을 끼친다.</p>

<h3 id="61-microservices-architecture">6.1. Microservices Architecture</h3>

<p>MSA는 구조적으로 객체 지향 방식과 유사한 면이 많다.</p>

<p>객체 지향의 핵심은 데이터와 함수를 하나의 객체로 묶는 것이다. MSA에서 서비스도 DB와 API를 하나로 묶어서 관리하고 각 서비스의 내부 구현과 DB는 외부에 노출되지 않는다. 이것은 서비스 내부의 변화가 외부에 영향을 미치지 않도록 하면서 유지보수성과 확장성에 큰 장점이 된다.</p>

<p><object data="/uml/5343b720ca16b12ee6bef537a977a2af.svg" type="image/svg+xml" class="plantuml"></object></p>

<p>OOP와 MSA가 구조적으로 유사하다는 사실에서 알 수 있듯이, OOP를 제대로 이해하지 못하면 MSA와 같은 아키텍처를 이해하고 올바르게 설계하는 것은 많이 어려운 일이 될 것이다.</p>

<p>요즘은 MSA가 유행인 것 같다. 그리고 많은 개발자들이 API gateway나 gRPC, 메시지 브로커 등 MSA 구성 요소들의 사용법을 익히는 데만 열중하는 것 같다. 그러나 가장 중요하고 기본적인 것은 OOP에 대한 깊은 이해이다.</p>

<h3 id="62-애자일-방법론">6.2. 애자일 방법론</h3>

<p>디자이너, 개발자, 기획자 등 관련자들이 한 팀을 이뤄 긴밀하게 협력하는 작업 방식은 객체 지향 프로그래밍(OOP)의 핵심 원칙인 높은 응집성과 낮은 결합도에 비유할 수 있다. 이러한 접근 방식은 소프트웨어 개발 뿐만 아니라, 조직 구성과 팀워크에서도 생산성과 효율성을 높이는 데 중요한 역할을 한다.</p>

<p>애자일 팀의 구성 자체가 데이터와 함수를 하나로 묶는 객체와 동일한 구조는 아니다. 그러나 애자일 팀에서는 기획자가 요구사항이라는 데이터를 생산하고, 개발자가 이를 구현한다는 점에서 데이터의 생산과 소비 주체가 함께 있다는 유사성을 찾을 수 있다. 이는 마치 객체 내부에서 데이터(속성)와 함수(메서드)가 밀접하게 연관되어 있는 것과 같은 맥락으로 볼 수 있다.</p>

<p>한편, 애자일 방법론의 중요 원칙인 점진적인 개발을 반복하는 프로세스는 객체 지향 설계의 관심사 분리를 기반으로 가능한 것이다. 객체 지향 프로그래밍은 시스템을 독립적인 객체들의 상호작용으로 모델링하므로, 각 객체를 개별적으로 개발하고 테스트할 수 있게 해준다. 이는 애자일 방법론이 지향하는 작은 단위의 개발과 피드백 반영을 원활히 하는 데 도움이 된다. 결과적으로 OOP는 애자일 소프트웨어 개발의 기반이 되는 주요 기법 중 하나로 자리매김하고 있다.</p>

<h2 id="7-결론">7. 결론</h2>

<p>이 글은 이렇게 시작했다.</p>

<blockquote>
  <p>객체 지향 프로그래밍은 데이터와 함수를 하나의 ‘객체’로 그룹화하여 응집성은 높이고 의존성은 낮추는 프로그래밍 패러다임이다.</p>
</blockquote>

<p>그렇다. 데이터와 함수를 하나의 객체로 그룹화 한다는 것이 객체 지향의 핵심이다.
그러나 OOP를 설명하는 많은 글이나 영상은 OOP의 캡슐화, 은닉화, 다형성, 상속성이 무엇인지를 설명한다. OOP의 이 네 가지 기본 원칙은 데이터와 함수를 그룹화 할 때의 지침일 뿐이다. 가장 기본적이고 필수적인 것은 데이터와 함수의 그룹화이다.</p>

<p>그렇다면 데이터만 존재하는 객체가 있을 수 있을까? 반대로 함수만 존재하는 객체가 있을 수 있을까?
문법적으로 class를 사용해서 코드를 작성한다고 해도 그것은 객체가 아니다. 객체는 상태(프로퍼티)와 방법(메소드)이 함께해야 의미를 가진다.</p>

<p>지금 이 글을 읽고 뭔가를 알것 같은 느낌을 받았을지도 모른다. 그러나 실제로 자신의 코드를 객체지향으로 바꿔보기 전에는 그것이 구체화 되지는 않을 것이다.
좋은 코드가 무엇인지 많은 고민과 연습이 필요하다.</p>

<p>현대적인 개발 방법론의 근간에는 OOP가 있다. OOP를 깊이있게 이해하지 못하면 TDD, DDD, 애자일, MSA 등 현대적인 개발 방법을 공부해도 올바르게 사용하기 어려울 것이다. 실제로 MSA를 적용한 프로젝트는 많지만 성공 사례가 적은 이유이다.</p>

<p>객체지향 프로그래밍에서 자주 사용하는 일반적인 패턴을 모아놓은 것이 디자인 패턴이다. 이것은 다음 기회에 다루겠다.</p>]]></content><author><name>mannercode</name><email>hello@mannercode.com</email></author><summary type="html"><![CDATA[객체 지향 프로그래밍은 데이터와 함수를 하나의 ‘객체’로 그룹화하여 응집성은 높이고 의존성은 낮추는 프로그래밍 패러다임이다.]]></summary></entry><entry><title type="html">소프트웨어 개발의 이념 전쟁: 원리주의와 실용주의</title><link href="/2024/02/03/pragmatism-principlism.html" rel="alternate" type="text/html" title="소프트웨어 개발의 이념 전쟁: 원리주의와 실용주의" /><published>2024-02-03T00:00:00+00:00</published><updated>2024-02-03T00:00:00+00:00</updated><id>/2024/02/03/pragmatism-principlism</id><content type="html" xml:base="/2024/02/03/pragmatism-principlism.html"><![CDATA[<p>과거 냉전 시대의 공산주의와 자유주의 만큼이나 양립할 수 없는 두 이념이 소프트웨어 개발에 존재한다. 원리주의와 실용주의가 그것이다. 소프트웨어 개발은 매우 복잡한 과정이며, 이 두 가지 이념은 각각 다른 방식으로 문제를 해결하려고 한다. 그렇기 때문에 이 두 이념은 소프트웨어 개발의 성공과 실패에 큰 영향을 미칠 수 있다.</p>

<p>원리주의자는 체계적인 소프트웨어 개발 이론을 기반으로 소프트웨어 개발을 진행해야 한다는 입장이다. 유지보수가 중요하고 멀리 보고 신중하게 코드를 작성한다. 반면, 실용주의자는 문제를 최대한 간단하게 해결하자는 입장이다. 초기에 많은 시간을 들여서 작업을 하느니 문제가 생길 때마다 대응하는 것이 효율적이라고 생각한다.</p>

<p>다양한 성향의 사람들이 있고 많은 상황들이 있기 때문에 여기서 모든 인간 유형을 다루는 것이 아니다. 여기서는 <code class="language-plaintext highlighter-rouge">극단적인 원리주의자</code>와 <code class="language-plaintext highlighter-rouge">극단적인 실용주의자</code> 그리고 그 중간의 입장을 알아보려고 한다.</p>

<h2 id="1-원리주의-팀원">1. 원리주의 팀원</h2>

<p>성장 욕구와 열정이 넘치는 주니어 개발자라면 높은 확률로 원리주의 팀원이 될 것이다. 이런 원리주의 팀원이 원리주의 팀장을 만나면 행복하겠지만 현실은 원리주의 팀원과 실용주의 팀장의 조합이 더 많다.</p>

<p>실용주의 팀장에 속한 원리주의 팀원은 개발팀에서 힘든 위치에 놓일 수 있다. 팀장에게 코드 리뷰를 기대하지 못하는 것은 당연하고 팀장이 일정을 재촉하기 때문에 코드 품질에 신경 쓸 여력도 없다. 일정에 여유가 있어서 리팩토링을 하더라도 팀장의 눈치를 봐야 한다. 문제가 발생하면 원리주의 팀원은 그 원인이 무엇인지 파악하고 올바르게 조치하기 위해서 노력한다. 그러나 실용주의 팀장이 원인을 무시하고 문제를 쉽게 해결할 수 있는 방법을 강요할 수 있다.</p>

<p>이런 일이 반복되면 원리주의 팀원은 답답함을 느낀다. 팀장의 실력이 부족한 것은 물론이고 책임감 없이 일을 대충 처리하는 것으로 보인다. 팀장에게서 배울 것이 없고 존경할 만한 업무 태도도 아니라고 생각하기 때문에 팀장을 무시하는 언행을 하기도 한다. 팀장도 그것을 느끼고 원리주의 팀원을 감정적으로 대한다. 원리주의 팀원은 정신적으로 점점 힘들어지고 결국 퇴사를 하게 된다. 그렇지만 회사를 옮겨도 결국 높은 확률로 실용주의 팀장을 만나게 되기 때문에 원리주의 팀원의 어려움은 쉽게 해결되지 않는다.</p>

<p>원리주의 팀원은 성장 욕구가 강한 만큼 회사의 업무가 자신의 성장에 도움이 되지 않는다고 생각하면 초조해 할 것이다. 성장에 도움이 되지 않는 일은 기술부채가 잔뜩 쌓인 코드를 유지보수 하거나 신규 개발이라도 오래되거나 대중적이지 않은 기술을 사용하는 프로젝트가 있다.</p>

<p>이런 상황에서 실용주의 팀장이라면 현재 상황을 유지하려는 경향이 강하기 때문에 대규모 리팩토링이나 신기술 도입을 가능한 피하려고 할 것이다. 원리주의 팀원이 대안을 제시해도 수용하지 않을 것이다. 첫 단추를 잘 꿰어야 하듯이 주니어 시절의 프로젝트가 개발자의 성장 방향에 큰 영향을 줄 수 있다. 맞지 않다고 생각되면 과감하게 팀을 떠나는 것도 나쁘지 않다.</p>

<p>그러나 팀장이 원리주의 성향이라면 기다리는 것을 추천한다. 현재 프로젝트에 기술적인 문제가 많다면 새로 만들 기회가 생길 수도 있다. 그렇게 되면 기존 프로젝트를 유지보수 하면서 도메인과 요구사항을 파악했기 때문에 기술에 더 집중할 수 있는 환경이 될 것이다. 물론 원리주의 팀원 자신이 그런 프로젝트를 맡을 수 있을 만큼 준비가 되어있어야 한다.</p>

<p>원리주의 팀원에게 이런 말을 전하고 싶다.</p>

<p><code class="language-plaintext highlighter-rouge">회사는 학원이 아니다.</code></p>

<p>회사는 내 시간과 기술을 팔고 돈을 받는 곳이다. 회사에서 하고 싶은 일만 할 수는 없다.</p>

<blockquote>
  <p>나는 잦은 이직을 하고 여러 팀장을 만나면서 내 뜻을 존중해 주는 팀장도 있었지만 그 중에서 두 번은 극단적인 실용주의 팀장이었다. 이 극단적인 실용주의 팀장은 자신감과 열정이 넘치는 어린 팀원이 마음에 들지 않았는지 노골적으로 견제하는 모습을 보여주기도 했다. 그래도 나는 팀원의 입장에서 최대한의 존중을 했다고 생각한다. 팀장과 갈등을 겪고 있을 때 다른 팀원들에게 내가 뭔가 잘못했냐고 여러차례 물어봤지만 단지 둘이 안 맞아서 그렇다는 대답이 대부분이었다.</p>

  <p>지금 생각해 보면 실용주의 팀장 자신의 개발 역량이 뒤쳐지는 것을 불안해 하는 와중에, 원리주의 팀원이 디자인 패턴이나 리팩토링 같은 개발 이론을 공공연하게 떠들고 다니면서 그 불안감을 더 자극한 것은 아닐까 싶다. 그래서 실용주의 팀장의 눈에 자신감 넘치고 눈치는 없는 팀원이 곱게는 안 보였을지도 모른다.</p>
</blockquote>

<h2 id="2-원리주의-팀장">2. 원리주의 팀장</h2>

<p>원리주의 팀원의 열정이 계속 된다면 대체로 원리주의 팀장이 된다. 팀장이라고 했지만 프로젝트의 주도권을 갖고 개발하는 위치에 있다면 여기에 해당한다.</p>

<h3 id="21-오버-엔지니어링">2.1. 오버 엔지니어링</h3>

<p>원리주의 팀장은 미래 대비에 지나치게 집착하는 경향이 있다. 이는 과도한 추상화, 불필요한 디자인 패턴의 적용 등의 오버 엔지니어링으로 나타난다. 이것은 오히려 코드의 복잡성을 높이고 개발 효율성을 저하시키는 결과를 초래한다. 유지보수를 위한 원리주의가 오히려 유지보수성을 해치는 비극이 되는 것이다.</p>

<p>이런 오버 엔지니어링은 관리자에게 답답함과 불안감을 느끼게 한다. 원리주의 팀장이 설계의 중요성을 역설하면서 열심히 하고는 있는데 눈에 보이는 것이 없으니 일정이 무척 걱정된다. 프로젝트 초기에는 시간 여유가 있어서 믿고 기다려 보지만 한계점에 이르면 적극적으로 일정을 관리하게 된다.</p>

<p>원리주의 팀장이 미래 대비를 철저히 할수록 프로젝트 전체를 통찰하는 데에는 약할 수 있다. 설계와 기술연구에 많은 시간을 소비한 상태에서 프로젝트 중간에 요구사항이 크게 변경되거나 미처 파악하지 못한 기술적인 문제가 드러나면 어떻게 될까?</p>

<p>원리주의 팀장은 이런 문제의 원인이 개발팀 외부에 있기 때문에 자신의 책임이 아니라고 생각할 수 있다. 그리고 이런 문제에 대비하는 것은 불가항력이기 때문에 프로젝트 기간을 늘리거나 기능을 줄이는 것이 합리적이라고 생각할 수 있다. 그러나 관리자는 이런 변화나 문제에 쉽게 대응하지 못한다면 왜 설계에 많은 시간을 할애했는지 납득할 수 없을 것이다.</p>

<p>이렇게 되면 관리자 입장에서는 유지보수야 어찌됐든 당장의 생산성이라도 높은 실용주의 팀장의 개발 방법이 더 나을 수 있다. 원리주의 팀장은 그런 관리자의 평가를 납득하지 못한다. 좋은 품질을 위한 자신의 노력이 부정당하는 것에 답답함을 느낀다.</p>

<blockquote>
  <p>일부는 내 이야기다. 나는 새 프로젝트를 시작하면 항상 기술적인 도전 과제를 설정하고는 했다. 이번 프로젝트에서는 TDD나 DDD를 적용해 보는 식으로 말이다. 이 도전이 얼마나 많이, 또 오래 지속되는지는 관리자의 피드백에 달렸다. 대체로 프로젝트를 시작하고 한 달이 넘도록 제품 개발은 더디고 기술 연구만 하고 있으면 개발 진행이 더디다는 관리자의 주의가 주어진다.</p>
</blockquote>

<h3 id="22-오버-프로세싱">2.2. 오버 프로세싱</h3>

<p>오버 프로세싱은 과도하게 형식적이고 비효율적인 개발 프로세스를 뜻한다.</p>

<p>오버 엔지니어링이 관리자를 힘들게 한다면 오버 프로세싱은 팀원들을 힘들게 하는데, 주로 다음과 같은 것들이 있다.</p>

<ol>
  <li>지나치게 형식적이고 자세한 개발 문서 요구</li>
  <li>지나치게 엄격한 코딩 규칙 적용</li>
  <li>테스트 커버리지에 대한 강박</li>
</ol>

<p>원리주의 팀장은 높은 테스트 커버리지를 달성하기 위해 팀원들에게 과도한 테스트 작성을 요구하곤 한다. 물론 테스트는 중요하지만, 무작정 커버리지 수치를 높이는 데에만 집중하다 보면 오히려 코드의 유연성이 떨어지고 테스트 코드 자체가 복잡해져서 유지보수가 어려워진다.</p>

<p>원리주의 팀장의 올바른 개발 방법론 주장에 팀원들은 많은 기대를 할 수 있다. 그러나 얼마 지나지 않아 원리주의 팀장의 지나치게 체계적인 접근과 꼼꼼한 계획 요구에 팀원들은 지칠 것이다.</p>

<p>원리주의 팀장의 관리가 느슨하다면 팀원들은 조금씩 지시를 무시하기 시작할 것이다. 반면, 관리가 철저하다면 팀장 자신이 코딩할 시간이 줄어드는 것은 물론이고, 팀원들의 사소한 잘못들을 지적하게 된다. 팀원들은 사소한 지적에 압박감을 느낄 것이고, 원리주의 팀장은 팀원들의 부족함에 답답함을 느낄 것이다.</p>

<p>원리주의 팀장의 지나친 요구사항들은 때로는 팀장 자신도 완벽하게 해내기 어려운 업무일 수 있다. 특히 소프트웨어 설계는 복잡하고 추상적인 개념을 다루기 때문에, 자신의 아이디어를 명확하게 문서화하는 것조차 쉽지 않다. 그런데도 원리주의 팀장은 경험이 부족한 팀원들에게 제대로 된 가이드라인도 없이 설계를 요구하곤 한다. 이는 마치 초등학생이 독후감을 써야 하는 것만큼이나 팀원들에게는 막막한 일이 될 수밖에 없다.</p>

<blockquote>
  <p>새 회사에 팀장으로 합류했을 때였다. 이전 팀장이 열정 넘치는 원리주의자였는지 팀원들에게 테스트의 코드 커버리지 100%를 요구했다고 한다. 물론 100%를 유지하는 것은 좋은 목표다. 문제는 함수마다 테스트를 꼼꼼하게 작성해서 작은 변경에도 많은 테스트가 깨진다는 것이다. 함수는 독립적으로 실행되는 것이 아니라 다른 함수를 호출하고 호출된다. 그래서 테스트는 유지보수와 생산성 등을 고려해 적절한 단위로 작성되어야 하는데, 이 부분이 간과된 것으로 보인다.</p>

  <p>결과적으로 테스트 코드가 1/10로 줄어들면서 팀원들은 더 적극적으로 테스트 코드를 작성하게 됐다.</p>
</blockquote>

<h3 id="23-문제의-원인">2.3. 문제의 원인</h3>

<p>원리주의 팀장은 가장 많은 시행착오를 겪는 시기인데, 이는 권한에 비해 실력과 경험이 부족하기 때문이다. 개인에 따라서는 넘치는 자신감이 문제를 더 키우기도 한다.</p>

<p>열정과 자신감은 어느 정도 비례 관계에 있기 때문에, 열정이 넘치는 원리주의 팀장에게 높은 자신감은 피하기 어려운 것 같다.</p>

<p>높은 자신감은 문제의 원인을 다른 사람에게서 찾게 만들고, 강한 자기 주장을 하게 만들기도 한다. 이런 언행은 관리자와 동료들에게 큰 부담이 되는데, 본인은 그것을 알지 못한다.</p>

<p>마지막으로, 원리주의 팀장에게 이런 말을 전하고 싶다.</p>

<p><code class="language-plaintext highlighter-rouge">하고 싶은 일이 아니라, 해야 할 일을 해라</code></p>

<p>하려는 일이 꼭 필요한 일인지 냉정하게 자신의 생각을 돌아봐야 한다. 원리주의 팀장은 본능적으로 하고 싶은 일을 해야 하는 일이라고 합리화 하는 경향이 있다.</p>

<h2 id="3-실용주의-팀원">3. 실용주의 팀원</h2>

<p>원리주의 팀원은 회사 일을 성장의 기회로 삼으려고 하는 반면에 실용주의 팀원은 회사의 일을 경제 활동으로 받아들인다. 그래서 문제가 있을 때 원리주의 팀원은 과도한 노력을 기울이게 되고 실용주의 팀원은 최소한의 노력으로 문제를 해결하려고 한다.</p>

<p>실용주의 팀원은 다양한 유형이 있다.</p>

<p>첫 번째 유형은 성실하지만 개발에 대한 열정은 낮은 경우다. 이런 유형은 원리주의 팀원이 힘들어 하는 일을 잘 할 수 있기 때문에 개발에 대한 열정이 낮은 것이 단점은 아니다. 개발에 대한 욕심이 적은 만큼 문제를 일으키는 일도 적어서 무난하게 회사 생활을 할 수 있다.</p>

<p>두 번째 유형은 성실하고 개발에 대한 열정도 높은 경우다. 나는 이런 유형의 개발자를 만났을 때 처음에는 이해가 되지 않았다. 개발에 대한 열정이 높다면 원리주의 팀원이 될 것 같은데 유지보수에 대한 고려를 하지 않는다. 해결 방법에 대해서 몇 번 가이드를 해도 결국은 최소 비용으로 문제를 해결한다.</p>

<p>이런 유형의 실용주의 팀원은 개발에 대한 순수한 열정이라기 보다는 일에 대한 열정이 높은 것이고 필요에 의해서 개발에 관심을 갖는 경우인 것 같다. 그러다 보니 더 좋은 회사로 이직하기 위해 도움이 되는 기술을 우선해서 학습하는 경향이 있다. 실용주의 팀원이 디자인 패턴을 공부한다면 그것이 궁금하기 보다는 면접에서 문제로 나올 수 있기 때문이다. 그래서 깊이있게 학습하지는 않는다. 알고리즘도 열심히 학습하는데 코딩 테스트에 필요하기 때문이다. 그런 면에서 원리주의 팀원으로 보기는 어렵다. 원리주의 팀원이 되려면 좀 더 근본을 파고드는 모습이 있어야 한다.</p>

<p>세 번째 유형은 일에 대한 열정이 낮은 경우다. 이런 경우 보통은 회사 업무가 마음에 들지 않아서 동기부여가 되지 않는 원리주의 팀원인 경우가 많다. 혹은 그냥 일 자체에 관심이 없는 경우다.</p>

<p>어느 쪽이든 책임감 있게 일만 제대로 한다면 팀장과 갈등은 크지 않을 것이다. 문제는 일이 하기 싫으니 점점 소홀히 한다는 것이다. 예를 들어 코드를 변경하면 테스트를 꼼꼼히 해야 하는데 테스트는 커녕 빌드만 해서 완료 보고를 하는 경우다. 또는 지시한 일만 수동적으로 수행할 뿐 스스로 일을 찾아서 하지는 않기 때문에 팀장의 관리 비용이 높아진다. 이런 일을 반복하면 다른 사람과의 관계도 안 좋아질 것이다.</p>

<p>어떤 유형이든 실용주의 팀원은 개발자로 성장하기 힘들다. 한 회사에 오래 머물면서 중간 관리자가 되는 것이 보통이다. 그런데 중간 관리자가 되는 것은 쉽지만 차별화되는 장점이 없다면 그 자리를 끝까지 지키는 것은 어려울 수 있다. 관리자가 된 것을 후회하는 경우를 많이 봐온 입장에서 자신이 원하는 방향이 무엇인지 심사숙고 하기를 조언한다.</p>

<p>실용주의 팀원에게 이런 말을 전하고 싶다.</p>

<p><code class="language-plaintext highlighter-rouge">쉽고 편한 길은 없다. 고민하는 만큼 성장한다.</code></p>

<p>실용주의 팀원은 효율을 우선하기 때문에 고민의 기회가 적다. 그러나 인간 관계든 개발이든 고민하는 만큼 성장할 수 있고 성장하는 만큼 차별화를 이룰 수 있다.</p>

<h2 id="4-실용주의-팀장">4. 실용주의 팀장</h2>

<p>많은 개발자들이 실용주의 팀장이 되는데 실용주의 팀원은 물론이고 원리주의 팀장도 실용주의 팀장이 될 수 있다. 실용주의 팀원이 실용주의 팀장이 되는 것은 자연스러운데, 원리주의 팀장이 실용주의 팀장이 되는 것은 무슨 말일까?</p>

<p>원리주의 팀장이 OOP, 디자인 패턴, TDD, DDD, MSA 등 많은 개발 방법론과 아키텍처를 학습하지만 실제 프로젝트에 적용하기는 쉽지 않다. 이런 방법론과 아키텍처는 서로 이어져 있어서 프로젝트에 적용하려면 정말 많은 노력과 경험이 필요하다. 예를 들면 MSA(Microservices Architecture)를 올바르게 적용하려면 현대적인 개발 방법의 근간인 OOP와 디자인 패턴은 물론이고 DDD(Domain-Driven Design)를 잘 알아야 한다. 그런데 현실은 OOP와 디자인 패턴조차 제대로 깨닫지 못하는 경우가 보통이다. TDD(Test-Driven Development)도 OOP/디자인패턴은 기본이고 도메인에 대한 이해를 기반으로 한 유연한 설계가 가능해야 한다.</p>

<p>이 정도 수준에 이르지 못하면 학습했던 개발 방법론을 실제 프로젝트에 적용하는 것은 힘들다. 프로젝트에 적용해 봤으나 결국 문제만 키우는 경험을 몇 번 하고나면 개발 방법론을 현실과 동떨어진 이상론으로 치부하게 된다.</p>

<p>실용주의 팀장의 눈에 원리주의 개발자는 아직 현실을 모르고 그럴듯한 이론에 빠져서 헛된 일을 하는 것으로 보인다. 실용주의 팀장은 주변에서 개발 방법론의 중요성을 외치는 많은 동료들을 봐왔지만 개발 일정만 늦어질 뿐 딱히 품질이 좋아지는 경우를 본 적이 없다. 그래서 원리주의 팀원의 노력을 시간 낭비로 보고 한심하게 여기기도 한다.</p>

<p>실용주의 팀장은 기술에 관심이 적은 만큼 요구사항 분석과 일정 관리에 더 많은 노력을 기울인다. 그 과정에서 자연스럽게 관리자로 전향하게 된다.</p>

<p>나는 실용주의 팀장이 코드 리뷰와 같이 적극적인 기술 리드를 하는 경우를 본 적이 없다. 팀원들에게 모듈 단위로 일을 할당하고 결과를 확인하는 정도가 보통이다. 팀원이 해결하지 못하는 기술적인 문제가 발생하면 직접 해결하기도 하지만 팀원이 늘어가면서 관리자에 좀 더 가까워지는 것 같다.</p>

<p>내 경험에는 실용주의 팀장은 SI 같은 1년 미만으로 진행되는 프로젝트에서 좋은 성과를 낼 수 있다. 그러나 프로젝트가 1년 이상 지속되면 품질 관리가 어려워지고 관리자도 문제가 있는 것을 눈치채기 시작할 것이다.</p>

<p>SI회사 이야기 쓴다.
실용주의 개발을 몇 년 해보고 유지보수가 중요함을 깨달은 경우는 의외로 많지 않다. 대충 만들고 쓰다가 버리고 다시 만든다. 유지보수는 허황된 이야기다.</p>

<h2 id="5-원리주의-관리자">5. 원리주의 관리자</h2>

<p>관리자는 팀 간 조율, 프로젝트 전체 일정 및 리소스 관리, 대외 커뮤니케이션 등 보다 거시적인 업무를 담당하고, 개발에는 직접 참여하지 않는다.</p>

<p>내 경험에는 실용주의보다 원리주의 관리자 비율이 더 높은 편인데, 이는 관리자가 직접 개발을 하지 않기 때문에 쉽게 원리주의적 접근을 선택할 수 있기 때문이다. 이는 관리자가 개발 현장에서 벗어나기 때문에 현실적인 제약보다는 이상적인 접근을 선호하게 되는 경향 때문이다.</p>

<p>원리주의 관리자는 자신의 실력을 과신하여 문제가 발생하는 경우가 많다는 면에서 원리주의 팀장의 업그레이드 버전 정도로 볼 수 있다. 내가 경험한 원리주의 관리자는 크게 두 가지 배경으로 나뉜다. 하나는 오래전에 개발 경력이 있던 관리자이고, 다른 하나는 개발 경력은 없지만 어느 정도 안다고 생각하는 관리자다. 이들의 공통점은 자신이 충분히 안다고 착각하는 것이다.</p>

<p>원리주의 관리자는 다음과 같은 특징을 보인다:</p>

<ol>
  <li>개발 과정에 지나친 개입</li>
  <li>일정이나 기능의 비현실적인 목표 설정</li>
  <li>과도한 혹은 형식적인 문서화 요구</li>
</ol>

<p>앞서 원리주의 팀장의 업그레이드 버전이라고 언급했듯이 원리주의 팀장의 문제점을 고스란히 이어받는다. 차이가 있다면 그 영향력이 더 크다는 것이다.</p>

<p>관리자는 매니저이고 팀장이 리더다. 팀장이 관리자가 되어서는 안 되겠지만, 관리자도 리더가 되려고 하면 안 된다.</p>

<p>리더형 관리자가 좋은 것이 아닌가라고 반문할 수 있다. 관리자가 리더가 되면 팀장의 존재는 희미해지고 관리자가 팀장의 역할을 하게 된다. 팀장은 자신의 역량을 제대로 발휘할 수 없고 관리자도 관리 업무에 집중할 수 없게 된다.</p>

<p>경험상 관리자가 개발을 리드하는 경우, 대부분 불가피한 상황이라기보다는 본인의 희망에 따른 선택인 것 같다. 극단적으로 말하자면, 개발 리드가 관리자의 취미생활처럼 여겨진다. 현명한 관리자라면 팀장을 교체하거나 팀의 업무를 조정할 것이다.</p>

<p>마지막으로, 원리주의 관리자에게 이런 말을 전하고 싶다.</p>

<p><code class="language-plaintext highlighter-rouge">의인불용 용인불의(疑人不用 用人不疑)</code></p>

<p>중국 사서 송사(宋史)에 나오는 말로, 의심 나는 사람은 쓰지 말고 쓴 사람은 의심하지 말라는 뜻이다.</p>

<blockquote>
  <p>보안 관련 회사에서 팀원으로 일했을 때의 일이다.</p>

  <p>회사 서비스의 품질이 지속적으로 하락하자 관리자는 각 팀장에게 설계 문서를 작성하라는 지시를 내렸다. 당시 C++로 작성된 소스 코드는 파일당 50k 라인이 넘을 만큼 복잡하게 얽혀있었다. 설계를 기반으로 구현하는 것이 기본인데, 관리자가 제시한 해결책은 구현을 기반으로 설계 문서를 작성하라는 것이었다.</p>

  <p>결국 개발팀은 약 3주 동안 설계 문서를 작성하다가 중단하고 말았다. 개발팀의 역량 부족으로 품질 관리가 어려웠다면, 관리자가 나설 것이 아니라 역량 있는 개발자를 충원했어야 한다.</p>

  <p>또 다른 경험이다. 특정 정보를 서비스하는 회사에서 팀원으로 일했을 때였다. 이 회사의 개발팀은 8명 내외였고, 대표는 명석한 인물이었으며 개발 팀장은 열정과 실력을 갖춘 존경받는 개발자였다.</p>

  <p>내가 이 회사에서 일하던 당시, 대표는 개발 과정에 적극적으로 개입했지만, 창업 초기였기 때문에 서비스 장애가 발생해도 서로 이해하는 분위기가 있었다.</p>

  <p>몇 년 후 퇴사하고 다시 찾아갔을 때, 개발 조직은 크게 바뀌어 있었다. 기존 개발자들은 독립된 공간에서 각자 명확하지 않은 업무를 하고 있었고, 중요한 업무는 대표가 직접 구성한 새로운 개발팀이 맡고 있었다. 이유를 물어보니, 대표가 품질 문제를 지속적으로 제기하다가 결국 자신이 직접 개발 리드를 선언하고 새로운 팀을 꾸린 것이었다.</p>

  <p>대표가 개발 리드를 하면서 얻은 것은 또 한 번의 큰 시행착오뿐이다. 이 경우에도 대표는 자신의 기준을 만족시킬 수 있는 개발자를 채용했어야 했다.</p>
</blockquote>

<h2 id="6-원리주의-팀장과-실용주의-팀장의-협업">6. 원리주의 팀장과 실용주의 팀장의 협업</h2>

<p>원리주의 팀장과 실용주의 팀장이 원만한 관계를 유지하면서 프로젝트를 진행한다는 이야기를 나는 들어본 적 없다. 둘의 관계는 이념 전쟁의 최전선에서 일촉즉발인 경우가 보통이다.</p>

<p>이 아슬아슬한 상황에서는 중재자의 역할이 중요한데 중재자가 원리주의 관리자라면 거의 대부분 피튀기는 전투가 벌어진다. 원리주의 관리자는 양측의 의견을 듣고 논리적으로 판단할 수 있다고 생각하지만 쉽지 않을 것이다. 더군다나 이런 전투가 매일 벌어지면 원리주의 관리자는 중재에 소극적인 입장이 될 것이다.</p>

<p>이런 상황이 되면 원리주의 팀장이 불리한 입장이 된다. 원리주의 팀장은 자신의 논리를 소프트웨어 개발 이론과 섞어가면서 장황하게 설명해야 한다. 반면에 실용주의 팀장은 원리주의 팀장의 주장에 ‘왜요?’라고 묻기만 하면 된다. 원리주의 팀장이 어지간한 지식이 었어도 실용주의 팀장의 ‘왜요?’ 공격을 방어하기는 쉽지 않다. 어느 순간 설명하기 어려운 지점에 이를 것이다.</p>

<p>원리주의 팀장은 이런 상황이 반복되면서 실용주의 팀장이 자신의 발목을 잡는다고 생각한다. 여기에 개발 지식이 부족한 원리주의 관리자까지 논리적으로 설득해야 하기 때문에 정신적으로 지치기 쉽다.</p>

<p>실용주의 팀장도 원리주의 팀장과 협업이 힘들 수 있다. 예를 들어 원리주의 팀장과 API를 합의했는데도 불구하고 원리주의 팀장이 계속해서 조금씩 변경을 요청할 수 있다. 처음 몇 번은 사소한 변경 요청에 흔쾌이 응할 수 있지만 금방 한계에 이를 것이다. 실용주의 팀장이 보기에는 원리주의 팀장이 디테일에 지나치게 집착하면서 프로젝트 진행의 발목을 잡는 것으로 느껴진다.</p>

<p>결국 둘은 감정적으로 대립하게 되고 프로젝트는 물론이고 개발 조직까지 흔들리게 된다.</p>

<p>이런 둘을 중재할 수 있는 것은 압도적인 경험과 역량을 갖춘 테크 리더 뿐이다. 정확하게는 테크 리더가 개발 팀장을 주도적으로 리드해야 한다. 개발 팀장들이 협의를 한다는 것은 상위 테크 리더가 없기 때문이다.</p>

<p>문제는 일반적인 개발 팀장들이 납득할 수 있는 압도적인 경험과 역량을 갖춘 테크 리더를 찾는 것이 쉽지 않다는 것이다.</p>

<!-- ## 11. 회사의 기술력을 높이기 위해서, 소프트웨어 개발 회사로 살아남기 위해서

충분한 비용을 들여서 제대로 된 개발자를 한 명은 채용해야 한다. 기술을 이해하는 관리자가 있어야 한다. 관리자가 기술을 모르면 팀장들 사이의 논쟁(혹은 분쟁)을 조율하지 못한다. 결국 실용주의 팀장이 남게 된다. 기술을 모르는 관리자라도 논쟁을 통해서 합리적 결론을 내릴 수 있다고 착각하는데 자신의 생각을 모두 논리적으로 설명할 수는 없다. 실용주의는 계속 의문을 제기하고 원리주의는 계속 답을 해야 하는데 그러다 답이 막힌다. 이 과정에서 원리주의는 지치고 감정 싸움이 되거나 퇴사하게 된다.

보안 회사를 두 군데 다녔다. 하나는 많은 문제가 있었고 기술 개발도 안 됐다. 다른 하나는 활기가 넘치고 기술력도 있는 것을 알았다. 거기에 CTO가 스스로 많은 연구를 하고 개발팀을 이끌고 있었다. 또라이 같은 팀장 하나 때문에 나오기는 했지만 종종 생각난다. -->

<h2 id="7-결론">7. 결론</h2>

<p>원리주의자는 생각이 안으로 향한다. 내 생각을 더 깊이 들여다 보고 그 생각을 확장한다. 실용주의는 바깥으로 향한다. 다른 사람의 생각을 들여다 보고 통찰한다.</p>

<!-- ## 7. 중도성향 팀원

팀장의 뜻을 적극 따르는 부류다. -->

<!-- ## 8. 중도성향 팀장

내 얘기 쓰면 된다.
반드시 원리주의에서 중도가 되는 것은 아니다. 처음부터 중도인 경우도 있다. 다만 시행착오가 적기 때문에 성장의 기회도 적다.
회사를 우선 장진석 언급

## 9. 중도성향 관리자

모두주차장 얘기 쓰면 된다.
원리주의에서 시행착오를 겪고 중도가 되는 것이다. 고통 없는 성장은 없다.
실용주의는 처음부터 효율을 추구하기 때문에 시행착오가 적고 고통도 적다. 실용주의가 중도가 되는 경우를 나는 보지 못했다.

개발 경력은 없지만 기본 흐름을 이해한다고 생각하는 관리자가 원리주의 관리자라고 했는데 그럼에도 불구하고 중도성향을 유지하는 경우도 있었다. 술 먹으면 개가 돼서 문제였을 뿐 -->

<p><object data="/uml/6623b76bfb081d35fb3f7f0e558e7de6.svg" type="image/svg+xml" class="plantuml"></object></p>

<!-- ## 3. 이념의 전향

### 3.1 원리주의자에서 실용주의자로

이것 저것 해봤는데 기술적 한계를 극복하지 못하고 결곡 포기하는 경우

### 3.2 실용주의자에서 원리주의자로

오래된 실용주의 개발자인데 OOP를 깨닫고 체계적인 개방 방법을 경험한 후로 원리주의자로 전향한다. 개발에 뜻은 있었으나 기회가 없었던 케이스다

### 3.1 원리주의자에서 중간주의자로

원리주의를 추구하며 노력의 끝에 도달한 경우다.

## 3. 조직 내에서의 입지

한 조직에서 원리주의자의 입지는 어떨까? 또 실용주의자는 어떤 입지를 가지게 될까?

원리주의자는 실용주의자에 비해서 불리한 입장인 경우가 많다. 보통 의문을 제기하는 것은 쉽지만 답하기는 어려운 데 실용주의자는 의문을 제기하는 쪽이고 원리주의자는 답을 해야하는 입장이다. 원리주의자가 논리적으로 답을 하는 것도 어렵지만 정답을 얘기한다고 해도 실용주의는 계속 의미없는 질문을 던져가며 자신의 주장을 굽히지 않을 수 있다.
이 정도 되면 감정적으로 원리주의자가 힘들어진다. 결국 제 3자가 보기에 원리주의자가 문제를 일으키는 것으로 보인다.

상위 직급자가 볼 때 실용주의자의 주장이 더 매력적으로 들린다. 적은 비용으로 간단하게 문제를 해결할 수 있으니까. 물론 어느 정도 경험이 있기 때문에 쉬운 해결책을 계속 고집하는 경우 유지보수가 어려워 진다는 것을 경험적으로 알고는 있다. 그러나 품질 문제는 당장 드러나는 것은 아니다. 반면에 두 개발자의 갈등은 당장 조정해야 하는 시급한 문제다.

이 갈등의 끝은 대체로 원리주의자가 고립감을 느끼고 조직을 이탈하게 된다.

원리주의자의 정치적 어려움
 한 조직에서 두 이념이 갈등할 때 프로젝트는 어떻게 진행될까?

실제 조직 내에서는 실용주의자들이 더 명확하게 살아남는 경향이 있는 경우가 많습니다. 이는 특히 단기적인 성과가 강조되는 경영 환경에서 두드러집니다. 관리자와 경영진은 대체로 당장의 결과와 가시적인 성과를 선호하며, 이는 실용주의적 접근이 잘 맞아떨어지는 상황입니다.

### 실용주의자의 강점과 조직 내에서의 우위

1. **즉시적인 결과물 제공:**
   실용주의자는 '지금 당장 작동하는' 솔루션을 제공하는 데 초점을 맞춥니다. 관리자나 이해관계자는 프로젝트가 빠르게 진행되는 것을 보고 싶어하며, 실용주의자들이 제공하는 신속한 해결책은 이러한 요구에 잘 부합합니다.

2. **유연성과 적응성:**
   시장의 변화에 빠르게 대응하고, 사용자의 요구에 신속하게 반응하는 것은 현대 비즈니스 환경에서 큰 장점입니다. 실용주의자들은 이러한 변화에 유연하게 대응하며, 이는 불확실한 경제 상황이나 경쟁이 치열한 시장에서 특히 중요합니다.

3. **직관적이고 실질적인 커뮤니케이션:**
   실용주의자는 복잡한 이론이나 모델을 사용하기보다는 직관적이고 실질적인 언어를 사용하여 아이디어를 전달합니다. 이는 비전문가나 다른 부서와의 소통에서 상당히 유리하며, 이해관계자들에게 쉽게 접근할 수 있게 해줍니다.

4. **위기 상황에서의 효과적 대응:**
   문제가 발생했을 때 즉각적으로 대응하는 실용주의자의 태도는 위기 상황에서 매우 유용합니다. 버그 수정, 사용자 피드백 반영, 또는 경쟁 제품에 대한 빠른 대응 등은 실용주의적 접근으로 더 잘 해결될 수 있습니다.

### 원리주의자의 답답함과 조직 내에서의 도전

1. **장기적인 비전 vs. 단기적 성과:**
   원리주의자는 장기적인 관점에서 안정성과 확장성을 고려하여 개발을 추진합니다. 하지만 많은 조직에서는 단기적인 성과가 더 중요시되며, 이러한 차이는 원리주의자에게 많은 답답함을 주고, 그들의 접근 방식이 간과되는 원인이 됩니다.

2. **이론과 실제의 간극:**
   원리주의자는 종종 소프트웨어 개발 이론과 모범 사례를 중시하지만, 실제 비즈니스 상황에서는 이러한 이론이 완벽하게 적용되기 어려울 수 있습니다. 이는 그들이 제안하는 솔루션을 설득하는 데 추가적인 어려움을 초래합니다.

3. **커뮤니케이션의 어려움:**
   원리주의자는 때때로 자신의 접근 방식을 설명할 때 너무 기술적이거나 이론적인 언어를 사용할 수 있습니다. 이는 비기술적인 관리자나 이해관계자와의 커뮤니케이션에서 장벽이 될 수 있으며, 그들의 아이디어가 충분히 평가받지 못하는 결과를 낳을 수 있습니다.

4. **변화에 대한 저항:**
   원리주의자는 변경을 신중하게 접근하며 때로는 새로운 요구사항이나 기술적 변화에 저항할 수 있습니다. 이는 특히 변화와 혁신을 추구하는 조직 문화에서 그들이 소외될 수 있는 요인입니다.

### 조직 내에서의 원리주의자와 실용주의자의 조화

결국 조직에서는 각기 다른 접근 방식이 필요한 다양한 상황이 존재합니다. 원리주의자와 실용주의자 모두의 접근 방식을 적절히 조화롭게 사용하는 것이 이상적입니다.

* **원리주의자는 실용주의자와의 협력을 통해** 자신의 장기적인 관점을 현실적인 프로젝트 목표에 맞추어 조정할 수 있습니다.
* **실용주의자는 원리주의자와의 대화를 통해** 자신의 단기적인 해결책이 장기적인 문제를 야기하지 않도록 보완할 수 있습니다.

이렇게 서로의 장점을 인정하고 통합하는 방식으로 일한다면, 원리주의자와 실용주의자 모두 조직 내에서 중요한 역할을 하며 살아남을 수 있습니다. 결국, 조직의 성공은 다양한 접근 방식을 포용하고, 각각의 강점을 최대한 활용하는 데에서 비롯됩니다.

## 결론

결국 길은 한 곳에서 만난다고 하지만
한 가지 중요한 점은 여기서 얘기하는 원리주의자와 실용주의자의 개발 실력이 평범한 경우의 이야기다.
그러니까 서로 다른 이념을 갖고 개발자로 한참 성장해야 하는 경우를 다루는 것이다.

개발 실력이 출중하고 경험이 많으면 어떤 이념이라고 하든 개인 성향으로 치부할 수 있다. 그리고 그런 개발자는 적절한 지점을 요령있게 간파할 것이다. -->

<!-- 실용주의 개발을 몇 년 해보고 유지보수가 중요함을 깨달은 경우다. 그러나 회사에 개발 방법론을 제대로 이해한 개발자가 없는 상황에서 어떻게든 품질을 끌어올리기 위해서 노력을 한다. 대표적으로 문서화를 강하게 주장한다.
아니면 개발 기술에 관심이 있는 엔지니어 성향의 관리자라면 처음부터 원리주의 관리자가 될 수도 있다.

대체로 원리주의 팀장의 업그레이드 버전이다.

자신을 과신하고 개발자를 불신하는 경우도 있었다. -->]]></content><author><name>mannercode</name><email>hello@mannercode.com</email></author><summary type="html"><![CDATA[과거 냉전 시대의 공산주의와 자유주의 만큼이나 양립할 수 없는 두 이념이 소프트웨어 개발에 존재한다. 원리주의와 실용주의가 그것이다. 소프트웨어 개발은 매우 복잡한 과정이며, 이 두 가지 이념은 각각 다른 방식으로 문제를 해결하려고 한다. 그렇기 때문에 이 두 이념은 소프트웨어 개발의 성공과 실패에 큰 영향을 미칠 수 있다.]]></summary></entry></feed>