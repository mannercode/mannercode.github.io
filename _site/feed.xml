<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-04T06:41:29+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Manner Code</title><subtitle>리팩토링, 디자인패턴, OOP, TDD, DDD, 아키텍처 같은 프로그래밍의 기본을 다룹니다.
</subtitle><author><name>mannercode</name><email>hello@mannercode.com</email></author><entry><title type="html">본질 기반 해석(Essence-Based Interpretation, EBI)</title><link href="http://localhost:4000/2024/05/03/ebi.html" rel="alternate" type="text/html" title="본질 기반 해석(Essence-Based Interpretation, EBI)" /><published>2024-05-03T00:00:00+00:00</published><updated>2024-05-03T00:00:00+00:00</updated><id>http://localhost:4000/2024/05/03/ebi</id><content type="html" xml:base="http://localhost:4000/2024/05/03/ebi.html"><![CDATA[<h2 id="1-소개">1. 소개</h2>

<p>개발자라면 리팩토링과 디자인패턴을 공부하고 실제 프로젝트에 적용하려고 할 때 고민스러웠던 경험이 있을 것이다. 이 상황에서 어떤 패턴을 적용해야 할까? 어떤 구조가 옳은가? 사소하지만 그렇다고 그냥 넘어가기에는 이유가 명확하지 않은 그런 꺼림직한 경험들 말이다.</p>

<p>이런 문제들은 명확한 이유를 설명하지 못하고 정답이라는 것이 있을 것 같지도 않기 때문에 개인의 성향이나 스타일로 치부하게 된다.</p>

<p>그런데 그게 최선일까? 이런 문제들의 해답이 정말 개인의 스타일에 좌우되어야 하는 걸까? 이것은 좋은 코드에 대해서 오랜시간 고민하면서 끊임없이 나를 괴롭히던 질문이었다. 디자인 패턴과 아키텍처, 개발 방법론에 두루 노력해도 이것은 쉽지 않은 문제였다. 그렇게 고민을 안고 여러 종류의 소프트웨어를 개발하다가 문득 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>에 대해서 깨닫게 됐는데 도메인 주도 개발(DDD)의 도움이 컸다.</p>

<p><code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>은 도메인 주도 개발(DDD)과 비슷한 맥락을 가진다. 차이점이라면 DDD는 도메인에 기반한 체계적인 설계 방법론이다. 반면에 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>은 개발 과정에서 마주하는 선택의 순간마다 본질에 입각해 사고하고 판단해야 하는, 개발자가 견지해야 하는 일종의 원칙이다.</p>

<p><code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>는 내가 만든 용어인데 왜 기존에 이런 개념을 정의하는 용어가 없었는지 의아하다. 너무 당연한 개념이라서 이름까지 붙일 필요가 없었다고 하기에는 많은 개발자들이 쉽게 간과하는 것 같다.</p>

<p><code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>은 구체적인 방법론은 아니고 추상적인 개념에 가깝기 때문에 명료한 문장으로 설명하기가 어렵다. 그래서 몇 가지 사례를 통해서 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>이 무엇인지 설명하고자 한다.</p>

<h2 id="2-방향키의-구현">2. 방향키의 구현</h2>

<p>사용자에게 ‘상/하/좌/우’를 선택할 수 있는 방향키를 제공해야 한다. 4개 화살표의 모양은 동일하고 방향만 다르다. 이 때 4개의 화살표를 구현하는 방법이 두 가지 있다.</p>

<h3 id="21-방법1---한-개의-이미지를-회전시켜서-재사용">2.1. 방법#1 - 한 개의 이미지를 회전시켜서 재사용</h3>

<p><code class="language-plaintext highlighter-rouge">방법#1</code>은 한 개의 화살표 이미지(arrow.png)를 회전시켜서 구현하는 것이다. 위에서 화살표의 모양은 동일하다고 했기 때문에 구현에 문제는 없다.</p>

<p>이 방법은 저장 공간을 적게 차지하는 장점과 코드 가독성이 상대적으로 떨어진다는 단점이 있다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"180"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"-90"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"arrow.png"</span> <span class="na">rotate=</span><span class="s">"90"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p><img src="/assets/images/arrows1.svg" alt="방향키1" /> <br />
<em>[그림 2-1] 한 개의 이미지를 회전시켜서 구성된 방향키</em></p>

<h3 id="22-방법2---4개의-이미지를-사용">2.2. 방법#2 - 4개의 이미지를 사용</h3>

<p><code class="language-plaintext highlighter-rouge">방법#2</code>는 상/하/좌/우에 해당하는 4개의 이미지를 사용하는 것이다.</p>

<p>이 방법은 방향만 다른 화살표 이미지를 관리하는 것이 번거로울 수 있고 공간도 더 많이 차지한다는 단점이 있다. 반면 코드의 가독성은 비교적 좋다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"up.png"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"down.png"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"let.png"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;View</span> <span class="na">src=</span><span class="s">"right.png"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p><img src="/assets/images/arrows2.svg" alt="방향키2" /> <br />
<em>[그림 2-2] 상/하/좌/우 4개의 이미지로 구성된 방향키</em></p>

<h3 id="23-옳은-방법은-무엇일까">2.3. 옳은 방법은 무엇일까?</h3>

<p>무엇이 옳은 것일까? 혹은 이 선택에 있어서 옳고 그름이 존재하긴 하는 걸까? 그저 개인의 철학에 따른 선택만이 있는 것은 아닐까?</p>

<p>읽기 쉬운 코드를 추구한다면 <code class="language-plaintext highlighter-rouge">방법#1</code>이지만 효율성을 추구한다면 <code class="language-plaintext highlighter-rouge">방법#2</code>일 것이다.</p>

<p>읽기 쉬운 코드가 옳은가? 성능 효율적인 코드가 옳은가? 대체로 과거에는 성능 효율을 우선했겠지만 요즘처럼 하드웨어의 성능이 충분한 경우에는 읽기 쉬운 코드를 선호한다. 그런 이유로 읽기 쉬운 코드를 선택해야 할까?</p>

<p>아마도 많은 개발자들이 화살표의 모양이 같다는 것에 주목해서 <code class="language-plaintext highlighter-rouge">방법#1</code>처럼 이미지를 회전 시켜서 효율을 추구하는 방법을 선택했을 것이다.</p>

<p>다양한 생각들이 있겠지만 우선적으로 고려해야 하는 것은 화살표의 의미다.</p>

<p>만약 화살표가 <em>[그림 2-3]</em> 처럼 특정한 물체를 가리키는 용도라면 <code class="language-plaintext highlighter-rouge">방법#1</code>처럼 화살표를 회전시켜서 구현하는 것이 맞다.</p>

<p><img src="/assets/images/arrows3.svg" alt="방향키3" /> <br />
<em>[그림 2-3] 무언가를 가리키는 용도의 화살표</em></p>

<p>그러나 사용자가 생각한 방향키는 <em>[그림 2-4]</em> 와 같이 키보드 구석에 고정되어 있는 4개의 방향키였을 것이다. 그리고 그런 사용자의 생각과 유사한 것은 <code class="language-plaintext highlighter-rouge">방법#2</code>와 같이 4개의 이미지를 사용하는 것이다.</p>

<p><img src="/assets/images/arrows4.svg" alt="방향키4" /> <br />
<em>[그림 2-4] 서로 다른 모양의 화살표를 가지는 방향키</em></p>

<p>사용자에게 보여지는 결과물은 같기 때문에 어떤 방법을 선택해도 큰 차이는 없다고 생각할지도 모르겠다. 사용자의 생각을 무시한 채 단순히 구현 편의성만을 추구하면 어떻게 될까?</p>

<p>사용자는 언제든지 화살표의 모양을 쉽게 변경할 수 있다고 생각한다. 왜냐하면 사용자는 당연히 4개의 이미지로 구성된 방향키라고 생각하기 때문이다. 이미지를 회전시켜서 성능을 최적화 하는 것은 지극히 개발자의 입장일 뿐이다. 그리고 어느날 사용자는 방향키의 모양을 <em>[그림 2-4]</em> 처럼 변경해 달라고 쉽게 요구할 수 있다. 키의 이미지를 변경하기만 하면 되니까 쉬운 작업이라고 생각할 것이다. 그러나 개발자는 구현 방법을 바꿔야 하는 큰 일이 된다.</p>

<p>화살표의 모양이 동일한 것은 그저 우연일 뿐이다. 이런 우연으로 생긴 상황을 구현에 반영하면 사용자의 생각과 멀어지게 된다. 다시 얘기하자면 사용자의 의도를 무시한 채 구현 편의성만을 추구하면 유지보수가 점점 더 어려워 지게 된다.</p>

<h3 id="24-해석의-어려움">2.4. 해석의 어려움</h3>

<p>여러 방법을 두고 고민하게 되는 이유 중에 하나는 당연한 정보는 누락하기 때문이다.</p>

<p>사용자가 방향키를 요구사항으로 언급했을 때는 키보드의 그 방향키라고 구체적으로 설명하지는 않았을 것이다. 사용자의 입장에서는 방향키라고 하면 당연히 키보드의 그것이라고 생각하기 때문이다.</p>

<p>그러나 개발자 입장에서는 방향키에 대한 추가 정보가 없기 때문에 구현 방법을 선택하는 데 있어서 조금 더 고민하게 되는 것이다.</p>

<p>이것이 해석의 어려운 부분인데 당연하다고 여겨 구체적 정의를 생략한 부분은, 개발 단계에서 개발자가 스스로 채워넣어야 한다. 그리고 개발자가 누락된 부분을 채우려면 요구사항이 그렇게 정의된 이유와 과정까지 모두 고려해야 하기 때문에 많은 경험과 통찰력이 필요하다.</p>

<p>만약 지금 상황에서 사용자의 의도를 정확히 파악할 수 없다면 어떻게 해야 할까? 혹은 어떻게 변경될지 예측할 수 없다면 어떻게 해야 할까?</p>

<p><code class="language-plaintext highlighter-rouge">&lt;Up /&gt;&lt;Down /&gt;&lt;Left /&gt;&lt;Right /&gt;</code> 클래스로 정의해서 화살표의 요구사항이 어떻게 변경 되더라도 다른 곳에 영향이 없도록 하는 것이다.</p>

<blockquote>
  <p>쇼핑몰을 운영하는 회사에서 일할 때의 일이다. 회의 내용은 ‘쿠폰’을 어떻게 구현할 것인가에 대한 논의였다.</p>

  <p>당시 개발팀은 결제 금액을 ‘원’이라는 화폐 단위로만 다루고 있었다. DB에 저장된 금액 단위는 모두 ‘원’이었고, 코드에서 다루는 금액 단위 역시 ‘원’이었다. 사용자 관점에서의 ‘결제금액’이라는 개념은 고려되지 않은 채로 말이다.</p>

  <p>이러한 상황에서 ‘포인트’ 개념을 도입하게 되었다. 다행히 당시에는 1point가 1원이라는 단순한 구조였기에 큰 문제없이 DB에 point 컬럼을 추가하는 것으로 대응할 수 있었다.</p>

  <p>하지만 서비스가 확장되며 할인쿠폰, 등급별 혜택 등의 기능이 추가되면서 사용자가 인지하는 ‘결제금액’은 단순히 원으로 표현될 수 없는 복잡한 개념이 되어갔다. 기존의 ‘원’ 중심 구현방식으로는 사용자의 결제 flow를 온전히 반영할 수 없게 된 것이다.</p>

  <p>만약 프로젝트 초기에 ‘결제금액’의 의미를 좀 더 깊이 생각했다면 이후의 많은 변경사항에 매끄럽게 대처할 수 있었을 것이다.</p>

  <p>물론, 이것은 쉽지 않은 일이기는 하다. 기본적으로 객체 지향 프로그래밍에 능숙해야 하는데 이것 부터가 쉽지 않다. 그리고 결제 기능이 언제 어떻게 변경될지 알 수 없기 때문에 아무리 실력있는 개발자라 하더라도 처음부터 ‘결제금액’을 객체로 만드는 것은 어려울 것이다.</p>

  <p>그러나 이런 어려움에도 불구하고 경험과 실력을 갖춘 개발자라면 새로운 개념을 발견했을 때 적절한 리팩토링을 반복하면서 꾸준히 위기를 관리하고 본질에 다가가게 된다. 여기서 적절한 리팩토링이라는 것은 기술 부채를 쌓지 않고 그렇다고 오버 엔지니어링도 아닌 비용 효율적인 접근을 뜻한다.</p>

  <p>그리고 방향키의 사례에서 봤던 것처럼 요구사항 이면의 본질을 파악하는 습관을 기른다면 본질에 다가가는 과정을 더 단축할 수 있게 된다.</p>
</blockquote>

<h2 id="3-rest-api-디자인">3. REST API 디자인</h2>

<p>REST API의 라우팅 디자인은 크게 <code class="language-plaintext highlighter-rouge">Shallow Routing</code>과 <code class="language-plaintext highlighter-rouge">Nested Routing</code>이 있다. 어느 쪽이 더 좋은 선택일까?</p>

<p>[그림 3-1]은 사용자가 영화 예매 서비스에서 상영 중인 영화/극장/시간을 선택하는 시퀀스 다이어그램이다. 여기에서 REST API의 라우팅을 어떻게 디자인 해야 할까?</p>

<p><object data="/uml/9eca4c0ba637d46c74f35ee2c77ca2cf.svg" type="image/svg+xml" class="plantuml"></object></p>

<p><em>[그림 3-1]</em></p>

<h3 id="31-shallow-routing">3.1. Shallow Routing</h3>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code> 형식으로 디자인 한다면 아래와 비슷한 형태가 될 것이다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 상영 영화 목록 요청</span>
/movies?status<span class="o">=</span>showing

<span class="c"># 상영 극장 목록 요청</span>
/theaters?movieId<span class="o">={</span>movidId<span class="o">}</span>

<span class="c"># 상영일 목록 요청</span>
/showdates?movieId<span class="o">={</span>movieId<span class="o">}</span>&amp;theaterId<span class="o">={</span>theaterId<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code>은 각 리소스를 독립적으로 관리할 수 있으므로 확장성이 좋다. 그러나 리소스 간의 관계를 명확하게 표현하지 않기 때문에 복잡한 계층 구조의 데이터를 표현하는데 어려움이 있다.</p>

<h3 id="32-nested-routing">3.2. Nested Routing</h3>

<p><code class="language-plaintext highlighter-rouge">Nested Routing</code> 형식으로 디자인 한다면 아래와 비슷한 형태가 될 것이다.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 상영 영화 목록 요청</span>
/showing/movies

<span class="c"># 상영 극장 목록 요청</span>
/showing/movies/<span class="o">{</span>movieId<span class="o">}</span>/theaters

<span class="c"># 상영일 목록 요청</span>
/showing/movies/<span class="o">{</span>movieId<span class="o">}</span>/theaters/<span class="o">{</span>theaterId<span class="o">}</span>/showdates
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Nested Routing</code>은 리소스 간의 관계를 URL에서 명확하게 표현할 수 있으므로, 복잡한 리소스 구조를 표현하는데 적합하다. 그러나 중첩된 리소스 구조가 변경될 경우, URL도 함께 변경되어야 하므로 유연성이 제한된다.</p>

<h3 id="33-옳은-방법은-무엇일까">3.3. 옳은 방법은 무엇일까?</h3>

<p>두 기술의 장단점을 간단하게 살펴봤다. 그렇다면 유연성과 명확함 사이에서 어떤 방법을 선택해야 할까?</p>

<p>두 방식 중에서 무엇을 선택할 것인지는 개념적인 관점에서 영화 예매 프로세스를 더 잘 표현하는 것이 무엇인지를 봐야 한다.</p>

<p>그런 면에서 <code class="language-plaintext highlighter-rouge">Nested Routing</code>은 티켓 구매 프로세스를 그대로 반영하고 있다.
티켓 구매 프로세스가 영화 선택 후 극장을 선택해야 하듯이, <code class="language-plaintext highlighter-rouge">Nested Routing</code>도 영화를 지정하지 않으면 극장을 지정할 수 없다.
즉, <code class="language-plaintext highlighter-rouge">Nested Routing</code>의 REST API가 티켓 구매 프로세스와 유사한 구조를 표현하고 있다.
이 정도면 별도의 문서로 정리하지 않아도 티켓 구매 프로세스를 알 수 있을 것이다.</p>

<p>Shallow Routing과 Nested Routing 중에서 무엇이 좋은가에 대한 논쟁을 종종 보게된다.
그러나 그런 논쟁은 무의미 하다. 중요한 것은 요구사항을 보다 정확히 반영하는 것이 무엇이냐인 것이다.
기술적 관점에서 보면 답이 없는 문제를 가지고 논쟁을 하니 논쟁이 끝나지 않는 것이다.</p>

<blockquote>
  <p>한참 고민해도 답이 보이지 않는다면 답이 거기에 없는 것이다.</p>
</blockquote>

<h3 id="34-상속과-포함composition">3.4. 상속과 포함(Composition)</h3>

<p><code class="language-plaintext highlighter-rouge">Shallow Routing</code>과 <code class="language-plaintext highlighter-rouge">Nested Routing</code>의 논쟁과 유사한 다른 논쟁으로 클래스의 상속과 포함(Composition)이 있다.</p>

<p>유연성이 주는 장점 때문에 <code class="language-plaintext highlighter-rouge">Shallow Routing</code>이 기술적으로 우월하다는 대체적인 공감대와 마찬가지로 클래스도 가능하면 상속을 피하고 포함을 사용하는 것이 좋은 재사용 방법이라고 한다. 그러나 이것도 마찬가지로 도메인 개념을 더 잘 표현하는 것이 무엇인지를 고민해야 하는 것이지 기술적 우월성을 우선해서 고려하면 안 된다.</p>

<p><object data="/uml/9f603402d37bffc94cd71f3d9fe52b9d.svg" type="image/svg+xml" class="plantuml"></object></p>

<p>위의 다이어그램에서 Dog는 Animal의 한 종류다. 이것은 상속으로 표현하는 것이 자연스럽다. 반면에 Engine은 Car를 구성하는 부품 중 하나이다. 이것은 포함으로 표현하는 것이 자연스럽다.</p>

<h2 id="4-문서의-통합-vs-분리">4. 문서의 통합 vs 분리</h2>

<p>외교부의 아포스티유/영사확인 문서 프로젝트를 진행할 때의 일이다.</p>

<p>소득증명서와 같은 국내에서 발행되는 문서의 국외 사용을 위한 인증 방식이 두 가지 있는데 그것이 ‘아포스티유’와 ‘영사확인’이다.
영사확인이 일반적인 절차이고 아포스티유는 협약에 따라 영사확인 절차를 보다 보다 간소화 한 것이다.</p>

<p>프로젝트의 목표는 이 두 문서를 암호화 하고 변조 여부를 확인할 수 있는 시스템을 구축하는 것이었다.</p>

<p>아포스티유와 영사확인 문서는 항목이나 구조가 유사했기 때문에 기존에 구축된 서비스도 하나의 테이블을 공유하고 있었다.</p>

<p><object data="/uml/05725b13c788685ea2729a3ba231029d.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="41-초기-설계">4.1. 초기 설계</h3>

<p>기존 시스템을 분석하는 과정에서 나는 영사확인과 아포스티유가 비슷해 보이는 것은 우연일 뿐이며 동일한 문서로 취급하면 안 될 것처럼 보였다. 만약 같은 문서라면 프로젝트 이름이 ‘아포스티유 &amp; 영사확인’은 아니었을 것이다.</p>

<p>그에 반해서 back-end 담당자는 두 개로 분리할 필요가 없다는 주장을 하고 있었다.
결국 타협점으로 REST API만 두 개로 분리하고 테이블 등은 하나로 구현하기로 했다.</p>

<p><object data="/uml/ec5e5e2347907e077d1b58976807c9cf.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="42-설계-변경">4.2. 설계 변경</h3>

<p>그런데 프로젝트가 진행되면서 두 문서의 차이가 구체화 되기 시작했다.
아포스티유와 영사확인의 문서번호가 중복될 수 있어서 문서번호 체계가 달라졌다.
그리고 서비스 기능이 확장 되면서 두 문서의 인터페이스는 점점 달라졌다.</p>

<p>결국 테이블을 둘로 나누고 내부 구조도 분리하기로 결정했다.
다행스럽게도 외부에 노출되는 API는 두 개로 분리되어 있었기 때문에 내부 구조를 변경하는 것은 비교적 수월했다.
만약 분리하는 것이 부담스러워서 리팩토링을 피하려고 했다면 코드 곳곳에 if-else가 넘쳐나고 지옥으로 가는 문이 열렸을 것이다.</p>

<p><object data="/uml/92b9f1fa32a97ec298a8c11ad6c7b8fc.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="43-이런-일이-발생한-이유">4.3. 이런 일이 발생한 이유</h3>

<p>이 사례에서 두 문서의 형식이 같았던 것은 그저 우연일 뿐이었다. 사용자의 요구에 따라서 얼마든지 달라질 가능성이 있었다. 애초에 다른 문서이기 때문에 다른 이름이 붙은 것이라는 사실을 간과한 것이 문제였다.</p>

<p>프로그래머는 종종 구현 편의성을 우선하는 경향이 있다. 그 습관을 버리기가 쉽지 않을 것이다. 그러나 철저하게 도메인의 개념을 따라야 한다.</p>

<h2 id="5-db-저장-방법">5. DB 저장 방법</h2>

<p>사용자가 웹 브라우저로 <code class="language-plaintext highlighter-rouge">[file].txt</code> 파일을 업로드 하려고 한다.</p>

<p>사용자가 업로드 하는 파일명이 한글이라서 URL encoding을 해서 서버에 전송해야 한다. 마찬가지로 사용자가 파일을 다운로드 받으려면 파일명을 URL encoding 해야 한다.</p>

<p>그렇다면 서버는 DB에 인코딩된 문자열(<code class="language-plaintext highlighter-rouge">%5Bfile%5D.txt</code>)을 그대로 저장하는 것이 좋을까? 아니면 이것을 다시 디코딩해서 <code class="language-plaintext highlighter-rouge">[file].txt</code>로 저장하는 것이 좋을까?</p>

<p><code class="language-plaintext highlighter-rouge">[file].txt</code>로 저장하면 사용자에게 파일을 전송할 때 다시 인코딩 해야 한다. 그렇다면 그냥 받은 그대로 <code class="language-plaintext highlighter-rouge">%5Bfile%5D.txt</code>으로 저장하는 것이 효율적이지 않을까?</p>

<p>이것도 역시 답을 알기 위해서 사용자의 생각을 살펴봐야 한다.</p>

<p>사용자가 업로드 한 파일명은 <code class="language-plaintext highlighter-rouge">[file].txt</code>이다. 사용자는 이것이 어떻게 변환되는지 모른다. 그러니까 저장할 때도 사용자의 생각에 맞춰서 <code class="language-plaintext highlighter-rouge">[file].txt</code>으로 저장하는 것이 옳다.</p>

<p>애초에 URL Encoding을 하는 이유는 ASCII 문자 집합의 일부만 전송 가능하다는 기술적 한계 때문이지 사용자의 요구사항과는 전혀 관련이 없다. 특정 기술의 한계 혹은 특성이 다른 영역에 영향을 주는 것은 좋은 구조가 아니다. 그러니까 HTML의 전송 과정에서 발생하는 기술적인 문제는 그 과정에서 해결해야 하는 것이지 그것을 DB까지 가져오면 두 개의 큰 영역이 서로 강하게 결합되는 안티-패턴이 된다.</p>

<p>사용자의 의도를 더 정확하게 반영하는 것이 우선이고 최적화는 그 다음이다.</p>

<p>다운로드 기능만을 고려한다면 받은 그대로 저장하는 것이 최선의 선택일 것이다. 그러나 기능이 확장되면서 파일 목록을 보여주거나 검색을 허용할 때는 원본 문자열(<code class="language-plaintext highlighter-rouge">[file].txt</code>)이 필요할 것이다. 왜냐하면 사용자는 파일명을 <code class="language-plaintext highlighter-rouge">[file].txt</code>으로 생각하기 때문이다. 그런데 저장을 <code class="language-plaintext highlighter-rouge">%5Bfile%5D.txt</code>으로 한다면 조회나 검색 기능을 구현할 때 얼마나 번거로울지 생각해 보라.</p>

<p>구현 편의성을 추구하면 이렇게 작은 변화에도 쉽게 흔들리게 되는 것이다.</p>

<!-- markdownlint-disable MD034 -->
<p><object data="/uml/543ff9861916ccb443624522babac381.svg" type="image/svg+xml" class="plantuml"></object></p>

<h2 id="6-영화-예매-서비스의-장바구니-기능">6. 영화 예매 서비스의 장바구니 기능</h2>

<p>보다 논리적인 레벨에서도 선택의 고민은 계속된다. 영화 예매 서비스를 개발한다고 할 때 여기에 장바구니 기능을 구현해야 할까? 전자상거래 서비스에서는 장바구니가 필수적인 기능이지만, 영화 예매 서비스에서도 꼭 필요할까?</p>

<p>이 질문에 답하기 위해서는 실제 영화 예매 프로세스에서의 사용자 경험을 생각해 봐야 한다. 일반적으로 사용자가 영화를 예매할 때는 다음과 같은 순서로 진행된다.</p>

<ol>
  <li>영화 선택</li>
  <li>상영 시간 선택</li>
  <li>좌석 선택</li>
  <li>결제</li>
</ol>

<p>이 과정에서 우리는 “장바구니에 담기”와 같은 중간 단계를 발견할 수 없다. 사용자는 영화, 시간, 좌석을 선택하고 바로 결제를 진행한다.</p>

<p>그렇다면 온라인 영화 예매 서비스에 장바구니 기능을 추가하는 것은 사용자의 실제 경험과는 거리가 먼 결정이 될 수 있다. 오히려 불필요한 복잡성을 야기하고, 온라인과 오프라인에서의 경험 간 일관성을 해칠 수 있다.</p>

<p>물론 “나중에 결제하기 위해 선택한 영화를 저장해 두는 기능이 있으면 좋겠다”라는 사용자 요구사항이 있을 수 있다. 하지만 이 경우에도 “장바구니”라는 개념을 그대로 가져오기보다는, 영화 예매 서비스의 맥락에 맞는 개념으로 재해석할 필요가 있다. 예를 들어, “관심 영화 저장” 또는 “예매 내역 저장” 등의 기능으로 제공하는 것이 더 적절할 수 있다.</p>

<h2 id="7-프로젝트-이름">7. 프로젝트 이름</h2>

<p>백엔드에 대한 기본적인 지식을 전달하기 위한 프로젝트로 영화 예매 서비스 개발을 시작하려고 한다. 프로젝트의 이름을 무엇이라고 해야 할까? 영화 예매니까 ticket-service이라고 하면 어떨까?</p>

<p>우리가 만들려고 하는 것은 ticket-service가 맞다. 그러나 왜 만들려고 하는가를 생각해 보면 backend-fundamentals이 더 좋은 선택이다. ticket-service는 백엔드의 기본적인 지식을 전달하기 위한 수단에 불과하다. 수단은 언제든지 변경될 수 있다.</p>

<p>이 경우처럼 코드가 아니어도 선택의 순간에는 <code class="language-plaintext highlighter-rouge">본질 기반 해석(EBI)</code>가 필요하다. 나의 경우 매 순간 습관처럼 내가 인지한 정보의 본질이 무엇인지를 고민한다.</p>

<h2 id="결론">결론</h2>

<!-- 결과적으로 `본질 기반 해석(EBI)`는 현실의 개념과 구현을 일치시키려는 노력이다. 다만, 현실에서 피상적으로 드러난 특징이 아니라 숨겨진 본질을 통찰해야 한다는 것을 강조하는 것이다.
현실에서 개념은 현재를 기반으로 확장/발전한다. 따라서 구현도 현실과 최대한 유사한 구조를 가져야 확장/발전이 수월하다.

몇 개의 사례를 늘어놨지만 `본질 기반 해석(EBI)`는 거의 매 순간 필요하다.

개발을 하면서 몇 번의 뇌 구조가 바뀌게 되는데 그 중 한 번은 OOP를 깨달았을 때다. `본질 기반 해석(EBI)`는 그 다음 뇌구조가 바뀌는 순간이다.

결론입니다.

`본질 기반 해석(EBI)`이 DDD와 비슷하다고 생각하실지 모르겠습니다.
DDD는 복잡한 도메인 로직을 다른 부분과 분리하는 것이고 설계 단계의 이야기입니다.
`본질 기반 해석(EBI)`은 요구사항 분석과 설계에서 당연하게 누락된 생각을 채우는 것으로 구현 단계의 이야기입니다.

분석 단계에서 사용자의 모든 생각을 문서로 정리할 수 없다.
설계도 마찬가지인데 설계 단계에서 설계자의 모든 생각을 정리할 수 없다.
모든 요구사항과 설계를 정리한 것이 코드이기 때문이다.

어느 정도 빈틈이 있을 수 밖에 없고 그 빈틈은 굳이 말하지 않아도 알 것이라고 생각하는 것들이다.
문제는 당연히 알 것이라고 생각하는 것 중에서 당연하지 않은 것이 있기 때문이다.
다시 말하자면 사용자가 당연하게 생각하는 것들을 개발자는 전혀 다르게 받아들일 수 있다.

이런 사용자와 개발자의 생각의 오차를 줄이려는 노력이 `본질 기반 해석(EBI)`이다.
개발은 요구사항 분석을 바탕으로 설계하고 구현해야 한다.
잘못된 분석을 기반으로 구현을 하면 얼마 안 가서 문제가 드러난다.
그러나 잘못된 해석을 기반으로 구현을 해도 당장 문제가 되지는 않는다.
문제가 되지 않는게 문제인데 프로젝트가 한참 진행된 후에 잘못을 인지하고 수정하려면 많은 노력이 필요하기 때문이다.

`본질 기반 해석(EBI)`에 대해서 간단하게 설명했지만 중요한 개념이다.
보통 소프트웨어 공학 관련 서적이나 자료들은 분석,설계,구현,검증 각각의 단계에 집중해서 설명을 하다보니
요구사항 분석과 구현을 일치시키려는 `본질 기반 해석(EBI)`에 대해서는 그 개념과 존재가 분명하게 다뤄지지 않는 것 같다.

`본질 기반 해석(EBI)`은 분석과 구현의 문제이지만 '해석' 자체는 다양한 단계에서 있을 수 있다.
설계단계에서 '해석'이 필요한 경우도 있을 수 있다. 사용자 조차 제대로 알 수 없는 것들을 고려해야 하는 경우가 있다.
예를 들면 이 프로젝트의 유지보수 기간에 따라서 설계가 달라질 수 있다. 물론 그 외에 개발인력과 개발비용 기간 등등 많은 요소들을 고려하게 된다.
단순히 요구사항 분석을 바탕으로 설계하는 것이 아니라 그 외에 다양한 요소들을 통찰해서 설계에 반영해야 하는 것이다.
이것에 굳이 이름을 붙이자면 '프로젝트 해석'이라고 해도 될지 모르겠다.

### 왜 사용자 관점을 따라야 할까?

우리가 개발하려는 것은 사용자가 사용하려는 것이다. 사용자의 생각이 변경될 때 현실을 기반으로 한다. 사용자가 방향키의 모양을 변경하기를 원한다면 사용자는 4개의 이미지로 이루어진 방향키를 전제로 어떻게 변경할 것인지를 고민할 것이다.

다시 말하자면 사용자의 생각의 변화에 따라 코드를 변경해야 하는 것이라면 처음부터 코드가 사용자의 생각을 그대로 반영한 구조여야 하는 것이다.

무엇을 해야 하느냐에 집중하는 것이 아니라 왜 해야 하는지에 집중해야 한다. 무엇은 언제든지 변할 수 있다. 그러나 그것을 하려는 이유는 변하지 않는다. 이유가 변하면 어떻게 하느냐고? 이유가 변경되거나 사라진다면 프로젝트 전체가 영향을 받는 것은 어쩔 수 없다.

```txt
이게 `본질 기반 해석(EBI)`라는 이름을 붙일 만한 개념인가? 그냥 당연한 이야기를 하는 건 아닌가?

글쓴이의 의도를 짐작해보자면, `본질 기반 해석(EBI)`라는 용어를 도입한 이유는 소프트웨어 개발에서 본질을 파악하고 개념을 충실히 구현하는 것이 매우 중요함에도 불구하고, 간과되는 경우가 많기 때문일 것입니다.
물론 제기하신 것처럼 `본질 기반 해석(EBI)`의 내용 자체는 어떻게 보면 당연한 이야기일 수 있습니다. 요구사항의 본질을 파악하고 도메인을 반영해서 설계하고 구현해야 한다는 것은 소프트웨어 개발의 기본 원칙이기도 합니다.
하지만 실무에서는 이 기본이 지켜지지 않는 경우가 많습니다. 글에서 제시된 방향키, REST API, 문서 관리 시스템의 사례들이 그런 경우입니다. 개발자들은 종종 편의성, 효율성 등을 이유로 요구사항과 도메인의 본질을 간과하곤 합니다.
`본질 기반 해석(EBI)`라는 용어를 도입함으로써 글쓴이는 이런 문제의식을 환기시키고, 본질과 개념에 충실할 것을 강조하고 싶었던 것 같습니다. 비록 새로운 개념은 아닐지라도 용어로 정의하고 강조함으로써 개발 과정에서 놓치지 말아야 할 원칙으로 자리매김하려 한 것으로 보입니다.
따라서 `본질 기반 해석(EBI)`를 하나의 방법론이나 패러다임으로 보기는 어려울 수 있지만, 개발자들에게 본질과 개념의 중요성을 상기시키는 원칙이자 지침으로서는 의미가 있다고 생각합니다. 다만 용어의 생소함으로 인해 독자들이 어렵게 느낄 수 있으므로, 댓글 주신 것처럼 보다 쉽고 친숙한 용어를 사용하거나, 좀 더 자세한 설명을 덧붙이는 것이 좋겠습니다.
``` -->]]></content><author><name>mannercode</name><email>hello@mannercode.com</email></author><summary type="html"><![CDATA[1. 소개]]></summary></entry><entry><title type="html">객체 지향 프로그래밍의 이해</title><link href="http://localhost:4000/2024/03/09/oop.html" rel="alternate" type="text/html" title="객체 지향 프로그래밍의 이해" /><published>2024-03-09T00:00:00+00:00</published><updated>2024-03-09T00:00:00+00:00</updated><id>http://localhost:4000/2024/03/09/oop</id><content type="html" xml:base="http://localhost:4000/2024/03/09/oop.html"><![CDATA[<blockquote>
  <p>객체 지향 프로그래밍은 데이터와 함수를 하나의 ‘객체’로 그룹화하여 응집성은 높이고 의존성은 낮추는 프로그래밍 패러다임이다.</p>
</blockquote>

<p>OOP를 학습할 때 가장 중요한 것은 사고의 전환이다. 마틴 파울러는 사고의 전환을 이루기 위한 가장 좋은 방법은 OOP가 잘 구성된 환경에서 얼마간 일해보는 것이라고 한다. 그러나 OOP를 제대로 이해한 개발자가 많지 않아서 그런 환경을 찾기가 쉽지 않다.</p>

<p>본 글에서는 절차식에서 객체 지향 방식까지 코드를 개선해 가면서 OOP의 본질이 무엇인지 알아보고 사고의 전환을 이루는데 조금이나마 도움이 되려고 한다.</p>

<h2 id="절차식-코드-소개">절차식 코드 소개</h2>

<p>먼저, 버퍼에서 문서를 읽어서 한 글자씩 출력하는 함수를 작성해 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 버퍼에서 읽기 */</span>
<span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>

  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">buffer</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">buffer</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="절차식-코드에-기능-추가하기">절차식 코드에 기능 추가하기</h3>

<p>여기에 파일에서 문서를 읽어서 한 글자씩 출력하는 기능을 추가해 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

  <span class="cm">/* 파일에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 파일에서 읽기 */</span>
    <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

      <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이것이 전형적인 절차식이다. 절차식의 특징 중 하나는 if가 자주 나온다는 것이다.</p>

<h2 id="절차식-코드의-문제점">절차식 코드의 문제점</h2>

<p>만약 여기에 REST API로 읽는 기능을 추가해야 한다면 어떻게 될까? main()함수는 물론이고 printDocument() 함수도 변경되어야 한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

  <span class="cm">/* 파일에서 읽기 */</span>
  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>

  <span class="cm">/* REST API 요청 */</span>
  <span class="kd">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HttpRequest</span><span class="p">(</span><span class="dl">"</span><span class="s2">https://test.com/api</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">request</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span> <span class="o">|</span> <span class="nx">HttpRequest</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 버퍼에서 읽기 */</span>
  <span class="k">if </span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 파일에서 읽기 */</span>
    <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

    <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

      <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* REST API 요청 */</span>
    <span class="kd">const</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">body</span><span class="p">();</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">body</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">body</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

      <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>지금처럼 printDocument() 함수 하나만 변경하는 것이라면 문제가 되지 않는다. 그러나 printDocument() 외에 다른 함수가 있다면? 변경해야 하는 함수가 그 만큼 늘어난다.</p>

<h3 id="중첩된-함수에서의-문제">중첩된 함수에서의 문제</h3>

<p>실제 프로젝트는 이것보다 더 길고 복잡한 코드인 경우가 많다. 이런 환경에서 관련된 모든 함수를 찾아서 변경하는 것은 쉽지 않다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span>
    <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>
    <span class="nf">updateDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="dl">"</span><span class="s2">new contents</span><span class="dl">"</span><span class="p">)</span>
    <span class="nf">clearDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>

    <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">)</span>
    <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
    <span class="nf">updateDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="dl">"</span><span class="s2">new contents</span><span class="dl">"</span><span class="p">)</span>
    <span class="c1">// clear 하려면 close 해야 한다는 규칙을 알아야 한다.</span>
    <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
    <span class="nf">clearDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">updateDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">,</span> <span class="nx">contents</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">doc</span> <span class="o">=</span> <span class="nx">contents</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">){</span>
        <span class="nx">doc</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">contents</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">){</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">clearDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">doc</span> <span class="o">=</span> <span class="dl">""</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">){</span>
        <span class="nx">doc</span><span class="p">.</span><span class="k">delete</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">){</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">doc</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>

            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">File</span><span class="p">){</span>
        <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">()</span>

        <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">)</span>

            <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">doc</span> <span class="k">instanceof</span> <span class="nx">HttpRequest</span><span class="p">){</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>if는 코드의 복잡도를 증가시키고 개발을 어렵게 한다. 그렇다고 if문을 제거하면 더 큰 부작용이 발생한다.</p>

<h2 id="절차식-코드의-개선-방법">절차식 코드의 개선 방법</h2>

<h3 id="함수-세분화하기">함수 세분화하기</h3>

<p>if를 피하는 방법으로 printDocument()를 세분화 하는 방법을 생각할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="nf">printBufferDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printFileDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printBufferDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printFileDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">File</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="nx">EOF</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

    <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>언뜻 괜찮은 방법처럼 보인다.</p>

<p>그런데 보통은 아래처럼 중첩해서 함수를 호출하기 마련이다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span>
    <span class="nf">printBufferWeeklyReport</span><span class="p">(</span><span class="nx">buffer</span><span class="p">)</span>

    <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">)</span>
    <span class="nf">printFileWeeklyReport</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printBufferWeeklyReport</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span><span class="p">){</span>
    <span class="cm">/* report를 생성하는 코드*/</span>
    <span class="p">...</span>

    <span class="nf">printBufferDocument</span><span class="p">(</span><span class="nx">report</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printFileWeeklyReport</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">File</span><span class="p">){</span>
    <span class="cm">/* report를 생성하는 코드*/</span>
    <span class="p">...</span>

    <span class="nf">printFileDocument</span><span class="p">(</span><span class="nx">report</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>확실히 if 문이 사라지긴 했다. 그러나 if를 피하기 위해서 ‘report를 생성하는 코드’를 반복하게 된다. 이럴거면 차라리 if를 사용하는 것이 낫다.</p>

<h3 id="실행-코드-전달하기">실행 코드 전달하기</h3>

<p>printDocument()에서 if를 제거할 수 없는 근본 원인은 main() 함수에서 printDocument()에 필요한 데이터만 전달할 뿐, 그 데이터를 사용하는 방법은 전달하지 않기 때문이다.</p>

<p>그래서 printDocument()는 데이터의 유형에 따라서 실행해야 하는 코드를 판별해야 하는 것이다.</p>

<p>그렇다면 실행해야 하는 코드도 같이 전달하면 어떨까?</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">buffer</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">getCharFromBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">position</span> <span class="o">==</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="nx">position</span><span class="o">++</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">getCharFromBuffer</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">getCharFromFile</span> <span class="o">=</span> <span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">File</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

    <span class="k">return</span> <span class="nx">char</span> <span class="o">==</span> <span class="nx">EOF</span> <span class="p">?</span> <span class="kc">null</span> <span class="p">:</span> <span class="nx">char</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">getCharFromFile</span><span class="p">);</span>
  <span class="nx">file</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">getChar</span><span class="p">:</span> <span class="nx">Func</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nf">getChar</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>

    <span class="nx">char</span> <span class="o">=</span> <span class="nf">getChar</span><span class="p">(</span><span class="nx">doc</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>비록 main() 함수는 더 복잡해졌지만 printDocument()는 if 문이 필요없고 어떤 형식이 오더라도 변경하지 않아도 된다.</p>

<p>이제 어떻게 하면 main() 함수를 깔끔하게 정리할 수 있을까?</p>

<h2 id="객체-지향-코드">객체 지향 코드</h2>

<p>main() 함수를 깔끔하게 정리하기 위해서 우리는 클래스를 사용할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">bufferDocument</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferDocument</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, World!</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">bufferDocument</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">fileDocument</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileDocument</span><span class="p">(</span><span class="dl">"</span><span class="s2">test.txt</span><span class="dl">"</span><span class="p">);</span>
  <span class="nf">printDocument</span><span class="p">(</span><span class="nx">fileDocument</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">printDocument</span><span class="p">(</span><span class="nx">reader</span><span class="p">:</span> <span class="nx">DocumentReadable</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">char</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>

  <span class="k">while </span><span class="p">(</span><span class="nx">char</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">char</span><span class="p">);</span>
    <span class="nx">char</span> <span class="o">=</span> <span class="nx">reader</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nx">reader</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">DocumentReadable</span> <span class="p">{</span>
  <span class="nf">getChar</span><span class="p">():</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nf">close</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">BufferDocument</span> <span class="k">implements</span> <span class="nx">DocumentReadable</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">position</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">buffer</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">getChar</span><span class="p">():</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">position</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>

    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nf">charAt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">position</span><span class="o">++</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">FileDocument</span> <span class="k">implements</span> <span class="nx">DocumentReadable</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">stream</span><span class="p">:</span> <span class="nx">ReadStream</span><span class="p">;</span>

  <span class="nf">constructor</span><span class="p">(</span><span class="nx">filename</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">stream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">getChar</span><span class="p">():</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">char</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">stream</span><span class="p">.</span><span class="nf">getChar</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">char</span> <span class="o">!==</span> <span class="nx">EOF</span> <span class="p">?</span> <span class="nx">char</span> <span class="p">:</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">public</span> <span class="nf">close</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">stream</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 객체 지향 방식에서의 printDocument()에는 문서 타입을 판별하는 if 문이 없다. main()에서 객체를 처음 생성할 때 필요한 것들이 모두 정해진다. printDocument()는 주어진 객체를 사용하기만 하면 되는 것이다.</p>

<blockquote>
  <p>코드에 if 문이 보인다면 이것이 절차식은 아닌지? 객체 지향으로 개선할 수 없는지 고민해 보기를 바란다.</p>
</blockquote>

<p>앞서 절차식은 printDocument()에 필요한 데이터만 전달할 뿐, 그 데이터를 사용하는 구체적인 방법(함수)은 전달하지 않는다고 했다. 객체 지향 방식은 데이터와 그 데이터를 사용하는 함수를 객체로 묶어서 전달한다. 이것이 가장 크고 두드러지는 차이점이다.</p>

<h2 id="좋은-객체의-특징">좋은 객체의 특징</h2>

<p>코드를 클래스 다이어그램으로 표현해 보자.</p>

<p><object data="/uml/152ad9a5674298d75d5a14fc5eceea85.svg" type="image/svg+xml" class="plantuml"></object></p>

<h3 id="관심사-분리">관심사 분리</h3>

<p><code class="language-plaintext highlighter-rouge">printDocument()</code> 함수는 <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스를 사용하기만 한다.<br />
<code class="language-plaintext highlighter-rouge">BufferDocument</code>나 <code class="language-plaintext highlighter-rouge">FileDocument</code>는 <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스에 맞춰서 각자 기능을 제공하기만 한다.</p>

<p>그러니까 <code class="language-plaintext highlighter-rouge">printDocument()</code>, <code class="language-plaintext highlighter-rouge">BufferDocument</code>, <code class="language-plaintext highlighter-rouge">FileDocument</code>가 아는 것은 <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스 뿐이고 서로에 대해서는 알지 못한다. 이것은 즉, <code class="language-plaintext highlighter-rouge">DocumentReadable</code> 인터페이스가 변경되지 않는 한 각 클래스 혹은 함수를 변경할 필요가 없다는 뜻이다.</p>

<p>다시 설명하자면 인터페이스를 변경하지 않는다면 각 부분을 어떻게 변경하든 다른 부분에는 영향을 미치지 않는다는 것이다. 이것이 객체 지향 프로그래밍이 점진적인 개발을 가능하게 하는 방법이다. 이렇게 인터페이스와 구현을 분리하는 매커니즘은 자연스럽게 응집성이 높아지면서 의존성이 낮아지는 결과가 된다.</p>

<blockquote>
  <p>절차식 사고에 익숙하면 이렇게 기능을 응집시키고 그 부분에만 집중하는 방법 자체에 서투른 경우를 보게 된다. 그것은 코드 뿐만이 아니라 업무를 분담하고 협업하는 등의 일상적인 업무에서도 나타난다.</p>

  <p>예를 들면, 프론트엔드와 백엔드 개발자가 REST API를 정의하고 각자 개발을 진행한다. 그러다 기존에 정의한 REST API를 만족시키지 못하는 오류가 백엔드에서 발생한다. 디버깅을 해보니 백엔드에서 코드를 수정하는 것보다 REST API를 변경하고 프론트엔드에서 코드를 수정하는 것이 더 간단한 상황이다. 백엔드 개발자는 프론트엔드 개발자에게 코드를 수정해 달라고 요청하고 프론트엔드 개발자도 기꺼이 동의한다.</p>

  <p>REST API를 설계했을 때의 원칙을 저버리는 것은 큰 문제다. 더군다나 백엔드의 문제를 프론트엔드까지 끌어들이면서 백엔드와 프론트엔드는 그 만큼 더 강하게 결합하게 된다.</p>

  <p>이 정도 사소한 변경이 그렇게 큰 문제일까 싶은 의문이 들지도 모르겠다. 코딩하는 당시에는 대수롭지 않겠지만 시간이 지나고 다른 개발자가 코드를 분석하려고 할 때 장애가 된다.</p>

  <p>“각자의 작업 영역은 엄격하게 지켜야 한다.”</p>

  <p>절차식 사고에 익숙한 개발자는 이 말을 이기적이고 냉정한 것으로 받아들이는 경우가 있다. 그러나 이것은 지극히 기술적인 접근일 뿐이다.</p>
</blockquote>

<h3 id="접근-제어">접근 제어</h3>

<p>함수들은 변수를 통해서 서로 연결된다고 볼 수 있다.</p>

<p>전역변수를 생각해 보자. 흔히 전역변수를 사용하면 안 된다고 한다. 왜냐하면 하나의 전역변수를 사용하는 모든 함수들은 서로 연결되는 것이다. 소스코드가 10만 라인이 넘어가는 상황에서 다른 함수들이 내가 생각한 규칙대로 움직인다고 어떻게 보장할 수 있을까?
이것은 복잡도를 엄청나게 상승시킨다.</p>

<blockquote>
  <p>코드를 변경할 때 그 영향이 어디까지 미치는 것인지 파악이 안 된다면 거의 반드시 버그를 만들고 있는 것이다.</p>
</blockquote>

<p>아래의 그림에서 count 변수를 사용하는 read(), write(), change(), reset() 함수들은 서로 연결되어 있다. 특히 값을 변경하는 change(), reset() 함수는 다른 모든 함수에 직접적인 영향을 끼친다.</p>

<!-- markdownlint-disable MD032 MD037 -->
<p><object data="/uml/62794e45846be2ea9677da1605c99ef9.svg" type="image/svg+xml" class="plantuml"></object></p>

<p>반면에 <code class="language-plaintext highlighter-rouge">BufferDocument</code>의 <code class="language-plaintext highlighter-rouge">buffer</code>나 <code class="language-plaintext highlighter-rouge">position</code>을 사용하는 함수는 <code class="language-plaintext highlighter-rouge">BufferDocument</code> 클래스에만 존재할 수 있다.
왜냐하면 두 프로퍼티(변수)가 비공개이기 때문에 외부에서의 접근이 원천적으로 차단되기 때문이다.</p>

<p>이것이 프로퍼티를 public으로 직접 노출하지 말라는 이유이다. 외부에서 프로퍼티를 변경할 수 있다면 프로퍼티와 관련된 코드를 변경할 때 그 영향이 어디까지 미칠지 알 수 없게 된다. 잠재적으로 전역변수와 다를바 없게 되는 것이다.</p>

<h2 id="객체-지향의-응용">객체 지향의 응용</h2>

<p>객체 지향 방식의 관심사 분리를 통한 복잡도 관리 및 변화에 의한 영향을 최소화 하는 특징은 다른 분야에도 영향을 끼친다.</p>

<h3 id="microservices-architecture">Microservices Architecture</h3>

<p>MSA는 구조적으로 객체 지향 방식과 유사한 면이 많다.</p>

<p>객체 지향의 핵심은 데이터와 함수를 하나의 객체로 묶는 것이다. MSA에서 서비스도 DB와 API를 하나로 묶어서 관리하고 각 서비스의 내부 구현과 DB는 외부에 노출되지 않는다. 이것은 서비스 내부의 변화가 외부에 영향을 미치지 않도록 하면서 유지보수성과 확장성에 큰 장점이 된다.</p>

<p><object data="/uml/8f61cb1ff6e3db9ca701d5b44d59a589.svg" type="image/svg+xml" class="plantuml"></object></p>

<p>OOP와 MSA가 구조적으로 유사하다는 사실에서 알 수 있듯이, OOP를 제대로 이해하지 못하면 MSA와 같은 아키텍처를 이해하고 올바르게 설계하는 것은 많이 어려운 일이 될 것이다.</p>

<p>요즘은 MSA가 유행인 것 같다. 그리고 많은 개발자들이 API gateway나 gRPC, 메시지 브로커 등 MSA 구성 요소들의 사용법을 익히는 데만 열중하는 것 같다. 그러나 가장 중요하고 기본적인 것은 OOP에 대한 깊은 이해이다.</p>

<blockquote>
  <p>현대적인 소프트웨어 개발 방법의 근간에는 OOP가 있다.</p>
</blockquote>

<h3 id="애자일-방법론">애자일 방법론</h3>

<p>디자이너, 개발자, 기획자 등 관련자들이 한 팀을 이뤄 긴밀하게 협력하는 작업 방식은 객체 지향 프로그래밍(OOP)의 핵심 원칙인 높은 응집성과 낮은 결합도에 비유할 수 있다. 이러한 접근 방식은 소프트웨어 개발 뿐만 아니라, 조직 구성과 팀워크에서도 생산성과 효율성을 높이는 데 중요한 역할을 한다.</p>

<p>애자일 팀의 구성 자체가 데이터와 함수를 하나로 묶는 객체와 동일한 구조는 아니다. 그러나 애자일 팀에서는 기획자가 요구사항이라는 데이터를 생산하고, 개발자가 이를 구현한다는 점에서 데이터의 생산과 소비 주체가 함께 있다는 유사성을 찾을 수 있다. 이는 마치 객체 내부에서 데이터(속성)와 함수(메서드)가 밀접하게 연관되어 있는 것과 같은 맥락으로 볼 수 있다.</p>

<p>한편, 애자일 방법론의 중요 원칙인 점진적인 개발을 반복하는 프로세스는 객체 지향 설계의 관심사 분리를 기반으로 가능한 것이다. 객체 지향 프로그래밍은 시스템을 독립적인 객체들의 상호작용으로 모델링하므로, 각 객체를 개별적으로 개발하고 테스트할 수 있게 해준다. 이는 애자일 방법론이 지향하는 작은 단위의 개발과 피드백 반영을 원활히 하는 데 도움이 된다. 결과적으로 OOP는 애자일 소프트웨어 개발의 기반이 되는 주요 기법 중 하나로 자리매김하고 있다.</p>

<h2 id="결론">결론</h2>

<p>이 글은 이렇게 시작했다.</p>

<blockquote>
  <p>객체 지향 프로그래밍은 데이터와 함수를 하나의 ‘객체’로 그룹화하여 응집성은 높이고 의존성은 낮추는 프로그래밍 패러다임이다.</p>
</blockquote>

<p>그렇다. 데이터와 함수를 하나의 객체로 그룹화 한다는 것이 객체 지향의 핵심이다.
그러나 OOP를 설명하는 많은 글이나 영상은 OOP의 캡슐화, 은닉화, 다형성, 상속성이 무엇인지를 설명한다. OOP의 이 네 가지 기본 원칙은 데이터와 함수를 그룹화 할 때의 지침일 뿐이다. 가장 기본적이고 필수적인 것은 데이터와 함수의 그룹화이다.</p>

<p>그렇다면 데이터만 존재하는 객체가 있을 수 있을까? 반대로 함수만 존재하는 객체가 있을 수 있을까?
문법적으로 class를 사용해서 코드를 작성한다고 해도 그것은 객체가 아니다. 객체는 상태(프로퍼티)와 방법(메소드)이 함께해야 의미를 가진다.</p>

<p>지금 이 글을 읽고 뭔가를 알것 같은 느낌을 받았을지도 모른다. 그러나 실제로 자신의 코드를 객체지향으로 바꿔보기 전에는 그것이 구체화 되지는 않을 것이다.
좋은 코드가 무엇인지 많은 고민과 연습이 필요하다.</p>

<p>현대적인 개발 방법론의 근간에는 OOP가 있다. OOP를 깊이있게 이해하지 못하면 TDD, DDD, 애자일, MSA 등 현대적인 개발 방법을 공부해도 올바르게 사용하기 어려울 것이다. 실제로 MSA를 적용한 프로젝트는 많지만 성공 사례가 적은 이유이다.</p>

<p>객체지향 프로그래밍에서 자주 사용하는 일반적인 패턴을 모아놓은 것이 디자인 패턴이다. 이것은 다음 기회에 다루겠다.</p>]]></content><author><name>mannercode</name><email>hello@mannercode.com</email></author><summary type="html"><![CDATA[객체 지향 프로그래밍은 데이터와 함수를 하나의 ‘객체’로 그룹화하여 응집성은 높이고 의존성은 낮추는 프로그래밍 패러다임이다.]]></summary></entry></feed>