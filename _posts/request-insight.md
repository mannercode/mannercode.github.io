---
layout: post
title:  "본질 지향 개발"
---


설계나 구현을 할 때 무엇을 선택해야 하는지 판단하기 어려운 경우가 있다.
어떤 경우가 있는지 그리고 어떤 선택을 해야 하는지 살펴보자.

## 고민의 순간들

### 방향키의 구현

사용자에게 ‘상/하/좌/우’를 선택할 수 있는 방향키를 제공해야 한다. 4개의 화살표 모양은 동일하고 방향만 다르다. 이 때 4개의 화살표를 구현하는 방법이 두 가지 있다.

먼저 상/하/좌/우에 해당하는 4개의 이미지를 사용하는 것이다.

![](/assets/images/arrows1.svg)

```html
<!-- 4개의 이미지를 사용 -->
<View src="up.png" />
<View src="down.png" />
<View src="let.png" />
<View src="right.png" />
```

그리고 화살표 이미지(arrow.png)를 회전시켜서 구현하는 방법도 있다.

![](/assets/images/arrows2.svg)

```html
<!-- 1개의 이미지를 회전시켜서 사용 -->
<View src="arrow.png" rotate="0" />
<View src="arrow.png" rotate="180" />
<View src="arrow.png" rotate="-90" />
<View src="arrow.png" rotate="90" />
```

무엇이 옳은 것일까? 읽기 쉬운 코드를 추구한다면 왼쪽이지만 효율성을 추구한다면 오른쪽일 것이다.

읽기 쉬운 코드가 옳은가? 성능 효율적인 코드가 옳은가? 대체로 과거에는 성능 효율을 우선했겠지만 요즘처럼 하드웨어의 성능이 충분한 경우에는 읽기 쉬운 코드를 선호한다.
그런 이유로 읽기 쉬운 코드를 선택해야 할까?

다양한 생각들이 있겠지만 우선적으로 고려해야 하는 것은 화살표의 의미다.

만약 화살표가 아래와 같이 특정한 물체를 가리키는 용도라면 화살표를 회전시켜서 구현하는 것이 맞다.

![](/assets/images/arrows3.svg)

그러나 방향키를 요구한 누군가가 생각했던 것은 아래와 같이 키보드 구석에 고정되어 있는 4개의 방향키였을 것이다.

![](/assets/images/arrows4.svg)

사용자가 방향키라고 했을 때 키보드의 그 방향키라고 하지 않았을 것이다. 방향키가 키보드의 그 방향키인 것이 당연하니까.
그러나 구현하는 프로그래머는 방향키에 대한 추가 정보가 없기 때문에 구현 방법을 선택하는 데 있어서 고민하게 되는 것이다.

이것이 해석의 어려운 부분인데 정확한 해석을 하려면 요구사항이 그렇게 정의된 이유와 과정까지 모두 고려해야 한다.
그러나 사용자도 세세한 부분까지 모두 명확하게 생각해서 요구사항을 정의한 것은 아니기 때문에 많은 경험과 통찰력이 필요하다.

<그림 2-1>처럼 화살표의 모양이 같기 때문에 회전 시켜서 구현해 볼 생각도 할 수 있었을 것이다.
그러나 이것은 사용자의 의도나 이전 단계의 분석을 무시한 채 단순히 구현 편의성만 고려한 생각이다.

다시 강조하자면 <그림 2-1>에서 화살표의 모양이 동일한 것은 그저 우연일 뿐이다.
이런 우연으로 생긴 상황에서 구현 편의성을 추구하게 되면 사용자의 생각과 멀어지게 된다.

그러면 어떤 일이 생길까?
사용자는 방향키의 모양을 <그림 2-3>처럼 바꿔달라고 쉽게 요구할 수 있다.
왜냐하면 키의 이미지를 변경하기만 하면 되니까 당연히 쉽다고 생각하기 때문이다.
그런데 개발자는 구현 방법을 바꿔야 하는 큰 일이 된다.

여러분은 이전 화면에서 어떤 방법을 선택했는가?
그리고 그 선택의 이유는 무엇이었는가?
나와 같은 이유였는가? 아니면 더 논리적이고 합리적인 이유가 있었는가?
만약 더 나은 이유였다고 생각한다면 댓글 부탁한다.

중요한 것은 선택의 결과가 아니라 선택의 이유이다.
이유가 틀려도 결과는 맞을 수 있다.
그러나 그것은 단지 운일 뿐이고 운은 계속되지 않는다.

만약 지금 상황에서 사용자의 의도를 정확히 파악할 수 없다면 어떻게 해야 할까?
혹은 어떻게 변경될지 예측할 수 없다면 어떻게 해야 할까?

<Up /><Down /><Left /><Right /> 클래스로 정의해서 화살표의 요구사항이 어떻게 변경 되더라도 다른 곳에 영향이 없도록 하는 것이다.

변경되지 않을 것이라고 생각된다면 클래스로 만드는 것은 부담일 수 있다.
4개의 소스 파일을 만들고 생성자도 작성하고 인터페이스도 상속하는 등의 작업을 하지 않아도 되니까 말이다.

### REST API의 Shallow routing과 Nested routing

rest api에는 크게 두 가지 디자인이 있다. shallow routing과 nested routing이다. 어느 쪽이 우월한 기술인가? 혹은 어떤 기술을 선택해야 하는가? 이것은 많은 논쟁이 있다.

이번에는 REST API에 대해서인데요.
사용자가 1. 현재 상영중인 영화를 선택하고 2. 극장을 선택한 상태에서 3. 상영 시간을 선택하려는 상황입니다.
이 때 상영시간을 제공하는 REST API를 어떻게 디자인 해야 할까요?

일반적으로 Shallow Routing이 기술적으로 옳은 방향이라는 의견이 지배적이다.
movieId나 theaterId가 빠지거나 변경될 수 있고 다른 쿼리가 추가될 수도 있다.
상황의 변화에 유연하게 대응할 수 있습니다.

반면에 Nested Routing은 정해진 구조를 변경하기 어렵습니다.
하려면 할 수도 있겠지만 이미 Nested Routing에 맞춰 구현되어 있을 코드를 상당수 고쳐야 할 것입니다.

그러나 두 방식 중에서 무엇을 선택할 것인지는 개념적인 관점에서 리소스의 구조가 중첩되는 것인지를 우선해서 판단해야 한다.

중첩 라우팅 API는 티켓 구매 프로세스를 그대로 반영하고 있다.
티켓 구매 프로세스도 영화 선택 후 극장을 선택해야 하듯이, 중첩 라우팅 API도 영화를 지정하지 않으면 극장을 지정할 수 없다.
Nested Routing의 REST API가 티켓 구매 프로세스를 구체적이고 정확하게 표현하고 있다.
별도의 문서로 정리하지 않아도 티켓 구매 프로세스를 알 수 있는 것이다.

Shallow Routing이 좋은가? Nested Routing이 좋은가에 대해서 기술적 논쟁이 있습니다.
요구사항 해석을 중요시하는 제 입장에서 보자면, 저는 그런 논쟁이 무의미해 보입니다.
중요한 것은 요구사항을 정확히 반영하는 것이 무엇이냐인 것이죠.
기술적 관점에서 보면 답이 없는 문제를 가지고 논쟁을 하니 논쟁이 끝날리가 없습니다.
여러분, 한참 고민해도 답이 보이지 않는다면 답이 거기에 없는 것입니다.

### 장바구니 기능의 선택

보다 논리 레벨의 단계에서도 선택의 고민은 계속된다. 영화 예매 서비스를 개발한다고 할 때 여기에 장바구니 기능을 구현해야 할까? 혹시 나중에라도 필요하지 않을까?

### 클래스의 상속 vs 포함

클래스의 기능을 재활용(?)하는 방법에는 크게 두 가지가 있다. 하나는 클래스를 상속하는 것이고 다른 하나는 포함하는 것이다. 흔히 상속 보다는 포함을 사용하라고 한다. 그것이 기술적으로 여러 장점이 있기 때문이다. 그렇다면 상속은 최대한 피해야 하는 것인가? 언제 상속을 해야 할까?

쉽게 선택할 수 없는 것은 기술적인 측면만을 고려하기 때문이다. 기술들은 각각 장단점이 있다. 문제는 소프트웨어는 계속해서 변경된다는 것이다. 오늘의 선택이 내일은 장애가 될 수도 있다.

### 문서의 통합 vs 분리

외교부의 아포스티유/영사확인 문서 프로젝트를 진행할 때였습니다.

소득증명서와 같은 국내에서 발행되는 문서의 국외 사용을 위한 인증 방식이 두 가지 있는데요.
그것이 아포스티유와 영사확인입니다.
프로젝트의 목표는 이 두 문서를 암호화 하고 변조 여부를 확인할 수 있는 시스템을 구축하는 것이었다.

아포스티유와 영사확인 문서는 항목이나 구조가 유사했기 때문에 기존에 구축된 서비스도 하나의 테이블을 공유하고 있었다.
그러나 저는 영사확인과 아포스티유가 비슷해 보이는 것은 우연일 뿐이며 동일한 문서로 취급하면 안 될 것처럼 보였다.

만약 같은 문서라면 프로젝트 이름이 '아포스티유 & 영사확인'은 아니었을 것이다.

그에 반해서 back-end 담당자는 두 개로 분리할 필요가 없다는 주장을 하고 있었다.
결국 타협점으로 REST API만 두 개로 분리하고 테이블 등은 하나로 구현하기로 했다.

그런데 프로젝트가 진행되면서 두 문서의 차이가 구체화 되기 시작했다.
아포스티유와 영사확인의 문서번호가 중복될 수 있어서 문서번호 체계가 달라졌다.
그리고 서비스 기능이 확장 되면서 두 문서의 인터페이스는 점점 달라졌다.

결국 테이블을 둘로 나누고 내부 구조도 분리하기로 결정했다.
다행스럽게도 외부에 노출되는 API는 두 개로 분리되어 있었기 때문에 내부 구조를 변경하는 것은 비교적 수월했다.
만약 분리하는 것이 부담스러워서 리팩토링을 피하려고 했다면 코드 곳곳에 if-else가 넘쳐나고 지옥으로 가는 문이 열렸을 것이다.

이 사례에서 두 문서가 같은 데이터를 저장하고 있었던 것은 그저 우연일 뿐이다.
프로그래머는 흔히 구현 편의성을 우선해서 설계에 반영한다. 그 습관을 버리기가 쉽지 않을 것이다.
그러나 철저하게 개념을 따라야 한다.

### DB 저장 방법

사용자가 업로드 한 파일이 한글이라서 UrlEncoding을 해서 서버에 전송한다.
그리고 클라이언트가 파일을 다운로드 받으려면 UrlEncoding을 해야 한다.

그렇다면 서버는 DB에 인코딩된 문자열을 그대로 저장해야 할까?
아니면 디코딩해서 저장하고 사용자가 다운로드 할 때 마다 다시 인코딩을 해야 할까?

사용자의 의도는 안녕하세요.txt이지 디코딩된 문자열이 아니다.
사용자의 의도를 더 정확하게 반영하는 것이 우선이고 최적화는 그 다음이다.
지금은 다운로드지만 파일 목록을 보여주거나 할 때는 원본 문자열이 필요할 수도 있다.

이 영상을 보는 사람들 중 누군가는 디코딩 해서 저장해야 한다고 생각했을 수 있다.
중요한 점은 디코딩을 한 이유이다. 결과가 같더라도 과정이 틀렸으면 그저 운이 좋았을 뿐이다.
물론 내 생각이 정답은 아니다. 그리고 언제나 예외는 있기 마련이다.

### 프로젝트 이름

백엔드에 대한 기본적인 지식을 전달하기 위한 프로젝트로 영화 예매 서비스 개발을 시작하려고 한다.
프로젝트의 이름을 무엇이라고 해야 할까? 영화 예매니까 ticket-service이라고 하면 어떨까?

그런데 우리가 하려는 것이 영화 예매 서비스를 개발하는 것일까? 아니다 그것은 그저 수단에 불과하다. 우리가 하려는 것은 backend-fundamentals이다. 수단은 언제든지 변경될 수 있다. 변하지 않는 것은 목표다. 이런 경우처럼 진짜가 무엇인지 통찰하는 과정에서 자칫 오류를 일으킬 수 있다.

### 사용자와 무관한 소프트웨어

사용자와 무관한 소프트웨어 개발이라면 어떨까? 백그라운드에서 동작하는 소프트웨어라도 모델이 되는 개념은 존재한다. OS의 아키텍처나 스케쥴 같은 것들 말이다. 사용자가 없는 소프트웨어는 없다. 사용자가 사람이 아닌 소프트웨어는 있을 수 있다.

트레이너라면? ui는 단순히 버튼 뿐이다. 여기에 rbd가 끼어들 틈이 있을까?

## 왜 사용자 관점을 따라야 할까?

우리가 개발하려는 것은 사용자가 사용하려는 것이다. 사용자의 생각이 변경될 때 현실을 기반으로 한다. 사용자가 방향키의 모양을 변경하기를 원한다면 사용자는 4개의 이미지로 이루어진 방향키를 전제로 어떻게 변경할 것인지를 고민할 것이다.

다시 말하자면 사용자의 생각의 변화에 따라 코드를 변경해야 하는 것이라면 처음부터 코드가 사용자의 생각을 그대로 반영한 구조여야 하는 것이다.

무엇을 해야 하느냐에 집중하는 것이 아니라 왜 해야 하는지에 집중해야 한다. 무엇은 언제든지 변할 수 있다. 그러나 그것을 하려는 이유는 변하지 않는다. 이유가 변하면 어떻게 하느냐고? 이유가 변경되거나 사라진다면 프로젝트 전체가 영향을 받는 것은 어쩔 수 없다.

## 결론

결론입니다.

요구사항 해석이 DDD와 비슷하다고 생각하실지 모르겠습니다.
DDD는 복잡한 도메인 로직을 다른 부분과 분리하는 것이고 설계 단계의 이야기입니다.
요구사항 해석은 요구사항 분석과 설계에서 당연하게 누락된 생각을 채우는 것으로 구현 단계의 이야기입니다.

분석 단계에서 사용자의 모든 생각을 문서로 정리할 수 없다.
설계도 마찬가지인데 설계 단계에서 설계자의 모든 생각을 정리할 수 없다.
모든 요구사항과 설계를 정리한 것이 코드이기 때문이다.

어느 정도 빈틈이 있을 수 밖에 없고 그 빈틈은 굳이 말하지 않아도 알 것이라고 생각하는 것들이다.
문제는 당연히 알 것이라고 생각하는 것 중에서 당연하지 않은 것이 있기 때문이다.
다시 말하자면 사용자가 당연하게 생각하는 것들을 개발자는 전혀 다르게 받아들일 수 있다.

이런 사용자와 개발자의 생각의 오차를 줄이려는 노력이 요구사항 해석이다.
개발은 요구사항 분석을 바탕으로 설계하고 구현해야 한다.
잘못된 분석을 기반으로 구현을 하면 얼마 안 가서 문제가 드러난다.
그러나 잘못된 해석을 기반으로 구현을 해도 당장 문제가 되지는 않는다.
문제가 되지 않는게 문제인데 프로젝트가 한참 진행된 후에 잘못을 인지하고 수정하려면 많은 노력이 필요하기 때문이다.

요구사항 해석에 대해서 간단하게 설명했지만 중요한 개념이다.
보통 소프트웨어 공학 관련 서적이나 자료들은 분석,설계,구현,검증 각각의 단계에 집중해서 설명을 하다보니
요구사항 분석과 구현을 일치시키려는 요구사항 해석에 대해서는 그 개념과 존재가 분명하게 다뤄지지 않는 것 같다.

요구사항 해석은 분석과 구현의 문제이지만 '해석' 자체는 다양한 단계에서 있을 수 있다.
설계단계에서 '해석'이 필요한 경우도 있을 수 있다. 사용자 조차 제대로 알 수 없는 것들을 고려해야 하는 경우가 있다.
예를 들면 이 프로젝트의 유지보수 기간에 따라서 설계가 달라질 수 있다. 물론 그 외에 개발인력과 개발비용 기간 등등 많은 요소들을 고려하게 된다.
단순히 요구사항 분석을 바탕으로 설계하는 것이 아니라 그 외에 다양한 요소들을 통찰해서 설계에 반영해야 하는 것이다.
이것에 굳이 이름을 붙이자면 '프로젝트 해석'이라고 해도 될지 모르겠다.
