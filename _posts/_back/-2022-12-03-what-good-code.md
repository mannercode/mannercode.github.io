---
layout: post
title: "1. 좋은 코드란 무엇인가?"
---

## 좋은 코드의 정의

사람은 누구나 자기가 노력하는 분야에서 실력으로 인정받기를 원한다.\
프로그래머도 마찬가지인데 문제는 실력의 기준이 제각각이라는 것이다.\
누군가는 알고리즘 같은 기본기를 중시하고 또 누군가는 빠르게 기능을 구현하는 것이 실력의 기준이 된다.\
거기에 디버깅도 잘 하고 최신 기술도 많이 알면 보통은 실력있는 프로그래머로 인정 받는 것 같다.

그러나 그게 전부일까?\
SDK의 문서를 읽고 기능을 구현하는 것은 당연하고 평범하다.\
알고리즘도 몇 개 정도를 이해하면 나머지는 개인의 재능에 따른 응용일 뿐이다.\
과연 주니어 프로그래머와 시니어 프로그래머의 차이가 이런 기술의 숙련도 정도일까?

내 생각에 프로그래머의 실력은 `얼마나 좋은 코드를 작성할 수 있는가`에 달렸다.\
프로그래머의 실력에 한정해서 이야기하는 것에 주의하기 바란다.\
좋은 프로그래머라면 실력 뿐만이 아니라 커뮤니케이션 능력을 포함하는 현명함도 갖추어야 한다.\
나 자신이 좋은 프로그래머라는 확신이 없고 이에 대한 정답도 존재할 것 같지 않다.

좋은 코드라는 추상적이고 주관적인 평가는 상황에 따라 달라지기 때문에 정의하기가 조심스럽다.\
그럼에도 불구하고 주변 프로그래머들에게 물어봤을 때 대체적인 공통된 답변은 '읽기 쉽고 변경하기 쉬운 코드'다.\
여기서 코드를 읽는 목적은 코드를 변경하기 위해서이기 때문에 이것은 결국 `변경하기 쉬운 코드`로 축약할 수 있다.

좋은 코드에 대한 정의는 각자 조금씩 다를 것이다.\
그러므로 이 글은 좋은 코드가 무엇이고 왜 그렇게 됐는지에 대한 나의 생각이다.

## 좋은 코드가 필요한 이유

프로그래머들은 왜 변경하기 쉬운 코드를 좋은 코드라고 생각할까?\
코드의 집합체인 소프트웨어를 자주 변경해야 하기 때문인데 주로 `사용자 요구사항`과 `분석 과정에서의 오류`가 원인이다.\
그 외에 종종 운영 환경의 변화가 원인이 되기도 하는데 몇 가지 예를 들면 아래와 같다.

1. OS가 업그레이드 되면서 API가 변경된다(특히 Apple OS들이 적극적이다).
1. 외부 인증 서비스가 중단되거나 비용이 높아져서 다른 서비스로 교체해야 한다.
1. 사용량이 증가하면서 성능 하락의 문제가 발생한다.
1. 사용하는 라이브러리에서 보안 취약점이 발견되거나 라이센스 정책이 변경된다.

이와 같이 어떤 식으로든 변경은 발생하고 기능 개선의 요구도 끝없이 나오는 것이 보통이다.

운영환경이야 어쩔 수 없다고 해도 요구사항 변경을 최소화 할 수는 없을까?\
무엇을 만들 것인지 신중하게 분석하고 설계하면 분석 단계에서의 오류도 줄일 수 있을 것 같다.

그러나 대부분의 프로젝트들이 이런 문제를 갖고있는 만큼 생각처럼 쉽지는 않다.\
이 정도 되면 그냥 소프트웨어 개발이 원래 그러려니 해야 하고 이런 문제를 최소화 하는 개발 전략을 세워야 한다.

생각해 보면 건축물이나 자동차는 이렇게 자주 변경하지 않는다.\
자동차의 경우 바퀴도 바꾸고 엔진도 개조하지만 적어도 프레임을 변경할 생각은 안 한다.\
소프트웨어 만큼 자주 변하는 것으로는 음악이 있는데 유명한 곡에 얼마나 많은 변형이 있는가를 생각해 보면 납득이 된다.

왜 소프트웨어는 프레임에 해당하는 부분까지도 변경하게 될까?\
이에 대해서 `Grady Booch`의 저서 `Object Oriented Analysis and Design with Applications`에서 그의 통찰을 읽을 수 있는데 요약하면 `소프트웨어의 복잡성`이라는 본질적 특성 때문이라고 한다.\
다시 말하자면 소프트웨어는 복잡해서 인간이 시행착오 없이 만들 수는 없다. 점진적인 개선을 통해서 완성해 나가는데 그 과정에서 변경이 계속되는 것이다.

> 산업용 소프트웨어 특징으로는 개발자 한 사람이 설계 부분까지 상세히 모두 알기에는 무척 까다롭다.
> 비록 불가능하지는 않겠지만, 대충 말해 이 정도의 시스템 복잡도라면 인간이 처리하는 지적 능력을 초과한다.
> 안된 일이지만 이런 복잡성은 대형 소프트웨어 시스템에서는 모두 나타나는 본질적 속성으로 보인다.
> 본질이라는 말은 복잡성을 정복할 수는 있어도 복잡성 자체를 제거할 수는 없다는 뜻이다.

아래의 두 항목은 거기에 나의 생각을 추가한 것이다.

### 소프트웨어의 유연성

소프트웨어라는 이름에서 알 수 있듯이 유연성은 소프트웨어의 본질적 특성이다.\
많은 책에서 유연성으로 정의해서 나도 그렇게 언급하지만 나는 무형이라는 말이 더 맞는 것 같다.\
소프트웨어는 논리와 개념의 집합으로 이루어진 무형의 산물이다.\
형태가 없기 때문에 변경하기 쉽고 그 만큼 구체화 하기도 어렵다.

건축은 지어질 건물을 3D모델링도 하고 미니어처로 만들어 보기도 한다.\
그러나 소프트웨어는 사용자가 볼 수 있는 화면으로 모두 구체화 할 수는 없다.\
구현해야 하는 개념을 사용자가 이해할 수 있게 눈에 보이는 형태로 표현하는 것도 어렵다.\
음악도 마찬가지인데 누군가에게 작곡을 의뢰할 때 원하는 것을 어떻게 표현할 수 있을까?\
아방가르드하고 약간은 그로테스크한 느낌의 신나는 곡이라고 하면 될까?

눈에 보이지 않는 생각이 추상적인 표현으로 전달되기 때문에 각자 생각하는 형태가 다른 것이 당연하다.\
개발이 진행될수록 사용자와 개발자 사이의 생각의 차이가 드러나고 그 만큼 큰 변경을 하게 된다.\
사용자의 생각을 구체적인 형태로 표현할 수 있다면 이런 시행착오를 줄일 수 있는데 그것이 분석/설계 문서이다.

사용자의 생각을 제대로 파악해서 문서를 작성하는 것도 어렵지만 사용자의 생각이 계속 바뀌는 것은 더 어렵다.\
사용자의 생각도 소프트웨어와 마찬가지로 무형이라서 그렇기는 하지만 인간의 생각 자체가 창조적이기 때문에 계속 새로운 아이디어가 떠오르기 마련이다.\
건물을 지을 때는 구조물을 변경하기 어렵기 때문에 사용자의 생각이 바뀌어도 상관이 없다. 사용자도 변경이 어렵다는 것을 알기 때문이다.\
그러나 소프트웨어는 무형이기 때문에 언제든지 변경할 수 있다는 환상이 있어서 출시 직전까지 요구사항 변경에 시달리기 마련이다.

변경은 자연스러운 것이고 프로그래머가 극복해야 하는 자연재해다.\
자연재해는 막을 수 없고 가능한 피해를 최소화 할 수 있을 뿐이다.\
그래서 가능한 쉽게 변경을 수용할 수 있는 코드를 작성하는 것이 좋다.

### 하드웨어의 발전

소프트웨어의 변경이 계속되는 이유 중에 하나는 하드웨어의 발전이 있다.
하드웨어는 소프트웨어를 담는 그릇이라고 할 수 있는데 하드웨어의 발전이 빠르면 그 만큼 소프트웨어의 발전도 빠르기 마련이다.
예를 들어,

- CPU와 메모리가 발전하면서 텍스트 기반의 OS에서 GUI 기반의 OS가 생겼다.
- CPU가 충분히 작아지면서 스마트폰이 생겼고 그에 따르는 수 많은 앱이 생겼다.
- CPU가 단일코어로 성능향상이 어려워지면서 이제는 8개의 코어는 기본이 됐고 소프트웨어는 병렬처리를 효율적으로 수행하도록 변화했다.
- 통신 인프라가 발전하면서 클라우드 컴퓨팅이라는 개념이 생겼다.
- CPU와 메모리가 발전하면서 가상화를 쉽게 수행하게 됐다.

VR이 대중화 된다면 그에 맞는 새로운 인터페이스도 기대할 수 있고 SSD의 속도가 충분히 빨라져서 메인 메모리의 개념이 사라질지도 모른다.

이렇게 발전하는 하드웨어에 맞춰서 그에 맞는 새로운 플랫폼과 개념들도 생겨나고 있다.\
그래서 현재 잘 사용하고 있던 소프트웨어도 금방 구식이 되기 때문에 다시 만들던가 크게 업그레이드를 하게 된다.\
어느 쪽이든 가능하면 기존 코드를 활용하는 것이 시행착오를 줄일 수 있는 방법이기 때문에 역시 좋은 코드를 작성해야 한다.

## 좋은 코드를 위한 도구와 방법들

이 글의 주제가 `좋은 코드`이기는 하지만 여기서 말하는 코드는 `printf("hello world!")` 같은 좁은 의미의 코드가 아니다. 표준화된 인터페이스와 유연한 아키텍처 등 `변화에 대응하는 기술적인 방법 모두`를 포함한다.

그 중 리팩토링은 좋은 시작점인데, 현재 코드의 무엇이 문제이고 이것을 어떻게 개선하면 되는지에 대한 이야기다. 자세한 내용은 `Martin Fowler`의 `Refactoring`을 추천한다.

아래는 변경에 대응하는 방법들 중 대표적인 몇 가지를 나열했다.\
물론 여기에 있는 것이 전부는 아니며 기준에 따라서 더 많은 것들이 있을 수 있다.\
중요한 것은 변경에 대응하기 위해서 이렇게 다양하고 많은 방법들이 존재한다는 것이다.

설계 방법에는 아래의 것들이 있다.

- OOP
- 디자인 패턴
- Layerd
- MVC/MVVM
- MSA

개발 도구에는 아래의 것들이 있다.

- Java, .NET
- React Native, Flutter
- TypeORM, MyBatis
- Docker/Kubernetes

마지막으로 개발 방법과 방법론이다.

- TDD
- DDD
- 애자일

위의 설계 방법과 도구들의 공통점은 변화에 대응한다는 것이다. 변화의 대상을 정의하고 그 변화에 독립적인 솔루션을 제시한다.\
그것은 코드도 마찬가지인데 좋은 코드는 변화에 쉽게 적응한다. 이런 코드의 특징은 의존성이 낮고 응집성이 높은 것이다.\
그래서 패턴이나 아키텍처의 핵심은 규모만 다를 뿐이지 의존성과 응집성에 대한 이야기다.

몇몇 책에서도 의존성과 응집성을 직접적으로 이야기 한다.\
그렇지 않더라도 방법과 방법론에 대한 '모든' 서적은 변화에 대한 이야기다.\
그리고 좋은 코드에 대해 소개하려고 하는 이 블로그 또한 응집성과 의존성에 대한 이야기다.

![의존성/응집성](/assets/refs/cohesion-coupling.png)
그림1 - 의존성과 응집성
> 다른 모듈과의 관계는 최소화, 그러기 위해서 관련있는 요소들은 최대한 응집한다.
> 그러면 변화의 영향이 다른 곳에 전파되는 것을 최소화 할 수 있다.

마지막으로,
많은 이들이 위에 나열한 개발 방법과 도구들에 집착하는 것으로 보인다.\
그러나 문제의 본질을 통찰하고 예측할 수 있다면 대응은 비교적 쉬운 편이고 도구도 올바르게 사용할 수 있다.\
반대로 도구에만 집착하면 오버엔지니어링이 되기 쉽다.\
도구는 수단이지 목적이 아님을 잊으면 안 된다.

## 결론

React, NodeJS와 같은 응용 기술은 변화가 빨라서 한 프로그래머가 여러 영역에 걸쳐서 전문성을 유지하기가 쉽지 않다.\
반면에 패턴과 아키텍처와 같은 개발 이론의 지식은 쉽게 얻을 수 없으나 얻으면 모든 분야에 유용하다.\
설계 없는 개발이 가능하겠는가.

어떤 이는 내가 디자인 패턴을 공부해도 다른 프로그래머들이 이해하지 못하기 때문에 쓸모가 없다고 말한다.\
시니어나 팀장이 되면 전체적인 틀을 잡고 주니어들에게 가이드를 하며 작업을 진행하게 되는데 이 때 소프트웨어 공학에 능숙하다면 더 나은 가이드를 할 수 있다.\
나의 경우에는 프로젝트를 처음 시작할 때 내가 먼저 테스트를 포함한 기본적인 기능을 구현한다.\
그러면 팀원들이 그것을 응용해서 작업을 하고 테스트까지 작성할 수 있었다.

컴퓨터가 개발된 초기에는 하드웨어 성능이 부족했지만 지금은 반대로 성능이 넘친다.\
그래서 소프트웨어는 성능 효율이 비교적 부족해도 변경 효율적인 쪽으로 발전하고 있는데 Docker나 크로스플랫폼이 그렇다.\
이에 맞춰서 현대의 좋은 코드는 변화에 잘 적응하는 코드다. 컴퓨터 초기라면 효율과 성능이 좋은 코드였겠지만 말이다.

끝으로,\
지식만으로는 프로젝트를 완성할 수 없고 나와 상대방을 아우르는 현명함이 필요하다.\
그래서 이 블로그에는 개발 방법 뿐만 아니라 여러 회사를 거치면서 힘들었던 경험들을 공유하려고 한다.\
이 블로그가 Manner Code인 이유다.
