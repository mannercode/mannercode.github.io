## 미정리

책에 있는 것은 그저 모범사례일 뿐이다. 현재 상황에 맞게 어느 정도 응용을 해야 한다. 물론, 제대로 이해해야 응용도 가능하다.

### 표준화의 어려움
자주 사용하는 기능이 표준화 되어있으면 개발은 보다 수월해질 것이다. 그러나 많은 프로젝트에서 세부적인 기능까지 직접 구현하는 경우가 많다.
그래디 부치는 그의 저서에서 소프트웨어의 유연성이 표준화를 어렵게 만드는 요인으로 언급했다.

> 주텍 건설업자는 대체로 목재를 확보할 목적으로 목재 농장을 운영하지는 않는다. 건측 회사가 새 건물에 쓸 맞춤형 철제 대둘보를 단조하려고 현장에 제강 공장을 세우는 일도 극히 드물다. 하지만 소프트웨어 산업에서 이런 관행은 보통이다. 소프트웨어는 극한의 유연성을 제공하므로, 개발자로서는 어떤 종류의 추상화도 표현할 수 있다. 이런 유연성은 믿을 수 없이 매력적인 속성으로 밝혀졌지만, 개발자가 상위 수준 추상 개념을 올려놓을 뼈대에 해당되는 구성 요소까지도 수작업으로 공둘여 만들 게 된 요인이기도 하다. 건측 산업에서는 일관성 있는 건물 기준과 표준을 써서 원자재 품질을 관리하는 체제를 갖춘 반면, 소프트웨어 산업에는 이런 표준이 거의 없다. 결과적으로 소프트웨어 개발은 노동 집약 산업 수준에 머물러 있다.

그러나 내 생각에 표준화가 안 되는 것은 소프트웨어의 발전이 빠르기 때문이다. 새로운 개념과 인터페이스가 성숙해지기 전에 더 개선되거나 새로운 개념이 계속 나오기 때문에 표준화 될 틈이 없다. 여기서 말하는 표준화의 대상은 프로토콜 뿐만 아니라 라이브러리나 프레임워크다.
예를 들어 REST API가 웹 인터페이스의 표준처럼 인식된 지 몇 년이나 지났다고 대안으로 RPC가 언급되고 있다. 라이브러리나 프레임워크도 그런 기능을 지원하기 위해서 변화하고 프로그래머도 그것을 쫓아가게 된다.

우리나라 정부의 SI사업은 자바 스프링과 React로 어느 정도 표준화를 이루었다. 그러나 도구가 아닌 기능이 표준화 되지 않으면 큰 도움은 되지 않을 것이다.

<!-- ### 이유

왜?가 제일 중요하다 우리가 접하는 많은 개발 방법과 도구들이 왜 그렇게 되었는지 이해하면 더 잘 이해할 수 있다.
OOP에 대한 경험이 부족한 프로그래머라면 리팩토링 디자인패턴을 그냥 읽기 보다는 변화라는 프레임에서 읽는다면 이해하는 데 도움이 될 것이다.

### 기타
실제로 경력이 10년 정도를 넘게되면 반복되는 작업에 더 성장하지 못하는 프로그래머들을 많이 봐왔다.
그런 프로그래머들에게 소프트웨어 개발은 별 것 없는 정이 경력이 오래될수록 생각이 고착화 되는 것 같다. -->
<!-- 많이 아는 것이 무의미한 것은 아니다.
그러나 지금의 기술이 쉽게 구식이 되는 이 분야에서는 다른 것이  -->

<!-- 흔히 이야기하는 좋은 소프트웨어는 사용자의 평가로써 `사용하기에 편하고 최소한의 시스템 자원으로 효율적이고 안정적으로 운영되는 것`이다.
반면에 좋은 코드는 프로그래머의 평가다. -->

### 좋은 함수의 어려움

함수를 작성하기 어렵다. 특히 이름 짓기가 어렵다.
assert try/catch를 적절히 사용해서 함수를 깔끔하게 만들 수는 있다.
그러나 함수가 변경되는 것을 피할 수는 없다.
그래도 함수는 비교적 쉬운 편인데 영향을 미치는 범위가 작기 때문이다.
클래스가 되면 더 많은 영향을 주고 모듈은 더더 많은 영향을 준다.
영향을 많이 주는 만큼 변화에 취약하기 마련이다.

이름이 길어지는 것은 함수가 하는 일이 명확하지 않아서다.
이것은 두 가지가 있는데 함수가 하는 일이 많거나 함수를 만든 프로그래머가 함수가 무슨 일을 하는지 제대로 파악하지 못해서다.
이 문제를 해결하려면 결국 클래스를 찾게 된다.
이름을 명확하게 하기 위해서 함수를 작게 만들면 너무 많은 함수가 만들어지는 것은 아닐까?
그래서 클래스를 찾게 된다.

### 클래스
리팩토링에서 소개하는 것은 지극히 기술적인 부분만 다룬다.
그런데 함수를 계속 변경하게 되는 것이 리팩토링의 기술이 부족해서일까?
함수의 인자값이 계속 바뀐다. (예제 고민하자)
이런 문제를 단순히 리팩토링으로 해결할 수는 없다.

그렇다면 OOP를 열심히 공부하고 SOLID원칙에 충실하면 좋아질까?
SOLID는 클래스 설계 지침일 뿐이다.
OOP는 익숙하고 SOLID에 충실하다면 변화에 잘 적응하는 좋은 코드를 만들 수 있을까?
답은 아니오다.
물론 그런 기술적인 지식들이 어느 정도 도움은 된다. 그러나 설계나 구현만으로는 좋은 코드를 작성할 수 없다.
변화에 대응하기 위해서는 분석이 제대로 이루어져야 한다.
이름 짓기가 힘들고 그래도 명확하게 이름을 지으려고 하니 이름이 길어진다. 함수나 변수 마찬가지다.
이것 또한 분석이 제대로 되지 않은 것이다. 이 함수가 무엇을 하는가에 대한 분석이 부족한 것이다.

말하고자 하는 것은 이미 나왔다. 좋은 코드를 작성하기 어려운 가장 근본적인 이유는 분석이 제대로 되지 않아서다.
왜 그럴까?
이것은 소프트웨어의 본질적 특성 때문인데 요구사항은 추상적이고 개념적이다.
프로그래머는 무언가부터 구체화를 시작해서 거기에 살을 붙여나가게 되는데 요구사항을 구체화 하기 어려운 것이다.
그래서 가장 구체화 하기 쉬운 DB나 로우레벨에 가까운 코드를 먼저 작성하게 되는데 이러면 정확한 분석과 점점 멀어지게 된다.
코드에 무언가 문제를 느껴서 개선해 보려고 하지만 분석에서 멀어진 상태로는 어떻게 해도 개선이 안 된다.
분석이 틀리면 그것을 기반으로 하는 설계와 구현이 모두 틀려지기 때문이다.
이름 짓기가 어려운 것도 분석을 구체적으로 하지 않아서 발생한다.
이러면 함수나 클래스가 구체적으로 어떤 일을 해야 하는지 나타낼 수가 없어진다.
물론 대략적으로 두리뭉실하게 어느정도 알 수는 있다. 그러나 어느 정도의 분석과 구체적인 분석은 0과 1 만큼의 차이가 있다.
이렇게 중요한 분석인데 분석까지 생각이 미치기에는 너무 먼 거리이다 보니 좋은 코드가 특히 어려워진다.
이것은 분석을 구체화 할 수 있기 전까지 계속되는 문제다. 그런데 요구사항 구체화가 쉽지 않다. UML 메뉴얼을 읽는다고 전부는 아니다.

### 1. OOP와 패턴을 이해하기 어려운 이유

무엇이 어떻게 변할 것인지 파악되지 않아서다.

1. 기초 서적에서 제시하는 예시는 자동차, 사과와 같은 일반적인 사물이다. 그렇다 보니 형태가 있는 사물에 대해서만 객체로 해석하려는 경향이 있다. 그러나 시간, 약속, 건강상태 등도 모두 객체다.

1. 사실 함수 하나를 디자인 하는 것도 쉽지 않다. params로 user를 받을 것인가? user.id를 받을 것인가? 등등 선택의 기준은 무엇이 어떻게 변할 것인지 예측하기에 달렸다.\
그런 예측은 전체 구조에 영향을 줄 수 있다. 함수와 호출자 외에 전체적인 구조에 따라 달라진다.

> 같은 구역이면 user 다른 구역이면 userID

문제를 인식해야 필요성을 느끼고 해결책으로 객체지향적인 생각을 하게 되는데, 그렇지 못하기 때문에 OOP로 사고하는 것이 어렵다.
코드의 일부분만을 보고 그것이 전체에 미칠 영향을 파악할 수 있어야 한다. 이것은 많은 경험과 학습이 필요하다.

다음의 코드에서 어떤 문제가 있을 수 있을까?

```typescript
switch (lang) {
  case "kor":
    "안녕";
    break;
  case "eng":
    "hello";
    break;
  default:
    "unknown";
    break;
}
```

어떻게 하면 해결할 수 있을까?

```typescript
interface Country {
  hello(): string;
}

class KOR {
  public hello() {
    return "안녕";
  }
}

class ENG {
  public hello() {
    return "hello";
  }
}

const country = new KOR();
country.hello();
```

문제에 따른 해결책에 차이는 있겠지만 다른 패턴도 의존성/응집성에 대한 이야기다.

### 2. 테스트는 어렵다.

패턴에 익숙하기만 할 뿐이다. 코드 작성 중에 전략패턴과 같은 다양한 패턴을 익숙하게 구현할 수는 있지만 그것이 설계는 아니다.
설계 없이 이렇게 저렇게 바꿔가며 구현하는 중에 사용하는 도구 중에 하나일 뿐이다.
혹은 그것이 설계라고 한다면 적어도 요구사항을 분석하는 능력이 부족한 것이다.

아키텍처에 대한 더 많은 이해가 필요하다.
모듈로 나누고 레이어로 나누고 어느 범위까지 테스트를 할 것인가 등등.
유닛테스트라고 해서 정확하게 함수 하나만 테스트 하는 것이 아니다.

레이어드 아키텍처에 대한 이해. 상위 레이어에 대한 이해.

사족->사실 패턴도 유사하다, 무엇이 적절한 패턴인지 판단하려면 더 상위의/다른 객체의/환경 분석이 필요하다.

요구사항을 먼저 구체화 할 수 있어야 한다.

이것이 어렵기 때문에 DB먼저 설계하는 상향식 개발을 하게된다.

그런데 요즘은 orm을 사용해서 DB를 직접 사용하는 것을 피한다.

> 아포스티유 프로젝트에서 유사한 형식의 두 종류 문서가 있었다. 기존 구현된 DB는 하나로 관리하고 있었고 두 종류로 나누는 것은 번잡하게 느껴졌다. 그러나 내용이 유사하다 하더라도 두 개의 개별적인 문서다. 우연히 내용이 비슷하다고 해서 이것을 하나의 문서로 취급하면 나중에 기능이 확장될 때 문제가 될 수 있다.
> 실제로도 그랬다. 다행히 db는 하나로 관리해도 service api는 두 종류로 구분해서 문제가 크게 번지지는 않았다.
> 상위 레이어 혹은 분석에서 시작하는 것이 아니라 분석과 구현 단계의 구분없이 개발이 진행되면 흔히 발생한다.
> 이런 통찰력이 없으면 분석이 제대로 되지 않고 설계와 구현까지 두루 영향을 미친다.

### 3. 그러나 요구사항 구체화는 어렵다.

눈에 보이지 않는 무형의 논리와 개념을 체계적으로 시각화 하는 것은 원래 어려움. 건축은 그림으로 그리고 규격화도 되어있다.
그래서 프로그래머들은 습관적으로 DB부터 정의한다. 당장 눈에 보이고 동작하기 때문이다.
그러나 이런 상향식 설계는 결국 도메인과 구현의 불일치에 도달하게 된다.

설계의 중요성이 여기서 드러난다. 추상적 개념을 분석하고 눈에 보이는 문서로 표현할 수 있어야 한다.
대표적으로 UML이 있겠으나 형식은 상관없다.
21세기 초, 우리나라에서는 이 UML이 유행했었고 그렇게 지나갔다.
왜 그랬을까?
분석을 구체적으로 표현하지 못한다. 분석을 기반으로 설계를 해야 하는데 Layerd arch. 같은 개념의 이해 이전에 제대로 된 분석 문서가 없는 것이다.
어떻게 하면 분석한 내용을 UML같은 도구를 사용해서 문서로 표현할 수 있을까?

분석 -> 설계 -> 구현 -> 테스트의 반복인데 시작이 어렵다.

1. 분석은 어떻게 하는가? 어떻게 구체화 할 수 있는가? 누가/무엇을 하는지부터 시작해라. Use Case, Activity
   1. 예외 : 익숙하지 않은 기술을 사용하는 경우 연구와 개발을 병행하게 된다. 이런 경우에는 설계 후 구현이 힘들다.
      꼭 기술이 아니라도 요구사항 자체가 확정적이지 않은 경우가 있다.

### 4. 설계는 어렵다


### 결론 - 프로그래머는 왜 변화에 대응하기 어려운가.

하향식 개발을 지향해야 제대로 할 수 있다. 그러나 많은 것을 이해하고 경험하지 못하면 구체화 하기 어렵기 때문에 상향식을 추구하게 된다.
할 수 있는 것은 상향식이고 해야 하는 것은 하향식이다. 그 간극 만큼이나 개발방법론 등이 비현실적으로 느껴지게 된다.
여기서 얘기하려는 것은 그 간격을 매울 수 있는 기회가 되길 바란다.

개발환경도 큰 영향을 미치는데 보통은 쉬운 모듈은 주니어가 개발하고 좀 어렵다 싶은 것은 시니어가 개발한다.
그러다 보니 눈에 보이는 기능부터 만들게 되고 분석은 뒷전으로 밀려난다.
시니어가 분석과 설계를 해서 주니어에게 전달하면 어려움은 크게 해소될 수 있다.

그리고 좋은 코드는 단계적으로 완성되지 않는다.
무슨 말이냐 하면 리팩토링을 학습하면 10% 좋아지고 디자인패턴을 학습하면 또 10% 좋아지고 이렇게 되지 않는다.

리팩토링, 디자인패턴, TDD, DDD, UML설계, 결국은 분석
난 위의 순서로 학습을 했다 그러나 완전한 이해를 하지 못하더라도 DDD를 우선적으로 학습해야 할까?
DDD를 먼저 읽으면 지나친 이상론으로 보일지 모른다.
정답은 없으나 패턴/TDD/DDD에 대한 충분한 이해와 경험이 필요하다.
